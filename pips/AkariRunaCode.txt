from math import *
from random import *
from functools import *
from AkariDB import stacks, mceil
import discord
from discord.ext import commands, tasks
import sqlite3
import os
import re
import AkariDB as adb
import io
import ast
import asyncio
import time
import math
import random
import requests
from collections import Counter, defaultdict
import shutil
import datetime
import vk_api
from gtts import gTTS
from PIL import Image, ImageSequence
from PIL import ImageFont
from PIL import ImageDraw
from bs4 import BeautifulSoup
from pyppeteer import launch
import logging
from rnnmorph.predictor import RNNMorphPredictor

# TODO: обновить иконки ачивок, сделать их одинакового размера, ачивки в профиле, обновить профиль
#        добаивить сообщения ВК в стату и общую стату
# TODO: словари для описания команд и микрохелпа (списки на случай если нужно много страниц), ревизия команд
# TODO: обновить базу AkariCoder'a и добавить в неё руну и ботов телеги

# Contents:
# Vehicle class
# Nexus class
# Vehicle loading and saving
# Loops
# Nexus game functions
# Pictures and music
# Events
# Common functions
# Blackout
# Experience and statistics
# Achievements
# Server/Channel statistics and saving history into file
# Vehicle functions
# TGD functions
# Emoji functions
# VK commands
# Cogs

# Main Init
DIR = os.path.dirname(__file__)
db = sqlite3.connect(os.path.join(DIR, "Akari.db"))
SQL = db.cursor()

vk_session = vk_api.VkApi(token=open('vktoken.txt').readlines()[0])
vka = vk_session.get_api()

client = discord.Client()
bot = commands.Bot(command_prefix=adb.prefix, intents=discord.Intents.all())
bot.remove_command("help")
start_time = time.time()

predictor = RNNMorphPredictor(language="ru")

# Logging
logger = logging.getLogger('AkariWood')
logger.setLevel(logging.INFO)
if not os.path.exists('logs'):
    os.mkdir('logs')
fh = logging.FileHandler(f'logs/Akari-{time.strftime("%d.%m.%Y-%H.%M", time.localtime())}.txt')
formatter = logging.Formatter('%(asctime)s - %(name)s - %(levelname)s - %(message)s')
fh.setFormatter(formatter)
logger.addHandler(fh)
def logg(x):
    return logger.info(re.sub(r'[^\w\s:()\-<>.,/]|\n', '', x))


# Some Vars
activetimers = []
achs = []
expd = defaultdict(dict)
emosdict = defaultdict(dict)
meslogs = defaultdict(list)
mlFlags = defaultdict(bool)
quis = {}
ACPvars = {}

# Future Vars
bbag = None
programistishe = None
monopolishe = None
mainchannel = None
logchannel = None

# Nexus Vars
nexus1 = None
nexus2 = None
nex1roles = []
nex2roles = []
kingrole = None
mainchannel2 = None
mainchannel2id = 823312775468023858
# TODO: json but not db
"""
nexus: class Nexus and db
nexus_damage: only db
nexus_items: only db
nexus_player_items: class Vehicle and db
nexus_players: class Vehicle, id in class Nexus and db
nexus_players_total: only db
nexus_sets: only db
"""


class Vehicle:
    """
    experience, statistics, custom user-linked emojis, nexus items and stuff
    """
    def __init__(self, sd, new=False):
        self.id = int(sd[0])
        self.server = int(sd[1])
        self.emos = []
        self.bottle = False
        if new:
            self.exp = defaultdict(int)
            self.bbagid = 0
            self.role = defaultdict(int)
            self.name = None
            self.vkid = 0
            self.vkemo = ''
            return
        self.bbagid = int(sd[2])
        self.name = sd[3]
        self.exp = {'exp': int(sd[4]), 'allmessages': int(sd[5]), 'messages': int(sd[6]),
                    'pictures': int(sd[7]), 'mentions': int(sd[8]), 'smiles': int(sd[9]),
                    'mat': sd[14], 'online': sd[15], 'symbols': sd[16], 'selfsmiles': sd[17],
                    'bottles': sd[18], 'dayphrases': sd[19], 'stickers': sd[20], 'vkmes': sd[21],
                    'lastbottle': sd[22]}
        if sd[23]:
            print(f'На бутылке: {sd[3]} ({int(sd[0])})')
            self.bottle = True
        if sd[10]:
            self.role = {'id': int(sd[10]), 'color': int(sd[11], 16)}
        else:
            self.role = defaultdict(int)
        self.vkid = sd[12]
        self.vkemo = sd[13]
        
    def __str__(self):
        c = [self.exp['allmessages'], self.exp['messages'], self.exp['pictures'], self.exp['mentions'], self.exp['smiles']]
        return f'{self.name} {self.id} from {self.server}, exp: {self.exp["exp"]}, counters={c}'

    def __eq__(self, other):
        if self.id == other.id and self.server == other.server:
            return True
        return False

    async def addexp(self, eadd, channel=None, reason='', mem=None):
        if eadd == 0:
            return
        if self.server == adb.bbag:
            if not mem:
                mem = bot.get_guild(self.server).get_member(self.id)
            roles = [i.id for i in mem.roles]
            if adb.congrats in roles:
                eadd = int(eadd * adb.ek_congrats)
        if self.bottle:
            eadd = int(eadd * adb.ek_bottle)
        lvl = adb.levelget(self.exp['exp'])
        self.exp['exp'] += eadd
        if reason:
            if reason != 'online':
                print(f'{self.name} получил {eadd} exp ({reason})')
            logg(f'exp: {self.name} ({self.server}/{self.id}) <- {eadd} exp ({reason})')
        else:
            print(f'{self.name} получил {eadd} exp')
            logg(f'exp: {self.name} ({self.server}/{self.id}) <- {eadd} exp')
        lvl_new = adb.levelget(self.exp['exp'])
        if lvl_new > lvl and self.bbagid <= 10:
            if self.server == adb.bbag:
                if not channel:
                    channel = mainchannel
                if os.path.exists('music') and os.listdir('music') and mem:
                    sound = random.choice(os.listdir('music'))
                    if mem.voice and mem.voice.channel:
                        await forceplay(sound, mem.voice.channel)
                    else:
                        vv = None
                        vvn = -1
                        for vc in mem.guild.voice_channels:
                            if len(vc.members) > vvn:
                                vvn = len(vc.members)
                                vv = vc
                        if vvn > 0:
                            await forceplay(sound, vv)
            else:
                return
            await channel.send(f'{rolemention(self)} апнул новый **{lvl_new}** уровень!', file=number_gif(lvl_new))
            print(f'{self.name} апнул {lvl_new} уровень!')
            logg(f'lvlup: {self.name} ({self.server}/{self.id}) <- {lvl_new} уровень!')


class Nexus:
    """Nexus game"""
    def __init__(self):
        data = None
        last_time = 0
        for i in os.listdir('nexus/data'): # find newest nexus
            le = ast.literal_eval(open(f'nexus/data/{i}').read())
            if le['last_played'] > last_time:
                last_time = le['last_played']
                data = le
        if not data: # if not found, create one
            data = {'season': 1, 'year': int(time.strftime("%y")), 'month': int(time.strftime("%m")), 'players': {},
                    'health0': 1000, 'health1': 1000, 'style': 'hotwater', 'img': 'nexus/data/1.png', 'days': 0}
            with open('nexus/data/1.png', 'w', encoding='uif-8') as f:
                f.write(data)
        self.data = data

    def add_player(self, mid, side):  # side 0 or 1
        self.data['players'][mid] = side

    def remove_player(self, mid):
        if mid in self.data['players']:
            del self.data['players'][mid]

    async def get_damage(self, id, player_id, dmg, reason):
        raw_damage = int(dmg)
        pure = True if 17 in expd[adb.bbag][id].nitems.keys() else False
        items = []
        for p in self.players:
            items += list(expd[adb.bbag][p].nitems.keys())
        if not pure:
            if 2 in items:
                pp = [[p, self.players[p]] for p in self.players if 2 in expd[adb.bbag][p].nitems.keys()][0]
                df = 10 if dmg > 10 else int(dmg)
                SQL.execute(f'UPDATE nexus_players SET damage_block = damage_block + {df} WHERE player_id = {pp[1]}')
                SQL.execute(f'UPDATE nexus_players_total SET damage_block = damage_block + {df} WHERE id = {pp[0]}')
                expd[adb.bbag][pp[0]].nplayer["damage_block"] += df
                dmg -= 10
            if reason != 'daily' and 12 in items:
                pp = [[p, self.players[p]] for p in self.players if 12 in expd[adb.bbag][p].nitems.keys()][0]
                df = 30 if dmg > 30 else int(dmg)
                SQL.execute(f'UPDATE nexus_players SET damage_block = damage_block + {df} WHERE player_id = {pp[1]}')
                SQL.execute(f'UPDATE nexus_players_total SET damage_block = damage_block + {df} WHERE id = {pp[0]}')
                expd[adb.bbag][pp[0]].nplayer["damage_block"] += df
                dmg -= 30
            if (1 in items and adb.chance(25)) or dmg < 0:
                pp = [[p, self.players[p]] for p in self.players if 1 in expd[adb.bbag][p].nitems.keys()][0]
                df = int(dmg)
                SQL.execute(f'UPDATE nexus_players SET damage_block = damage_block + {df} WHERE player_id = {pp[1]}')
                SQL.execute(f'UPDATE nexus_players_total SET damage_block = damage_block + {df} WHERE id = {pp[0]}')
                expd[adb.bbag][pp[0]].nplayer["damage_block"] += df
                dmg = 0
            if self.side == 2:
                dmg *= 0.9
        dmg = int(dmg)
        self.health -= dmg
        SQL.execute(f'UPDATE nexus SET health = {self.health} WHERE id = {self.id}')
        SQL.execute(f'UPDATE nexus_players SET damage = damage + {dmg} WHERE player_id = {player_id}')
        SQL.execute(f'UPDATE nexus_players_total SET damage = damage + {dmg} WHERE id = {id}')
        expd[adb.bbag][id].nplayer["damage"] += dmg
        if reason == 'daily':
            SQL.execute(f'UPDATE nexus_players SET day_damage = day_damage + {dmg} WHERE player_id = {player_id}')
            SQL.execute(f'UPDATE nexus_players_total SET day_damage = day_damage + {dmg} WHERE id = {id}')
            expd[adb.bbag][id].nplayer["day_damage"] += dmg
        sql_insert = f'INSERT INTO nexus_damage(nexus_id, player_id, damage, raw_damage, reason, time, day) VALUES (?,?,?,?,?,?,?)'
        data = (self.id, player_id, dmg, raw_damage, reason, int(time.time()), self.days)
        SQL.execute(sql_insert, data)
        db.commit()
        res = [[id, dmg, reason, self.side]]
        if self.health <= 0:
            res[0].append('death')
        if 15 in items and adb.chance(10):
            pp = [[p, self.players[p]] for p in self.players if 10 in expd[adb.bbag][p].nitems.keys()][0]
            if self.side == 1:
                data2 = await nexus2.get_damage(pp[0], pp[1], dmg, 'Банка с хреном')
            else:
                data2 = await nexus1.get_damage(pp[0], pp[1], dmg, 'Банка с хреном')
            res += data2
        return res

    async def get_heal(self, id, player_id, heal, reason):
        raw_heal = int(heal)
        heal = int(heal)
        self.health += heal
        SQL.execute(f'UPDATE nexus SET health = {self.health} WHERE id = {self.id}')
        SQL.execute(f'UPDATE nexus_players SET heal = heal + {heal} WHERE player_id = {player_id}')
        SQL.execute(f'UPDATE nexus_players_total SET heal = heal + {heal} WHERE id = {id}')
        expd[adb.bbag][id].nplayer["heal"] += heal
        sql_insert = f'INSERT INTO nexus_damage(nexus_id, player_id, damage, raw_damage, reason, time, day) VALUES (?,?,?,?,?,?,?)'
        data = (self.id, player_id, heal*-1, raw_heal*-1, reason, int(time.time()), self.days)
        SQL.execute(sql_insert, data)
        db.commit()
        res = [[id, heal*-1, reason, self.side]]
        return res


# ----------------------------------------------------------------------------------------------------------------------
# Vehicle loading and saving
def AELoad():
    global expd
    global emosdict
    for c in SQL.execute('SELECT * FROM exp').fetchall():
        expd[c[1]][c[0]] = Vehicle(c)
    for g in bot.guilds:
        for m in g.members:
            try:
                if not expd[g.id][m.id]:
                    print(g.id, m.id)
            except:
                expd[g.id][m.id] = Vehicle([g.id, m.id], True)
    for e in SQL.execute('SELECT * FROM emos').fetchall():
        if e[5]:
            code = f'<a:{e[0]}:{e[1]}>'
        else:
            code = f'<:{e[0]}:{e[1]}>'
        if not emosdict[e[2]]:
            emosdict[e[2]] = defaultdict(str)
        emosdict[e[2]][e[0]] = code
        if 0 < e[2] < 11:
            for g in expd:
                for m in expd[g]:
                    if e[2] == expd[g][m].bbagid:
                        expd[g][m].emos.append(code)
    for a in SQL.execute('SELECT * FROM achs').fetchall():
        ach = {'owner': a[0], 'name': a[2], 'level': a[3], 'value': a[4], 'date': a[5]}
        achs.append(ach)


def AESavedef(reason=None):
    for g in expd:
        for m in expd[g]:
            i = expd[g][m].exp
            SQL.execute(f'SELECT * FROM exp WHERE id = {m} AND server = {g}')
            u = SQL.fetchall()
            if not u:
                sql_insert = 'INSERT INTO exp(id, server, exp, allmessages, messages, pictures, mentions, smiles, mat, online, symbols, selfsmiles, bottles, dayphrases, stickers, vkmes, lastbottle) VALUES (?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?)'
                SQL.execute(sql_insert, (
                    m, g, i['exp'], i['allmessages'], i['messages'], i['pictures'], i['mentions'], i['smiles'], i['mat'], i['online'], i['symbols'], i['selfsmiles'], i['bottles'], i['dayphrases'], i['stickers'], i['vkmes'], i['lastbottle']))
                db.commit()
            else:
                SQL.execute(
                    f"UPDATE exp SET exp = {i['exp']}, allmessages = {i['allmessages']}, messages = {i['messages']}, pictures = {i['pictures']}, mentions = {i['mentions']}, smiles = {i['smiles']} WHERE id = {m} AND server = {g}")
                SQL.execute(
                    f"UPDATE exp SET mat = {i['mat']}, online = {i['online']}, symbols = {i['symbols']}, selfsmiles = {i['selfsmiles']}, bottles = {i['bottles']} WHERE id = {m} AND server = {g}")
                SQL.execute(
                    f"UPDATE exp SET vkmes = {i['vkmes']}, lastbottle = '{i['lastbottle']}' WHERE id = {m} AND server = {g}")
                SQL.execute(
                    f"UPDATE exp SET dayphrases = {i['dayphrases']}, stickers = {i['stickers']} WHERE id = {m} AND server = {g}")
    db.commit()
    if reason:
        logg(f'aesave: DB saved after '+reason)
    else:
        logg(f'aesave: DB saved after a while...')


@tasks.loop(minutes=adb.e_savetime)
async def AESavetask():
    AESavedef()


# ----------------------------------------------------------------------------------------------------------------------
# Loops
@tasks.loop(minutes=adb.e_onlinetime)
async def online_counter():
    mems = []
    trans_time = datetime.datetime.utcnow() - datetime.timedelta(minutes=adb.e_onlinetime)
    async for mes in mainchannel.history(after=trans_time):
        mems.append(mes.author.id)
    async for mes in programistishe.history(after=trans_time):
        mems.append(mes.author.id)
    async for mes in monopolishe.history(after=trans_time):
        mems.append(mes.author.id)
    for v in bbag.voice_channels:
        if len(v.members) > 1:
            for m in v.members:
                if m.voice and not m.voice.self_deaf:
                    mems.append(m.id)
    mems = list(set(mems))
    for m in mems:
        if 0 < expd[adb.bbag][m].bbagid < 11:
            await expd[adb.bbag][m].addexp(adb.e_online, reason='online')
            expd[adb.bbag][m].exp['online'] += adb.e_onlinetime
            await sum_achieve(m, {"online": True})
            await asyncio.sleep(1)


@tasks.loop(hours=1)
async def daycheck():
    if time.strftime("%H") == "17":
        if not os.path.exists('AEBackups'):
            os.mkdir('AEBackups')
        shutil.copyfile("Akari.db", f"AEBackups/Akari{random.randint(10000, 99999)}.db")


@tasks.loop(hours=1)
async def daymeme():
    if time.strftime("%H") == "18":
        mems = []
        async for m in bot.get_channel(adb.bbagpics).history(limit=10000):
            mems += [a.url for a in m.attachments]
        if mems:
            emb = discord.Embed(title='Мем дня')
            emb.set_image(url=random.choice(mems))
            mes = await mainchannel.send(embed=emb)
            await mes.add_reaction(get_emoji('TemaOr'))
            await mes.add_reaction(get_emoji('Tthinking'))
            await mes.add_reaction(get_emoji('FaceTem'))
            await mes.add_reaction(get_emoji('hateful'))


@tasks.loop(hours=1)
async def daybottle():
    if time.strftime("%H") == "20":
        mem = random.choice([i for i in expd[adb.bbag] if 0 < expd[adb.bbag][i].bbagid < 11])
        await bottledef(mem)


@tasks.loop(hours=1)
async def dayphrase():
    if time.strftime("%H") == "22":
        file = open('pips/phrases.txt', encoding='utf-8').readlines()
        phrase = random.choice(file)
        author = ''
        if '©' in phrase:
            phrase, author = phrase.split('©')
        phrase.rstrip()
        emb = discord.Embed(title='Фраза дня', description=phrase)
        if author:
            url = ''
            member = author.split('+')[0].split(' ')[0].replace('\n', '')
            for m in expd[adb.bbag]:
                if expd[adb.bbag][m].name == member:
                    try:
                        mem = bot.get_guild(adb.bbag).get_member(m)
                        url = mem.avatar_url
                    except:
                        continue
            if url:
                emb.set_footer(icon_url=url, text=f'©{author}')
                expd[adb.bbag][mem.id].exp['dayphrases'] += 1
                await expd[adb.bbag][mem.id].addexp(adb.e_dayphrase, reason='фраза дня', mem=mem)
        mes = await mainchannel.send(embed=emb)
        await mes.add_reaction(get_emoji('TemaOr'))
        await mes.add_reaction(get_emoji('Tthinking'))
        AESavedef('a dayphrase')


@tasks.loop(minutes=3)
async def achieve_giver():
    for m in expd[adb.bbag]:
        if not 0 < expd[adb.bbag][m].bbagid < 11:
            continue
        for i in adb.achieves:
            c, ac, s, n, t, d, icon = i['counts'], i['addcount'], i['stat'], i['name'], i['title'], i['desc'], i['icon']
            cur_levels = [a['level'] for a in achs if a['owner'] == m and a['name'] == n]
            nextlevel = max(cur_levels) + 1 if cur_levels else 1
            nextvalue = c[nextlevel - 1] if nextlevel <= len(c) else c[-1] + ac * (nextlevel - len(c))
            value = adb.levelget(expd[adb.bbag][m].exp[s]) if s == 'exp' else expd[adb.bbag][m].exp[s]
            if value >= nextvalue:
                ach = {'name': n, 'level': nextlevel, 'value': nextvalue,
                       'date': time.strftime("%d.%m.%Y, %H:%M", time.localtime()), 'owner': m}
                achs.append(ach)
                save_achieve(ach)
                title = f'{t} {adb.to_roman(nextlevel)}'
                desc = d.format(nextvalue)
                purl = await picfinder(icon)
                emb = discord.Embed(title='Achievement get!',
                                    description=f'**{title}**\n{desc}\nНаграду получил: {rolemention(expd[adb.bbag][m])}')
                emb.set_image(url=purl)
                await mainchannel.send(embed=emb)
                await expd[adb.bbag][m].addexp(adb.e_ach + nextlevel * adb.e_ach_lvladd,
                                               reason=f'{n} {adb.to_roman(nextlevel)}')
                AESavedef('giving an achieve')


@tasks.loop(hours=1)
async def bbag_reminder():
    hour = int(time.strftime("%H"))
    picname = ''
    if picname and 7 < hour < 22 and hour % 3 == 2:
        purl = await picfinder(picname)
        mes = await mainchannel.send(purl)
        await mes.add_reaction('<:agroMornyX:833000410976354334>')


@tasks.loop(hours=1)
async def all_guilds_save():
    if time.strftime("%d") == "24" and time.strftime("%H") == "11":
        if adb.if_host:
            for g in bot.guilds:
                savepics = 'False' if g.id in adb.guildsave_pic_blacklist else ''
                await guildsavedef(g, None, savepics, f'D:/Brutal Bro Abnormal Gang/Archives/{g.name}')
        else:
            tai = bot.get_guild(adb.dmh).get_channel(adb.taisetsu)
            await tai.send('Время делать бекап!')


@tasks.loop(seconds=10)
async def voice_disconnect():
    voice = discord.utils.get(bot.voice_clients, guild=bbag)
    if voice and voice.is_connected() and not voice.is_playing():
        await voice.disconnect()


# ----------------------------------------------------------------------------------------------------------------------
# Nexus game functions
def nsort(l):
    pass


def nexus_draw():
    phone = Image.open(f'nexus/{nexus1.season}_raw.png').convert('RGBA')
    SQL.execute(f'SELECT * FROM nexus_style_poses WHERE style = "{nexus1.style}"')
    pos1 = SQL.fetchone()
    SQL.execute(f'SELECT * FROM nexus_style_poses WHERE style = "{nexus2.style}"')
    pos2 = SQL.fetchone()
    imgs1 = random.shuffle([i for i in nexus1.players])
    imgs2 = random.shuffle([i for i in nexus2.players])

    for i, id in enumerate(imgs1):
        idx = len(imgs1)-i-1
        items = []
        if pos1[idx][5]:
            pad = Image.open(f'nexus/pad_{nexus1.style}.png').convert('RGBA')
            if pos1[idx][8] != 100:
                h, w = pad.size
                pad = pad.resize((h*pos1[idx][8]/100, w*pos1[idx][8]/100))
            phone.paste(pad, (pos1[idx][6], pos1[idx][7]), pad)

        img = Image.open(f'nexus/{expd[adb.bbag][id].nplayer["icon"]}').convert('RGBA')
        if pos1[idx][4] != 100:
            h, w = img.size
            img = img.resize((h * pos1[idx][4] / 100, w * pos1[idx][4] / 100))
        phone.paste(img, (pos1[idx][2], pos1[idx][3]), img)

        av = Image.open(f'nexus/a{expd[adb.bbag][id].bbagid}.png').convert('RGBA')
        if pos1[idx][4] != 100:
            h, w = av.size
            av = av.resize((h * pos1[idx][4] / 100, w * pos1[idx][4] / 100))
        phone.paste(av, (pos1[idx][2]+22, pos1[idx][3]-17), av)

        nitems = nsort(list(expd[adb.bbag][id].nitems.keys()))
        for item in nitems:
            itg = Image.open(f'nexus/i{item}.png').convert('RGBA')
            if pos1[idx][4] != 100:
                h, w = itg.size
                av = itg.resize((h * pos1[idx][4] / 100, w * pos1[idx][4] / 100))

            idata = SQL.execute(f'SELECT * FROM nexus_poses WHERE pose_id = 1 AND item_id = {item}').fetchone()
            if idata[2] != 100:
                h, w = itg.size
                av = itg.resize((h * pos1[idx][2] / 100, w * pos1[idx][2] / 100))
            if item in [13]:
                eyepose = SQL.execute(f'SELECT nexus_eyes FROM exp WHERE id = {id}').fetchone()[0] # FIXME: этого нет в exp
                phone.paste(av, (pos1[idx][2]+int(eyepose.split('.'[0]))-13, pos1[idx][3]), av)
            else:
                phone.paste(av, (pos1[idx][2] + idata[3], pos1[idx][3] + idata[4]), av)
            items.append(item)

    for i, id in enumerate(imgs2):
        idx = len(imgs2)-i-1
        items = []

        if pos2[idx][5]:
            pad = Image.open(f'nexus/pad_{nexus2.style}.png').convert('RGBA')
            if pos2[idx][8] != 100:
                h, w = pad.size
                pad = pad.resize((h*pos2[idx][8]/100, w*pos2[idx][8]/100))
            phone.paste(pad, (pos2[idx][6], pos2[idx][7]), pad)

        img = Image.open(f'nexus/{expd[adb.bbag][id].nplayer["icon"]}').convert('RGBA')
        if pos2[idx][4] != 100:
            h, w = img.size
            img = img.resize((h * pos2[idx][4] / 100, w * pos2[idx][4] / 100))
        phone.paste(img, (pos2[idx][2], pos2[idx][3]), img)

        av = Image.open(f'nexus/a{expd[adb.bbag][id].bbagid}.png').convert('RGBA')
        if pos2[idx][4] != 100:
            h, w = av.size
            av = av.resize((h * pos2[idx][4] / 100, w * pos2[idx][4] / 100))
        phone.paste(av, (pos2[idx][2]+22, pos2[idx][3]-17), av)

        nitems = nsort(list(expd[adb.bbag][id].nitems.keys()))
        for item in nitems:
            itg = Image.open(f'nexus/i{item}.png').convert('RGBA')
            if pos2[idx][4] != 100:
                h, w = itg.size
                av = itg.resize((h * pos2[idx][4] / 100, w * pos2[idx][4] / 100))

            idata = SQL.execute(f'SELECT * FROM nexus_poses WHERE pose_id = 1 AND item_id = {item}').fetchone()
            if idata[2] != 100:
                h, w = itg.size
                av = itg.resize((h * pos2[idx][2] / 100, w * pos2[idx][2] / 100))
            if item in [13]:
                eyepose = SQL.execute(f'SELECT eyepose FROM exp WHERE id = {id}').fetchone()[0] # FIXME: этого нет в exp
                phone.paste(av, (pos2[idx][2]+int(eyepose.split('.'[0]))-13, pos2[idx][3]), av)
            else:
                phone.paste(av, (pos2[idx][2] + idata[3], pos2[idx][3] + idata[4]), av)
            items.append(item)

    phone.save(f'nexus/{nexus1.season}.png')
    file = discord.File(fp=f'nexus/{nexus1.season}.png')
    return file


def nexus_starter():
    if adb.nexus_on:
        global nex1roles
        global nex2roles
        for i in adb.nexusroles[1]:
            role = bbag.get_role(i)
            nex1roles.append(role)
        for i in adb.nexusroles[2]:
            role = bbag.get_role(i)
            nex2roles.append(role)
        SQL.execute('SELECT * FROM nexus WHERE side = 1 ORDER BY season DESC')
        n1 = SQL.fetchone()
        if not n1:
            print('\033[31m\033[1mОшибка: нет нексуса в базе данных')
            return
        SQL.execute(f'SELECT * FROM nexus WHERE side = 2 AND season = {n1[1]}')
        n2 = SQL.fetchone()
        if not n2:
            print('\033[31m\033[1mОшибка: нет второго нексуса в базе данных')
            return
        if n1[5] <= 0 or n2[5] <= 0:
            print('\033[31m\033[1mОшибка: у нексуса нет здоровья')
            return

        global nexus1
        global nexus2
        nexus1 = Nexus(n1)
        nexus2 = Nexus(n2)
        p1 = SQL.execute(f"SELECT * FROM nexus_players WHERE nexus_id = {nexus1.id}").fetchall()
        p2 = SQL.execute(f"SELECT * FROM nexus_players WHERE nexus_id = {nexus2.id}").fetchall()
        nexus1.add_players(p1)
        nexus2.add_players(p2)
        for p in p1+p2:
            expd[adb.bbag][p[2]].nplayer = {'player_id': p[0], 'nexus_id': p[1], 'level': p[3], 'icon': p[4], 'damage': p[6], 'heal': p[7], 'damage_block': p[8], 'day_damage': p[9]}
            items = SQL.execute(f"SELECT * FROM nexus_items WHERE item_id in "
                                f"(SELECT item_id FROM nexus_player_items WHERE player_id = {p[0]})").fetchall()
            expd[adb.bbag][p[2]].nitems = {i[0]: {'id': i[0], 'name': i[1], 'description': i[2], 'level': i[3], 'season': i[4], 'icon': i[5]} for i in items}


@tasks.loop(hours=1)
async def nexus_daily():
    if adb.nexus_on:
        if time.strftime("%H") == "06":
            global nexus1
            global nexus2
            endFlag = 0
            if time.strftime("%d") != "01":
                items1 = []
                items2 = []
                dmgl = []
                for p in nexus1.players:
                    items1 += list(expd[adb.bbag][p].nitems.keys())
                for p in nexus2.players:
                    items2 += list(expd[adb.bbag][p].nitems.keys())
                for p in nexus1.players:
                    pitems = expd[adb.bbag][p].nitems.keys()
                    dmg = 10
                    if 4 in items1:
                        dmg *= 2
                    if 13 in pitems:
                        dmg *= 1.5
                    if 6 in pitems and adb.chance(25):
                        dmg *= 2
                    if 16 in pitems and adb.chance(20):
                        dmg *= 1.5
                    if 3 in items2:
                        dmg = 0
                    dmgi = await nexus2.get_damage(p, nexus1.players[p], dmg, 'daily')
                    dmgl += dmgi
                    if 9 in items1:
                        heal = dmgi[0][3] / 2
                        pp = [[p, nexus1.players[p]] for p in nexus1.players if 10 in expd[adb.bbag][p].nitems.keys()][0]
                        dmgi = await nexus1.get_heal(pp[0], pp[1], heal, 'Ангельское крыло')
                        dmgl += dmgi
                    if 10 in items2:
                        pp = [[p, nexus2.players[p]] for p in nexus2.players if 10 in expd[adb.bbag][p].nitems.keys()][0]
                        dmgi = await nexus1.get_damage(pp[0], pp[1], dmg / 2, 'Зеркало души')
                        dmgl += dmgi
                for p in nexus2.players:
                    pitems = expd[adb.bbag][p].nitems.keys()
                    dmg = 10
                    if 4 in items2:
                        dmg *= 2
                    if 13 in pitems:
                        dmg *= 1.5
                    if 6 in pitems and adb.chance(25):
                        dmg *= 2
                    if 16 in pitems and adb.chance(20):
                        dmg *= 1.5
                    if 3 in items1:
                        dmg = 0
                    dmgi = await nexus1.get_damage(p, nexus2.players[p], dmg, 'daily')
                    dmgl += dmgi
                    if 9 in items2:
                        heal = dmgi[0][3] / 2
                        pp = [[p, nexus2.players[p]] for p in nexus2.players if 10 in expd[adb.bbag][p].nitems.keys()][0]
                        dmgi = await nexus2.get_heal(pp[0], pp[1], heal, 'Ангельское крыло')
                        dmgl += dmgi
                    if 10 in items1:
                        pp = [[p, nexus1.players[p]] for p in nexus1.players if 10 in expd[adb.bbag][p].nitems.keys()][0]
                        dmgi = await nexus2.get_damage(pp[0], pp[1], dmg / 2, 'Зеркало души')
                        dmgl += dmgi
                if nexus1.health > 0:
                    SQL.execute(f'UPDATE nexus SET days = days+1 WHERE id = {nexus1.id}')
                    nexus1.days += 1
                if nexus2.health > 0:
                    SQL.execute(f'UPDATE nexus SET days = days+1 WHERE id = {nexus2.id}')
                    nexus2.days += 1
                db.commit()
                emb = discord.Embed(title=f'Дневной урон, день {max([nexus1.days, nexus2.days])}')
                d1 = ''
                d2 = ''
                for i in dmgl:
                    if i[3] == 2:
                        d1 += f'{bbag.get_role(expd[adb.bbag][i[0]].role["id"]).mention}{random.choice(expd[adb.bbag][i[0]].emos)} наносит **{i[1]}**'
                        if i[2] != 'daily':
                            d1 += f' by {i[2]}'
                        d1 += '\n'
                    if i[3] == 1:
                        d2 += f'{bbag.get_role(expd[adb.bbag][i[0]].role["id"]).mention}{random.choice(expd[adb.bbag][i[0]].emos)} наносит **{i[1]}**'
                        if i[2] != 'daily':
                            d2 += f' by **{i[2]}**'
                        d2 += '\n'
                for i in dmgl[::-1]:
                    if i[-1] == 'death':
                        endFlag = i[3]
                if not d1:
                    d1 = 'Нет'
                if not d2:
                    d2 = 'Нет'
                emb.add_field(name='☀️Свет', value=d1)
                emb.add_field(name='🌙️ Тьма', value=d2)
                await mainchannel2.send(embed=emb)
            mesdays = [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31]
            mesidx = int(time.strftime("%m")) - 1
            if endFlag or time.strftime("%d") == str(mesdays[mesidx]):
                if endFlag == 1:
                    halfor = 1
                    winners = nexus1.players.keys()
                    emb = discord.Embed(title=f'Nexus Battle Season {nexus1.season} End',
                                        description=f'Игра закончилась! Победила команда ☀️Света!')
                elif endFlag == 2:
                    halfor = 1
                    winners = nexus2.players.keys()
                    emb = discord.Embed(title=f'Nexus Battle Season {nexus1.season} End',
                                        description=f'Игра закончилась! Победила команда 🌙️ Тьмы!')
                else:
                    if nexus1.health == nexus2.health:
                        halfor = 0.5
                        winners = list(nexus1.players.keys()) + list(nexus2.players.keys())
                        emb = discord.Embed(title=f'Nexus Battle Season {nexus1.season} End',
                                            description=f'Игра закончилась! Между командами ничья! У обоих нексусов осталось {nexus1.health} здоровья')
                    elif nexus1.health > nexus2.health:
                        halfor = 1
                        winners = nexus1.players.keys()
                        emb = discord.Embed(title=f'Nexus Battle Season {nexus1.season} End',
                                            description=f'Игра закончилась! Победила команда ☀️Света!')
                    else:
                        halfor = 1
                        winners = nexus2.players.keys()
                        emb = discord.Embed(title=f'Nexus Battle Season {nexus1.season} End',
                                            description=f'Игра закончилась! Победила команда 🌙️ Тьмы!')
                desc = ''
                maxdmg = 0
                maxdmgp = None
                for p in winners:
                    desc += f'{bbag.get_role(expd[adb.bbag][p].role["id"]).mention}{random.choice(expd[adb.bbag][p].emos)}:\n  Урон: **{expd[adb.bbag][p].nplayer["damage"]}**, **{expd[adb.bbag][p].nplayer["level"]}** уровень,\n' \
                            f'  блок урона: **{expd[adb.bbag][p].nplayer["damage_block"]}**, хил: **{expd[adb.bbag][p].nplayer["heal"]}** уровень\n'
                    dmg = expd[adb.bbag][p].nplayer["damage"] + expd[adb.bbag][p].nplayer["damage_block"] + expd[adb.bbag][p].nplayer["heal"]
                    if dmg > maxdmg:
                        maxdmg = dmg
                        maxdmgp = p
                    await expd[adb.bbag][p].addexp(int(adb.e_nexwinner * halfor), reason='Nexus winner!')
                for p in list(nexus1.players.keys()) + list(nexus2.players.keys()):
                    expd[adb.bbag][p].nitems = defaultdict(int)
                    expd[adb.bbag][p].nplayer = defaultdict(int)
                emb.add_field(name='Игроки-победители', value=desc)
                img = nexus_draw()
                mes = await logchannel.send(file=img)
                nexus1.img = mes.attachments[0].url
                emb.set_image(url=nexus1.img)
                SQL.execute('SELECT * FROM nexus WHERE side = 1 ORDER BY season DESC')
                n1 = SQL.fetchone()
                SQL.execute(f'SELECT * FROM nexus WHERE side = 2 AND season = {n1[1]}')
                n2 = SQL.fetchone()
                icon1 = f'{n1[1] + 1}.png' if f'{n1[1] + 1}.png' in os.listdir('nexus') else ''
                icon2 = f'{n2[1] + 1}.png' if f'{n2[1] + 1}.png' in os.listdir('nexus') else ''
                data1 = (n1[0] + 2, n1[1] + 1, 0, 0, 1, 1000, n1[6], icon1, 0)
                data2 = (n2[0] + 2, n2[1] + 1, 0, 0, 2, 1000, n2[6], icon2, 0)
                nexus1 = Nexus(data1)
                nexus2 = Nexus(data2)
                sql_insert = f"INSERT INTO nexus(id, season, year, month, side, health, style, img, days) VALUES (?,?,?,?,?,?,?,?,?)"
                SQL.execute(sql_insert, data1)
                SQL.execute(sql_insert, data2)
                SQL.execute(f"UPDATE sets SET value = 0 WHERE name = 'cd1_cz'")
                SQL.execute(f"UPDATE sets SET value = 0 WHERE name = 'cd1_8ball'")
                SQL.execute(f"UPDATE sets SET value = 0 WHERE name = 'cd1_spor'")
                SQL.execute(f"UPDATE sets SET value = 0 WHERE name = 'cd1_flip'")
                SQL.execute(f"UPDATE sets SET value = 0 WHERE name = 'cd2_cz'")
                SQL.execute(f"UPDATE sets SET value = 0 WHERE name = 'cd2_8ball'")
                SQL.execute(f"UPDATE sets SET value = 0 WHERE name = 'cd2_spor'")
                SQL.execute(f"UPDATE sets SET value = 0 WHERE name = 'cd2_flip'")
                db.commit()
                for m in bbag.members:
                    for r in nex1roles + nex2roles + [kingrole]:
                        await m.remove_roles(r)
                    if m.id == maxdmgp:
                        await m.add_roles(kingrole)
                await mainchannel2.send(embed=emb)
            else:
                emb = discord.Embed(title=f'Nexus Battle Season {nexus1.season}',
                                    description='Добро пожаловать на битву Нексусов! Присоединяйтесь к силам света и тьмы, играйте в мини-игры, находите предметы и уничтожьте Нексус врага!')
                emb.add_field(name="Свет ☀️",
                              value='Силы света наносят на 20% больше урона, участвуя в играх. Приходи к нам за лучиком добра')
                emb.add_field(name="Игры",
                              value=f'Игры приносят много очков, но имеют большой кулдаун:\n**;flip 0|1** {adb.reload} 3d'
                                    f'\n**;spor** {adb.reload} 2d\n**;cz** {adb.reload} 3d'
                                    f'**;8ball** {adb.reload} 2d')
                emb.add_field(name="Тьма 🌙",
                              value='Силы тьмы получают на 10% меньше урона от любых источников. Переходи к нам, у нас есть печеньки')
                emb.add_field(name="Уровни",
                              value='Повышайте мастерство владения светом или тьмой, нанося урон Нексусу врага. Уровень сбросится, если сменить сторону!')
                emb.add_field(name="Предметы", value='Вы можете находить предметы, дающие прирост к характеристикам')
                emb.add_field(name="Бонусы",
                              value='Помочь уничтожению вражеского Нексуса можно прослушивая музыку или, например, сев на бутылку')
                emb.add_field(name="Дневной урон",
                              value='Каждый день ваша команда наносит урон вражескому Нексусу')
                emb.add_field(name="Испытания",
                              value='Выполняйте специальные задания и получайте за них очки!')
                img = nexus_draw()
                mes = await logchannel.send(file=img)
                nexus1.img = mes.attachments[0].url
                emb.set_image(url=nexus1.img)
                mes = await mainchannel2.send(embed=emb)
                await mes.add_reaction('☀️')
                await mes.add_reaction('🌙')


# ----------------------------------------------------------------------------------------------------------------------
# Pictures and music
async def picfinder(text, ch=None):
    if not ch:
        ch = adb.enpics
    async for m in bot.get_channel(ch).history(limit=10000):
        if m.content == text:
            if m.attachments:
                return m.attachments[0].url
    raise ValueError(f"Encoded pic {text} not found")


async def forceplay(name, channel):
    try:
        guild = channel.guild
        try:
            await channel.connect()
        except:
            pass
        voice = discord.utils.get(bot.voice_clients, guild=guild)
        voice.play(discord.FFmpegOpusAudio(source=f'music/{name}'))
        voice.source = discord.PCMVolumeTransformer(voice.source)
        voice.source.volume = 100
    except:
        return


def number_gif(num):
    if int(num) < 10:
        return discord.File(fp=f'pips/{num}.gif')
    num = str(num)
    main_ims = []
    frames = {'0':9, '1':6, '2':7, '3':11, '4':9, '5':7, '6':6, '7':6, '8':5, '9':7}
    for f in range(1, 8):
        main_im = Image.new('RGBA', (45 * len(num), 100), (54, 57, 63, 255))
        for i, im in enumerate(num):
            frame_num = f if f < frames[im] else frames[im]
            im = Image.open(f'pips/numgifs/{im}_{frame_num}.png').convert('RGBA')
            main_im.paste(im, (45 * i, 0, 45 * (i + 1), 100), im)
        main_ims.append(main_im)

    if not os.path.exists('pips/numgifs_'):
        os.mkdir('pips/numgifs_')
    path = f'pips/numgifs_/{num}.gif'
    main_ims[0].save(
        path,
        optimize=False,
        save_all=True,
        append_images=main_ims[1:],
        duration=200,
        loop=0,
        transparency=0
    )
    return discord.File(fp=path)


@bot.command()
async def numgif(ctx, num):
    await ctx.send(file=number_gif(num))


# ----------------------------------------------------------------------------------------------------------------------
# Events
@bot.event
async def on_message(message):
    if message.content.startswith(adb.prefix):
        for i in adb.allcoms:
            if i == 'r':
                if message.content.split(' ')[0] != adb.prefix+i:
                    continue
            if message.content.startswith(adb.prefix+i):
                if i != 'clear' and i != 'newemoji':
                    try:
                        await message.delete()
                    except:
                        pass
                name = expd[message.guild.id][message.author.id].name
                print(f'{name} применил {i}')
                logg(f'command: {name} ({message.guild.id}/{message.author.id}) -> {i}')
                sql_insert = 'INSERT INTO commlog(id, server, name, command, date) VALUES (?,?,?,?,?)'
                SQL.execute(sql_insert, (message.author.id, message.guild.id, name, i, time.strftime("%d.%m.%Y, %X", time.localtime())))
                db.commit()
    await bot.process_commands(message)
    if message.channel.id in adb.oldchannels:
        await message.channel.send(f'Дебил! Это не тот канал! Пиши в {mainchannel.mention}', file=adb.mischat, delete_after=30)
        if len(message.content) > 0 and len(message.content) <= 1900:
            await mainchannel.send(f'`{message.author.name}`{smile(message)} из {message.channel.mention}:\n{message.content}')
        return
    if message.author.id != bot.user.id:
        await AkariCatch(message)
        await AkariCoderEvent(message)
        await AkariCalculatingProcessor(message)
        await AkariMetrics(message)
    await memlog(message)
    if message.channel.id == adb.vkchannel:
        await vkExp(message)
    await AkariExp(message)
    if '&$' in message.content:
        await rolelore(message)
    if message.author.id != bot.user.id:
        await AkariSwitcher(message)
        # await AkariCorrector(message)


@bot.event
async def on_message_edit(_, new):
    if new.content.startswith(adb.prefix):
        for i in adb.allcoms:
            if i == 'r':
                if not new.content.split(' ')[0] != adb.prefix + i:
                    continue
            if new.content.startswith(adb.prefix + i):
                if i != 'clear' and i != 'newemoji':
                    await new.delete()
                name = expd[new.guild.id][new.author.id].name
                print(f'{name} применил {i}')
                logg(f'command_edit: {name} ({new.guild.id}/{new.author.id}) -> {i}')
                sql_insert = 'INSERT INTO commlog(id, server, name, command, date) VALUES (?,?,?,?,?)'
                SQL.execute(sql_insert, (
                new.author.id, new.guild.id, name, i, time.strftime("%d.%m.%Y, %X", time.localtime())))
                db.commit()
    await bot.process_commands(new)

    
@bot.event
async def on_ready():
    global bbag
    global programistishe
    global monopolishe
    global mainchannel
    global logchannel
    bbag = bot.get_guild(adb.bbag)
    programistishe = bot.get_channel(adb.programistishe)
    monopolishe = bot.get_channel(adb.monopolishe)
    mainchannel = bot.get_channel(adb.bbagmain)
    mainchannel2 = bot.get_channel(mainchannel2id) # для отладки нексуса
    logchannel = bot.get_channel(adb.botcage)
    AELoad()
    nexus_starter()
    AESavetask.start()
    daycheck.start()
    dayphrase.start()
    daymeme.start()
    daybottle.start()
    online_counter.start()
    achieve_giver.start()
    bbag_reminder.start()
    voice_disconnect.start()
    nexus_daily.start()
    gr = random.choice(adb.greets)
    await logchannel.send(gr, delete_after=30)
    print(gr)
    all_guilds_save.start()
    logg("start: Bot started, all tasks work and tables loaded!")
    activity = discord.Activity(name=f"Плюётся в людей | {adb.prefix}help", type=0)
    await bot.change_presence(status=discord.Status.online, activity=activity)


@bot.event
async def on_raw_reaction_add(payload):
    if str(payload.emoji) == '<:agroMornyX:833000410976354334>' and payload.user_id != bot.user.id:
        mes = await bot.get_channel(payload.channel_id).fetch_message(payload.message_id)
        await mes.delete()
    elif payload.message_id in quis and payload.user_id != bot.user.id:
        mes = await bot.get_channel(payload.channel_id).fetch_message(payload.message_id)
        qdict = quis[payload.message_id]
        emb = discord.Embed(title='Опрос', description=qdict['desc'])
        for i in qdict['ans']:
            if not i['emo'] == str(payload.emoji):
                try:
                    await mes.remove_reaction(i['emo'], payload.member)
                except:
                    pass
        mes = await bot.get_channel(payload.channel_id).fetch_message(payload.message_id)
        all = 0
        for ii,i in enumerate(qdict['ans']):
            for r in mes.reactions:
                if str(r.emoji) == i['emo']:
                    qdict['ans'][ii]['count'] = r.count - 1
                    all += r.count - 1
        for i in qdict['ans']:
            if all == 0:
                prog = '░' * 20
                perc = f'0.00%'
                add = ''
            else:
                prog = int(round((i['count'] / all) * 20))
                prog = f"{'▓' * prog}{'░' * (20 - prog)}"
                perc = f"{round((i['count'] / all) * 100, 2)}%"
                add = f"({i['count']})" if i['count'] > 0 else ''
            emb.add_field(name=i['name'] + ' ' + add, value=f"{i['emo']} {prog} {perc}", inline=False)
            emb.set_footer(icon_url=qdict['author'].avatar_url, text=f"©{qdict['author'].display_name}")
        await mes.edit(embed=emb)
    if adb.nexus_on:
        if payload.user_id == bot.user.id:
            return
        m = payload.member
        if not m.id in expd[adb.bbag]:
            return
        elif not 0 < expd[adb.bbag][m.id].bbagid < 11:
            return
        react = str(payload.emoji)
        message = await payload.member.guild.get_channel(payload.channel_id).fetch_message(payload.message_id)
        if react == '☀️':
            try:
                await message.remove_reaction('🌙', m)
            except:
                pass
            SQL.execute(f"SELECT * FROM nexus_players WHERE id = {m.id}")
            dbp = SQL.fetchone()
            if dbp and (dbp[1] == nexus1.id or time.time() - dbp[5] > 60):
                return
            for r in nex2roles:
                await m.remove_roles(r)
            for r in nex1roles[:2]:
                await m.add_roles(r)
            if dbp:
                SQL.execute(f"UPDATE nexus_players SET nexus_id = {nexus1.id} WHERE id = {m.id}")
                pid = dbp[0]
                expd[adb.bbag][m.id].nplayer['nexus_id'] = nexus1.id
            else:
                icon = random.choice([i for i in os.listdir('nexus') if i.startswith('p1')])
                sql_insert = f"INSERT INTO nexus_players(nexus_id, id, name, level, icon) VALUES (?,?,?,?,?)"
                SQL.execute(sql_insert, (nexus1.id, m.id, expd[adb.bbag][m.id].name, 1, icon))

                SQL.execute(f"SELECT * FROM nexus_players_total WHERE id = {m.id}")
                dbpt = SQL.fetchone()
                if not dbpt:
                    sql_insert = f"INSERT INTO nexus_players_total(id, name) VALUES (?,?)"
                    SQL.execute(sql_insert, (m.id, expd[adb.bbag][m.id].name))

                SQL.execute(f"SELECT * FROM nexus_players WHERE id = {m.id} AND nexus_id = {nexus1.id}")
                dbp = SQL.fetchone()
                pid = dbp[0]
                expd[adb.bbag][m.id].nplayer = {'player_id': pid, 'nexus_id': nexus1.id, 'level': 1, 'damage': 0,
                                                'day_damage': 0, 'damage_block': 0, 'heal': 0, 'icon': icon}
            nexus2.remove_player(m.id, pid)
            nexus1.add_player(m.id, pid)
            db.commit()

        elif react == '🌙':
            try:
                await message.remove_reaction('☀️', m)
            except:
                pass
            SQL.execute(f"SELECT * FROM nexus_players WHERE id = {m.id}")
            dbp = SQL.fetchone()
            if dbp and (dbp[1] == nexus2.id or time.time() - dbp[5] > 60):
                return
            for r in nex1roles:
                await m.remove_roles(r)
            for r in nex2roles[:2]:
                await m.add_roles(r)
            if dbp:
                SQL.execute(f"UPDATE nexus_players SET nexus_id = {nexus2.id} WHERE id = {m.id}")
                pid = dbp[0]
                expd[adb.bbag][m.id].nplayer['nexus_id'] = nexus2.id
            else:
                icon = random.choice([i for i in os.listdir('nexus') if i.startswith('p1')])
                sql_insert = f"INSERT INTO nexus_players(nexus_id, id, name, level, icon) VALUES (?,?,?,?,?)"
                SQL.execute(sql_insert, (nexus2.id, m.id, expd[adb.bbag][m.id].name, 1, icon))

                SQL.execute(f"SELECT * FROM nexus_players_total WHERE id = {m.id}")
                dbpt = SQL.fetchone()
                if not dbpt:
                    sql_insert = f"INSERT INTO nexus_players_total(id, name) VALUES (?,?)"
                    SQL.execute(sql_insert, (m.id, expd[adb.bbag][m.id].name))

                SQL.execute(f"SELECT * FROM nexus_players WHERE id = {m.id} AND nexus_id = {nexus2.id}")
                dbp = SQL.fetchone()
                pid = dbp[0]
                expd[adb.bbag][m.id].nplayer = {'player_id': pid, 'nexus_id': nexus2.id, 'level': 1, 'damage': 0,
                                                'day_damage': 0, 'damage_block': 0, 'heal': 0, 'icon': icon}
            nexus1.remove_player(m.id, pid)
            nexus2.add_player(m.id, pid)
            db.commit()


@bot.event
async def on_member_join(m):
    try:
        if not expd[m.guild.id][m.id]:
            print(m.guild.id, m.id)
    except:
        expd[m.guild.id][m.id] = Vehicle([m.guild.id, m.id], True)
    if m.guild.id == adb.bbag:
        await mainchannel.send(f'{rolemention(expd[m.guild.id][m.id])}', file=adb.streetracing)


@bot.event
async def on_typing(channel, user, ttime):
    if adb.chance(1, 1000):
        await channel.send(f'{rolemention(expd[channel.guild.id][user.id])}{random.choice(adb.typing)}')
    if channel.guild.id == adb.dmh and not channel.id == adb.memlog and not mlFlags[channel.id]:
        meslogs[channel.id].append(int(time.time()))
        mlFlags[channel.id] = True
        await asyncio.sleep(120)
        mlFlags[channel.id] = False


@bot.event
async def on_member_remove(member):
    if member.guild.id == adb.bbag:
        # await mainchannel.send(embed=discord.Embed(title='НУ ПОКА', description=f'Харон провожает **{member.nick}** в Тартар))'), file=adb.cannon)
        SQL.execute(f'SELECT value FROM config WHERE name = "daykick"')
        d = SQL.fetchone()[0].split('.')
        days = int(time.time() - time.mktime((int(d[2]), int(d[1]), int(d[0]), 0, 0, 0, 0, 0, 0))) // 86400
        await mainchannel.send(f'**{member.display_name}** был УНИЧТОЖЕН жестокой системой. Дней без проишествий:', file=number_gif(days))
        t = time.localtime(time.time())
        SQL.execute(f'UPDATE config SET value = "{t[2]}.{t[1]}.{t[0]}" WHERE name = "daykick"')
        db.commit()


@bot.event
async def on_member_update(before, after):
    if before.display_name != after.display_name:
        print(f'{before.display_name} ({before.guild.id}/{before.id}) сменил имя на {after.display_name}')
        logg(f'changename: {expd[after.guild.id][after.id].name} ({after.id}/{after.guild.id}) {before.display_name} -> {after.display_name}')
        sql_insert = 'INSERT INTO changenicks(id, server, before, after, time) VALUES (?,?,?,?,?)'
        SQL.execute(sql_insert, (after.id, after.guild.id, before.display_name, after.display_name, time.strftime("%d.%m.%Y, %X", time.localtime())))
        db.commit()


# ----------------------------------------------------------------------------------------------------------------------
# Common functions
async def vekdef(ctx):
    god = int(time.strftime('%Y'))
    vekr = adb.to_roman(god)

    daysec = (int(time.strftime('%j')) - 1) * 24 * 3600
    hoursec = int(time.strftime('%H')) * 3600
    minsec = int(time.strftime('%M')) * 60
    secsec = int(time.strftime('%S'))
    sec = daysec + hoursec + minsec + secsec
    await ctx.send(f"С начала {god} года прошло {adb.postfix(sec, ['секунда', 'секунды', 'секунд'])}")
    vek = int(sec * 99.795081967213114754098360655738) if adb.vis(god) is True else int(
        sec * 100.06575342465753424657534246575)

    year = vek // 31536000 if adb.vis(god) is True else vek // 31622400
    year = year + 100 * god - 99
    vek = vek % 31536000 + len([None for a in range(1, year % 100) if adb.vis(a) is True]) * 86400
    if vek >= 31536000 and adb.vis(year) is False:
        vek -= 31536000
        year += 1
    if vek >= 31622400:
        vek -= 31622400
        year += 1

    day = adb.day_to_day(vek // 86400 + 1, year)
    vek %= 86400
    hour = vek // 3600
    vek %= 3600
    minute = vek // 60
    vek = int(vek % 60)

    if vek < 10: vek = '0' + str(vek)
    if minute < 10: minute = '0' + str(minute)
    if hour < 10: hour = '0' + str(hour)

    await ctx.send(
        f"{random.choice(adb.veks)} **{vekr}** век, {year} год, {day}, {random.choice(adb.hours).lower()} {hour}:{minute}:{vek}")


@bot.command()
async def vek(ctx):
    await vekdef(ctx)


@bot.command()
async def help(ctx):
    helps = discord.Embed(title=random.choice(adb.helps), colour=random.choice(adb.raincolors))
    for i in range(len(adb.botcoms)):
        helps.add_field(name=f'{random.choice(adb.garbage)} #{i + 1}',
                        value=f"**{adb.botcoms[i]}**: {adb.comdescs[i]}", inline=False)
    await ctx.send(embed=helps)


@bot.command()
async def dmhelp(ctx):
    helps = discord.Embed(title=random.choice(adb.dmhelps), colour=random.choice(adb.raincolors))
    for i in range(len(adb.dmcoms)):
        helps.add_field(name=f'{random.choice(adb.garbage)} #{i + 1}',
                        value=f"**{adb.dmcoms[i]}**: {adb.dmdescs[i]}", inline=False)
    await ctx.send(embed=helps)


@bot.command()
async def uptime(ctx):
    t = int((time.time() - start_time))
    d, t = t // 86400, t % 86400
    h, t = t // 3600, t % 3600
    m, t = t // 60, t % 60
    send = random.choice(adb.uptimes) + ' '
    if d != 0: send += adb.postfix(d, ['день', 'дня', 'дней']) + ' '
    if h != 0: send += adb.postfix(h, ['час', 'часа', 'часов']) + ' '
    if m != 0: send += adb.postfix(m, ['минуту', 'минуты', 'минут']) + ' '
    send += adb.postfix(t, ['секунду', 'секунды', 'секунд'])
    await ctx.send(send)


@bot.command()
async def stol(ctx):
    await ctx.send(random.choice(adb.stoliki))


@bot.command()
async def chiefr(ctx, *words):
    words = ' '.join(words).lower()
    alphabet = {'а':'100000', 'б':'101000', 'в':'011101', 'г':'111100', 'д':'110100', 'е':'100100', 'ё':'100001', 'ж':'011100', 'з':'100111', 'и':'011000', 'й':'111011', 'к':'100010', 'л':'101010', 'м':'110010', 'н':'110110', 'о':'100110', 'п':'111010', 'р':'101110', 'с':'011010', 'т':'011010', 'у':'100011', 'ф':'111000', 'х':'101100', 'ц':'110000', 'ч':'111110', 'ш':'100101', 'щ':'110011', 'ъ':'101111', 'ы':'011011', 'ь':'011111', 'э':'011001', 'ю':'101101', 'я':'111001'}
    strings = ['','','']
    for i in words:
        if i in alphabet:
            strings[0] += alphabet[i][:2]+'  '
            strings[1] += alphabet[i][2:4]+'  '
            strings[2] += alphabet[i][4:6]+'  '
        elif i == ' ':
            strings[0] += '    '
            strings[1] += '    '
            strings[2] += '    '
    string = '\n'.join(strings)
    fin_string = ''
    for i in string:
        if i == '0':
            fin_string += '👽'
        elif i == '1':
            fin_string += '😂'
        else:
            fin_string += i
    await ctx.send(fin_string)


async def AkariCatch(mes):
    if mes.guild.id != adb.bbag:
        return
    mcl = mes.content.lower()
    for k in adb.catch:
        if ':' in k[1]:
            chance = adb.chance(int(k[1].split(':')[0]), int(k[1].split(':')[1]))
        else:
            chance = adb.chance(int(k[1]))
        if not chance:
            continue
        for i in range(2, len(k)):
            if k[i] in mcl:
                if k[0] == 'vek': await vekdef(mes.channel)
                if k[0] == 'sleep': await mes.channel.send(
                    f'{random.choice(adb.sleep)}, {rolemention(expd[mes.guild.id][mes.author.id])}')
                if k[0] == 'stol': await mes.channel.send(random.choice(adb.stoliki))
                if k[0] == 'beda': await mes.channel.send(f'Беды с башкой, {rolemention(expd[mes.guild.id][mes.author.id])}')
                if k[0] == 'iq': await mes.channel.send(file=adb.iqpic)
                if k[0] == 'p': await mes.channel.send(random.choice(adb.prcatch), file=AkariCoder())
                if k[0] == 'pp': await mes.channel.send(random.choice(adb.prcatch), file=AkariCoder())
                if k[0] == 'lenyka': await mes.channel.send('Мотиватор: https://torshina.me/pizdaboliya/dodelyivat-delo-do-kontsa/')
                if k[0] == 'hello': await mes.channel.send('Я те щас помашу, пидрила 👋')
                break


@bot.command()
async def coder(ctx):
    await ctx.send(random.choice(adb.prcatch), file=AkariCoder())


async def AkariCoderEvent(mes):
    if mes.channel.id != adb.programistishe:
        return
    if not adb.chance(5):
        return
    await mes.channel.send(random.choice(adb.prcatch), file=AkariCoder())


def AkariCoder():
    file = open('pips/AkariCode.txt', encoding='utf-8').read()
    file2 = open('pips/AkariOnlyfuncs.txt', encoding='utf-8').read()
    file3 = open('pips/bbagdict.txt', encoding='utf-8').read()
    main = list(set(re.findall(r'[\w\.\[\]_]+', file)))
    code = list(set(file2.split(' ')))
    words = file3.split('\n')
    sym = 0
    comms = []
    res = ''

    imports = [f'import {adb.ranget(main)}' for _ in range(random.randint(2, 4))]
    if adb.chance(50):
        imports[-1] = f'from {adb.ranget(main)} import {adb.ranget(words)}'
    imports = '\n'.join(imports)
    sym += len(imports)
    comms.append(imports)

    config = '\n'.join([f'{f"{adb.ranget(main)} = "}{adb.ranget(code)}' for _ in range(random.randint(2, 5))])
    sym += len(config)
    comms.append(config)

    for _ in range(random.randint(2, 6)):
        comm = ''
        if adb.chance(67):
            if adb.chance(67):
                if adb.chance(50):
                    comm += f"@bot.event\n"
                else:
                    comm += f"@bot.command()\n"
                comm += f'async def {adb.ranget(words)}(ctx, {adb.ranget(main, random.randint(1, 3))}):\n  '
            else:
                comm += f'async def {adb.ranget(words)}({adb.ranget(main, random.randint(2, 3))}):\n  '
        else:
            comm += f'def {adb.ranget(words)}({adb.ranget(main, random.randint(2, 5))}):\n  '
        comm += '\n  '.join([f'{random.choice(["await ", f"{adb.ranget(main)} = ", f"{adb.ranget(main)} += ", "return ", f"{adb.ranget(code)} "])}{adb.ranget(code)}' for _ in range(random.randint(1, 9))])
        sym += len(comm)
        comms.append(comm)
    while sym > 1800:
        sym -= len(comms[-1])
        del comms[-1]
    text = res + '\n\n'.join(comms)
    if os.path.exists('pips/ac.py'):
        os.remove('pips/ac.py')
    file4 = open('pips/ac.py', 'a', encoding='utf-8')
    file4.write(text)
    file4.close()
    file5 = discord.File(fp='pips/ac.py')
    return file5


async def bottledef(m, g=None, channel=None):
    if not channel:
        channel = mainchannel
    if g:
        guild = bot.get_guild(g)
    else:
        guild = bbag
        g = adb.bbag
    mem = guild.get_member(m)

    bidx = random.randrange(0, len(adb.bottles))
    bottle = adb.bottles[bidx]
    fil = adb.fillers[bidx]

    if g == adb.bbag and not adb.if_host:
        role = bbag.get_role(adb.bottle_role)
        bottlecolor = random.choice(list(adb.colnames.values()))
        bottlecolor = discord.Colour.from_rgb(*bottlecolor)
        await role.edit(name=adb.randomnick(), color=bottlecolor)

    if g == adb.bbag and not adb.if_host:
        emb = discord.Embed(title='Бутылка дня', description=f'На бутылку c {bottle} сегодня садится {rolemention(expd[g][m])}\n:champagne: {fil} {fil} {fil} :champagne:\nЕму присуждается звание {role.mention}')
    else:
        emb = discord.Embed(title='Бутылка дня', description=f'На бутылку c {bottle} сегодня садится {rolemention(expd[g][m])}\n:champagne: {fil} {fil} {fil} :champagne:')

    await expd[g][m].addexp(adb.e_bottle, reason='бутылка', mem=mem)

    expd[g][m].exp['bottles'] += 1
    expd[g][m].exp['lastbottle'] = time.strftime("%d.%m.%Y, %H:%M", time.localtime())

    purl = await picfinder('$$$')
    emb.set_image(url=purl)
    emb.set_footer(icon_url=mem.avatar_url, text=f'Опыт увеличен в {adb.ek_bottle} раза на сутки')

    for mm in expd[g]:
        expd[g][mm].bottle = False
        SQL.execute(f"UPDATE exp SET bottlednow = 0 WHERE id = {mm} AND server = {g}")
        if g == adb.bbag and not adb.if_host:
            try:
                mmem = guild.get_member(mm)
                if role in mmem.roles:
                    await mmem.remove_roles(role)
            except:
                pass
    expd[g][m].bottle = True
    SQL.execute(f"UPDATE exp SET bottlednow = 1 WHERE id = {m} AND server = {g}")
    if g == adb.bbag and not adb.if_host:
        await mem.add_roles(role)
    db.commit()
    await channel.send(embed=emb)
    AESavedef('giving a bottle')


@bot.command()
async def bottle(ctx, mem=None):
    if ctx.author.id != 262288342035595268:
        return
    if mem:
        mem = finduserindex(mem, ctx.guild.id)
        await bottledef(mem.id, ctx.guild.id, ctx.channel)
        return
    if ctx.guild.id == adb.bbag:
        mem = random.choice([i for i in expd[adb.bbag] if 0 < expd[adb.bbag][i].bbagid < 11])
    else:
        mem = random.choice(list(expd[ctx.guild.id]))
    await bottledef(mem, ctx.guild.id, ctx.channel)


@bot.command()
async def bottleregen(ctx):
    if ctx.guild.id == adb.bbag:
        role = bbag.get_role(adb.bottle_role)
        bottlecolor = random.choice(list(adb.colnames.values()))
        bottlecolor = discord.Colour.from_rgb(*bottlecolor)
        await role.edit(name=adb.randomnick(), color=bottlecolor)


@bot.command()
async def randomplay(ctx):
    mem = ctx.author
    if os.path.exists('music') and os.listdir('music') and mem:
        sound = random.choice(os.listdir('music'))
        if mem.voice.channel:
            await forceplay(sound, mem.voice.channel)
        else:
            vv = None
            vvn = -1
            for vc in mem.guild.voice_channels:
                if len(vc.members) > vvn:
                    vvn = len(vc.members)
                    vv = vc
            if vvn > 0:
                await forceplay(sound, vv)


@bot.command()
async def musplay(ctx, sound):
    mem = ctx.author
    if os.path.exists('music') and os.listdir('music') and mem:
        if not '.mp3' in sound:
            sound += '.mp3'
        if sound not in os.listdir('music'):
            await ctx.send('Такого трека нет:(', delete_after=10)
            return
        if mem.voice.channel:
            await forceplay(sound, mem.voice.channel)
        else:
            vv = None
            vvn = -1
            for vc in mem.guild.voice_channels:
                if len(vc.members) > vvn:
                    vvn = len(vc.members)
                    vv = vc
            if vvn > 0:
                await forceplay(sound, vv)


async def new_role(mes, name, color=None):
    if color in adb.colnames:
        c = adb.colnames[color]
        color = discord.Colour.from_rgb(c[0], c[1], c[2])
    else:
        color = discord.Colour.from_rgb(255, 255, 255)
    newrole = await mes.guild.create_role(name=name, color=color, reason=f'Так захотел {mes.author.nick}', mentionable=True)
    return newrole


async def rolelore(mes):
    roles = []
    text = mes.content.split('&$')
    for i, a in enumerate(text[1:]):
        color = None
        men = None
        b = a.split(' ', maxsplit=1)
        if '$' in b[0]:
            d = b[0].split('$')
            name = d[0]
            color = d[1].lower()
            try:
                men = d[2:]
            except:
                pass
        else:
            name = b[0]
        role = await new_role(mes, name, color)
        roles.append(role)
        b[0] = role.mention
        if men:
            for m in men:
                me = finduserindex(m, mes.guild.id)
                me = mes.guild.get_member(me.id)
                await me.add_roles(role, reason=f'Так захотел {mes.author.nick}')
        text[i + 1] = ' '.join(b)
    text = ''.join(text)
    await mes.channel.send(text)
    await mes.delete()
    for r in roles:
        await r.delete(reason=f'Так захотел {mes.author.nick}')


@bot.command()
async def ping(ctx):
    em = discord.Embed(title='**Текущая задержка:**', description=f'{bot.ws.latency * 1000:.0f} ms', color=random.choice(adb.raincolors))
    await ctx.send(embed=em)


@bot.command()
async def felete(ctx, file):
    if not '.' in file:
        file +='.txt'
    os.remove(file)
    await ctx.send(f'Файл {file} удалён!', delete_after=5)


@bot.command()
async def transfer(ctx, ch, count):
    ch = ctx.guild.get_channel(int(ch))
    days = False
    if 'd' in count:
        days = True
        count = count.split('d')[0]
    count = int(count)
    mess = []
    mems = []
    if days:
        if count < 1:
            await ctx.send(f'Введите количество дней')
        trans_time = datetime.datetime.now() - datetime.timedelta(days=count-1)
        async for mes in ch.history(after=trans_time):
            mess.append(mes)
        days_count = count
        count = len(mess)
    else:
        async for mes in ch.history(limit=count):
            mess.append(mes)
        days_count = 1
    mess = mess[::-1]
    for m in mess:
        cont = m.content
        # mentions = re.findall(r'<@.?>', cont)
        # print(mentions)
        # for me in mentions:
        #     me_id = re.sub(r'\D', '', me)
        #     mem = m.guild.get.member(me_id)
        #     re.sub(me, f'{mem.name}{smile(mem=mem)}', cont)
        file = None
        if m.attachments:
            a = m.attachments[0]
            if a.filename.endswith((".png", ".jpg", ".gif")):
                pic = requests.get(a.url)
                pf = open(f'{a.filename}', 'wb')
                pf.write(pic.content)
                pf.close()
                file = discord.File(fp=a.filename)
        if len(cont) > 1900:
            await ctx.send(f'`{m.author.name}`{smile(m)}, `{m.created_at.strftime("%d.%m.%Y, %X")}`')
            await ctx.send(cont, file=file)
        else:
            await ctx.send(f'`{m.author.name}`{smile(m)}, `{m.created_at.strftime("%d.%m.%Y, %X")}`\n{cont}', file=file)
        mems.append(m.author)
        await asyncio.sleep(0.5)
        if file:
            os.remove(file.fp.name)
    if count <= 5:
        return
    mems = set(mems)
    mems = [rolemention(expd[me.guild.id][me.id]) for me in mems]
    mems = '\n'.join(mems)
    desc = f'Перекинул {count} сообщений '
    if days:
        desc += f'(за {adb.postfix(days_count, ["день", "дня", "дней"])}) '
    desc += f'из {ch.mention} ({ch.guild.name})\nАвторы сообщений:\n{mems}'
    embed = discord.Embed(tile='Перенос', description=desc)
    embed.set_footer(icon_url=ctx.author.avatar_url, text=f'Вызвал: {ctx.author.name}')
    await ctx.send(embed=embed)


@bot.command()
async def tts(ctx, *text: str):
    text = ' '.join(text)
    tts = gTTS(text=text, lang="ru", lang_check=True)
    name = ctx.author.name + '.mp3'
    tts.save(name)
    file = discord.File(fp=name)
    await ctx.send(random.choice(adb.ttss), file=file)
    os.remove(name)


def casino_def():
    l = list(adb.cas_reward.keys())
    return random.choice(l), random.choice(l), random.choice(l)


@bot.command()
async def casino(ctx):
    g = ctx.guild.id
    m = ctx.author.id
    emb = discord.Embed(title='Казино 🪓🪓🪓', description='Вращайте барабан!')
    embed = await ctx.send(embed=emb)
    a, b, c = casino_def()
    mes = await ctx.send(f'{a}{b}{c}')
    for i in range(4):
        await asyncio.sleep(1)
        a, b, c = casino_def()
        await mes.edit(content=f'{a}{b}{c}')
    await mes.delete()
    if a == b and a == c:
        emb.add_field(name=f'Джекпот!', value=f'{a}{b}{c}! Ваш выигрыш: **{adb.cas_reward[a]}**')
        await expd[g][m].addexp(adb.cas_reward[a], ctx.channel, 'казино', mem=ctx.author)
        await embed.edit(embed=emb)
    else:
        emb.add_field(name=f'Неудача((', value=f'Повезёт в другой раз!\n{a}{b}{c}')
        await embed.edit(embed=emb)


@bot.command()
async def qui(ctx, *args):
    try:
        args = ' '.join(args).split('|')
        desc = args[0]
        emb = discord.Embed(title='Опрос', description=desc)
        qdict = {'desc': desc, 'author': ctx.author, 'ans': []}
        n = 0
        for i in args[1:]:
            n += 1
            ans, emo = i.split('<', maxsplit=1)
            emo = '<' + emo.split('>')[0] + '>'
            prog = '░' * 20
            perc = f'0.00%'
            emb.add_field(name=f'{n}. {ans}', value=f'{emo} {prog} {perc}', inline=False)
            emb.set_footer(icon_url=ctx.author.avatar_url, text=f'©{ctx.author.display_name}')
            qdict['ans'].append({'name': f'{n}. {ans}', 'emo': emo, 'count': 0})
        mes = await ctx.send(embed=emb)
        for i in qdict['ans']:
            await mes.add_reaction(i['emo'])
        quis[mes.id] = qdict
    except Exception as e:
        print(e)


async def AkariSwitcher(mes):
    sw = adb.switch(mes.content)
    z = zip(mes.content.lower().split(), sw.split())
    bolds = []
    for orig, trlt in z:
        pure_orig = re.sub(r'[\W\d_]', '', orig)
        pure_trlt = re.sub(r'[\W\d_]', '', trlt.lower())
        if len(pure_orig) > 3 and trlt not in bolds and not adb.find_word(pure_orig) and adb.find_word(pure_trlt):
            bolds.append(trlt)
            sw = re.sub(trlt, '**'+trlt+'**', sw)
    if bolds:
        await mes.channel.send('Akari переведёт:\n'+sw[:1900])


async def AkariCorrector(mes):
    ct = mes.content
    bolds = []
    for word in ct.split():
        pure = re.sub(r'[\W\d_]', '', word.lower())
        if len(pure) > 3 and word not in bolds and not adb.find_word(pure):
            kword = adb.correct_word(pure)
            if kword:
                bolds.append(word)
                ct = re.sub(word, '**'+adb.replace_reg(word, kword)+'**', ct)
    if bolds:
        await mes.channel.send('Очепятка, правильно:\n' + ct[:1900])


@bot.command()
async def nicks(ctx, mem=None):
    if not mem:
        mem = ctx.author
    else:
        mem = finduserindex(mem, ctx.guild.id)
        mem = ctx.guild.get_member(mem.id)
    SQL.execute(f'SELECT after, time FROM changenicks WHERE id = {mem.id} AND server = {mem.guild.id}')
    lastnicks = SQL.fetchall()[-10:]
    if not lastnicks:
        await ctx.send('Этот пользователь ещё не менял ники:(', delete_after=10)
        return
    embed = discord.Embed(title=random.choice(adb.changenicks), colour=random.choice(adb.raincolors))
    for i,t in lastnicks:
        embed.add_field(name=t, value=f'{i}{smile(mem=mem)}', inline=False)
    await ctx.send(embed=embed)


@bot.command(aliases=['cov'])
async def corona(ctx):
    browser = await launch()
    page = await browser.newPage()
    await page.goto('https://xn--80aesfpebagmfblc0a.xn--p1ai/information/')
    soup = BeautifulSoup(await page.content(), 'html.parser')
    await browser.close()

    date = str(soup.find("small").string).split('По состоянию на')[1] # FIXME: дата должна быть не вакцинации, а статы
    values = soup.find_all("h3", {"class": "cv-stats-virus__item-value"})
    values = [i.string.replace('\n', '').replace('\xa0', '') for i in values]
    values = [re.sub('\D', '', i) for i in values]
    values = values[:1]+values[1:6:2]+values[2:7:2]
    for j,t in enumerate(values):
        text = str(int(t))[::-1]
        text = ' '.join([text[i:i+3] for i in range(0, len(text), 3)])[::-1]
        values[j] = text

    heads = ['В больничку', 'Обратно', 'Заболело', 'Сдохло', 'Здоровых', 'Заболело', 'Сдохло']
    heads_icons = ['hospital', 'medcar', 'biohazard', 'skull', 'plus', 'biohazard', 'skull']

    icons = {i.split('.png')[0]: Image.open('pips/plgs/' + i).convert('RGBA') for i in os.listdir('pips/plgs')}
    font = ImageFont.truetype('pips/arial.ttf', size=55)
    fontmd = ImageFont.truetype('pips/blood.ttf', size=44)
    fontsm = ImageFont.truetype('pips/arial.ttf', size=36)

    im = Image.open(f'pips/plg.png').convert('RGBA')
    photo = random.choice(os.listdir("pips/plgphones"))
    photo = Image.open(f'pips/plgphones/{photo}').convert('RGBA')
    photo = photo.resize((445, 445))
    im.paste(photo, (137, 14), photo)
    im.paste(icons['corner1'], (137, 401), icons['corner1'])
    im.paste(icons['corner2'], (519, 14), icons['corner2'])
    im.paste(icons['corner2'], (137, 401), icons['corner2'])
    im.paste(icons['corner1'], (519, 14), icons['corner1'])

    barvalues = [int(re.sub('\D', '', i)) for i in values[3:0:-1]]
    barsum = sum(barvalues)
    covvals_pxs = [int(1700 * i / barsum) for i in barvalues]
    obj = im.load()
    px_start = 611, 368
    barsize = 1700, 86
    if sum(covvals_pxs) != barsize[0]:
        covvals_pxs[0] += barsize[0] - sum(covvals_pxs)
    xoffset = 0
    for k in range(3):
        color = [adb.colnames['серый'], adb.colnames['тёмно-красный'], adb.colnames['голубой']][k]
        color = tuple(list(color) + [255])
        for i in range(covvals_pxs[k]):
            for j in range(barsize[1]):
                ii = px_start[0] + xoffset + i
                jj = px_start[1] + j
                obj[ii, jj] = color
        xoffset += covvals_pxs[k]

    im.paste(icons['barmask'], px_start, icons['barmask'])
    draw = ImageDraw.Draw(im)
    draw.text((621, 25), 'Россия', font=font, fill=('#FFFFFE'))
    draw.text((978, 37), 'За сутки  |  Всего', font=fontmd, fill=('#FFFFFE'))
    # draw.text((1840, 37), date, font=fontmd, fill=('#FFFFFE')) # FIXME: см. выше
    draw.text((670, 130), heads[0], font=fontsm, fill=('#FFFFFE'))
    draw.text((970, 130), heads[1], font=fontsm, fill=('#FFFFFE'))
    draw.text((670, 230), heads[2], font=fontsm, fill=('#FFFFFE'))
    draw.text((970, 230), heads[3], font=fontsm, fill=('#FFFFFE'))
    draw.text((1280, 130), heads[4], font=fontsm, fill=('#FFFFFE'))
    draw.text((1280, 230), heads[5], font=fontsm, fill=('#FFFFFE'))
    draw.text((1580, 230), heads[6], font=fontsm, fill=('#FFFFFE'))

    draw.text((670, 180), values[0], font=fontsm, fill=('#FFFFFE'))
    draw.text((970, 180), values[1], font=fontsm, fill=('#FFFFFE'))
    draw.text((670, 280), values[2], font=fontsm, fill=('#FFFFFE'))
    draw.text((970, 280), values[3], font=fontsm, fill=('#FFFFFE'))
    draw.text((1280, 180), values[4], font=fontsm, fill=('#FFFFFE'))
    draw.text((1280, 280), values[5], font=fontsm, fill=('#FFFFFE'))
    draw.text((1580, 280), values[6], font=fontsm, fill=('#FFFFFE'))

    im.paste(icons[heads_icons[0]], (885, 130), icons[heads_icons[0]])
    im.paste(icons[heads_icons[1]], (1118, 130), icons[heads_icons[1]])
    im.paste(icons[heads_icons[2]], (838, 230), icons[heads_icons[2]])
    im.paste(icons[heads_icons[3]], (1100, 230), icons[heads_icons[3]])
    im.paste(icons[heads_icons[4]], (1450, 135), icons[heads_icons[4]])
    im.paste(icons[heads_icons[5]], (1448, 230), icons[heads_icons[5]])
    im.paste(icons[heads_icons[6]], (1710, 230), icons[heads_icons[6]])

    output = io.BytesIO()
    im.save(output, 'png')
    image_pix = io.BytesIO(output.getvalue())
    await ctx.send(file=discord.File(fp=image_pix, filename='corona.png'))


@bot.command()
async def whereami(ctx):
    if adb.if_host:
        await ctx.send('Я у Димы на компе!')
    else:
        await ctx.send('Я у Лёши на хосте))')


@bot.command(aliases=['rt'])
async def rantime(ctx, *args):
    args = ' '.join(args)
    t = random.choice([30, 7200, 21600, 86400, 172800])
    d, t = t // 86400, t % 86400
    h, t = t // 3600, t % 3600
    m, t = t // 60, t % 60
    send = args + ' через '
    if d != 0: send += adb.postfix(d, ['день', 'дня', 'дней']) + ' '
    if h != 0: send += adb.postfix(h, ['час', 'часа', 'часов']) + ' '
    if m != 0: send += adb.postfix(m, ['минуту', 'минуты', 'минут']) + ' '
    if t != 0: send += adb.postfix(t, ['секунду', 'секунды', 'секунд'])
    await ctx.send(send)


async def AkariCalculatingProcessor(message):
    t = message.content
    u = message.author
    if not t or t.isdigit():  # or (not t[0].isdigit() and not t[0] == '(' and not t[0] == '#'):
        return
    for i in re.findall(r'[A-Za-z]+\.[A-Za-z]+', t):
        if all(j not in i for j in ['math.', 'random.', 'adb.']):
            if 'os.' in i or 'system.' in i:
                await message.channel.send('ТЫ АХУЕЛ?')
            return
    for i in ['exit', 'quit']:
        if i in t:
            await message.channel.send('ТЫ АХУЕЛ?')
            return
    try:
        ACPvars['result'] = 0
        if "#" in t and not t.endswith("#"):
            t, tt = t.split("#")[:2]
            vars = {'result': 0}
            for i in tt.split(","):
                m, n = i.split("=")
                m = m.strip()
                n = n.strip()
                exec('result='+n, globals(), vars)
                ACPvars[m] = vars['result'] if not adb.is_float(vars['result']) or int(vars['result']) != float(vars['result']) else int(vars['result'])
        t = re.sub(r'==', '=', t)
        t = re.sub(r'=', '==', t)
        t = re.sub(r'\^', '**', t)
        exec('result='+t, globals(), ACPvars)
        res = ACPvars["result"] if not adb.is_float(ACPvars["result"]) or int(ACPvars["result"]) != float(ACPvars["result"]) else int(ACPvars["result"])
        await message.channel.send(f'{rolemention(expd[u.guild.id][u.id])} {res}')
    except Exception as e:
        if all(i not in str(e) for i in ['invalid syntax', 'is not defined', 'in identifier', 'unexpected EOF while parsing']):
            await message.channel.send(f'{get_emoji("AgroMornyX")} {e}')


async def AkariMetrics(message):
    t = message.clean_content
    u = message.author
    if not t:
        return
    num = re.findall(r'[\d]+', t)
    if not num:
        return
    tl = t.split(" ")
    num = num[0]
    a = []
    for s in tl:
        reg = re.findall(r'[^\W\d_]+', s)
        if reg:
            a.append(reg[0])
    res = predictor.predict(tl)
    for i,s in enumerate(res):
        if s.pos == 'NOUN' and 'Case=Gen' in s.tag:
            await message.channel.send(f'{num} {tl[i]} тебе в жопу, {rolemention(expd[u.guild.id][u.id])}')
            return


@bot.command()
async def nlp(ctx, *args):
    a = []
    for s in args:
        reg = re.findall(r'[^\W\d_]+', s)
        if reg:
            a.append(reg[0])
    res = predictor.predict(a)
    res = [adb.pretty_nlp_tag(a[i], s) for i, s in enumerate(res)]
    for i in adb.longsplit_lines(res):
        await ctx.channel.send('```py\n'+i+'```')


@bot.command()
async def quit(ctx):
    if ctx.author.id != 262288342035595268:
        return
    os.abort()


# ----------------------------------------------------------------------------------------------------------------------
# Blackout
async def whiteoutdef(ctx):
    if not os.path.exists('whiteout.txt'):
        return
    g = ctx.guild.id
    whiteoutlist = ast.literal_eval(open('whiteout.txt', 'r', encoding='utf-8').read())
    embed = discord.Embed(title=random.choice(adb.paintlist), colour=0xfffffe)
    rest = discord.Embed(title=random.choice(adb.restlist), colour=0xfffffe)
    embedi = 1
    resti = 1
    await ctx.send(random.choice(adb.whiteouts), delete_after=10)
    for u, nick in whiteoutlist.items():
        if u in expd[g]:
            mem = ctx.guild.get_member(u)
            try:
                oldnick = rolementionfixed(expd[g][u])
                await mem.edit(nick=nick)
                await asyncio.sleep(0.5)
                embed.add_field(name=f'{random.choice(adb.people)} #{embedi}',
                                value=f"{oldnick} {random.choice(adb.calling)} **{nick}**",
                                inline=False)
                embedi += 1
            except:
                rest.add_field(name=f'{random.choice(adb.garpeople)} #{resti}',
                               value=f"{rolementionfixed(expd[g][u])} {random.choice(adb.calling)} **{nick}**",
                               inline=False)
                resti += 1
    await ctx.send(embed=embed)
    await ctx.send(embed=rest)
    os.remove('whiteout.txt')


@bot.command()
async def whiteout(ctx):
    await whiteoutdef(ctx)


@bot.command()
async def blackout(ctx, timedef=None):
    if os.path.exists('whiteout.txt'):
        await ctx.send('Дождитесь вайтаута.', delete_after=10)
        return
    g = ctx.guild.id
    whiteoutlist = {}
    embed = discord.Embed(title=random.choice(adb.paintlist), colour=0x000000)
    rest = discord.Embed(title=random.choice(adb.restlist), colour=0x000000)
    embedi = 1
    resti = 1
    await ctx.send(random.choice(adb.blackouts), delete_after=10)
    for mem in ctx.guild.members:
        u = mem.id
        if expd[g][u].name:
            whiteoutlist[u] = mem.display_name
            try:
                oldnick = rolementionfixed(expd[g][u])
                await mem.edit(nick=expd[g][u].name)
                await asyncio.sleep(0.5)
                embed.add_field(name=f'{random.choice(adb.people)} #{embedi}',
                                value=f"{oldnick} {random.choice(adb.calling)} **{expd[g][u].name}**",
                                inline=False)
                embedi += 1
            except:
                rest.add_field(name=f'{random.choice(adb.garpeople)} #{resti}',
                               value=f"{rolementionfixed(expd[g][u])} {random.choice(adb.calling)} **{expd[g][u].name}**",
                               inline=False)
                resti += 1
    await ctx.send(embed=embed)
    await ctx.send(embed=rest)
    file = open('whiteout.txt', 'w', encoding='utf-8')
    file.write(str(whiteoutlist))
    file.close()
    if timedef:
        timedef = str(timedef)
        if 'h' in timedef:
            timedef = int(timedef.split('h')[0]) * 3600
        elif 'm' in timedef:
            timedef = int(timedef.split('m')[0]) * 60
        timedef = int(timedef)
        await asyncio.sleep(timedef)
        await whiteoutdef(ctx)


@bot.command()
async def colorout(ctx, timedef=None):
    if os.path.exists('whiteout.txt'):
        await ctx.send('Дождитесь вайтаута.', delete_after=10)
        return
    g = ctx.guild.id
    whiteoutlist = {}
    embed = discord.Embed(title=random.choice(adb.paintlist), colour=0x000000)
    rest = discord.Embed(title=random.choice(adb.restlist), colour=0x000000)
    embedi = 1
    resti = 1
    await ctx.send(random.choice(adb.blackouts), delete_after=10)
    rans = adb.randomnicks(nicks=len(ctx.guild.members))
    for mem in ctx.guild.members:
        u = mem.id
        whiteoutlist[u] = mem.display_name
        ran = random.choice(rans)
        rans.remove(ran)
        try:
            oldnick = rolementionfixed(expd[g][u])
            await mem.edit(nick=ran)
            await asyncio.sleep(0.5)
            embed.add_field(name=f'{random.choice(adb.people)} #{embedi}',
                            value=f"{oldnick} {random.choice(adb.calling)} **{ran}**",
                            inline=False)
            embedi += 1
        except:
            rest.add_field(name=f'{random.choice(adb.garpeople)} #{resti}',
                           value=f"{rolementionfixed(expd[g][u])} {random.choice(adb.calling)} **{ran}**",
                           inline=False)
            resti += 1
    await ctx.send(embed=embed)
    await ctx.send(embed=rest)
    file = open('whiteout.txt', 'w', encoding='utf-8')
    file.write(str(whiteoutlist))
    file.close()
    if timedef:
        timedef = str(timedef)
        if 'h' in timedef:
            timedef = int(timedef.split('h')[0]) * 3600
        elif 'm' in timedef:
            timedef = int(timedef.split('m')[0]) * 60
        timedef = int(timedef)
        await asyncio.sleep(timedef)
        await whiteoutdef(ctx)


# ----------------------------------------------------------------------------------------------------------------------
# Experience and statistics
async def AkariExp(mes):
    atts = len(mes.attachments)
    eadd = 0
    g = mes.guild.id
    m = mes.author.id
    flags = {'exp': True, 'allmessages': True}
    expd[g][m].exp['allmessages'] += 1
    expd[g][m].exp['pictures'] += atts
    if len(mes.content) > 0:
        expd[g][m].exp['messages'] += 1
        if len(mes.content) > adb.e_message * 3:
            eadd += len(mes.content)
        else:
            eadd += adb.e_message
    eadd += atts * adb.e_picture

    if atts:
        flags['pictures'] = True
    if len(mes.content) > 0:
        mat = len(adb.matcounter(mes.content))
        expd[g][m].exp['symbols'] += len(mes.content)
        flags['symbols'] = True
        if mat:
            expd[g][m].exp['mat'] += mat
            flags['mat'] = True
    await expd[g][m].addexp(eadd, mes.channel, mem=mes.author)

    if m != bot.user.id and len(mes.content) > 0:
        if mes.raw_mentions or mes.raw_role_mentions:
            roles = {expd[g][mmm].role["id"]: expd[g][mmm].id for mmm in expd[g] if 0 < expd[g][mmm].bbagid < 11}
            ids = [expd[g][mmm].id for mmm in expd[g]]
        for u in mes.raw_mentions:
            if u == m or u not in ids:
                continue
            await expd[g][u].addexp(adb.e_men, mes.channel, 'mention')
            expd[g][u].exp['mentions'] += 1
            flags['mentions'] = True
        for r in mes.raw_role_mentions:
            if not r in roles:
                continue
            u = roles[r]
            if u == m or u not in ids:
                continue
            await expd[g][u].addexp(adb.e_men, mes.channel, 'role_mention')
            expd[g][u].exp['mentions'] += 1
            flags['mentions'] = True
        smiles = Counter(re.findall(r'<:\S{,10}:\S{,20}>', mes.content))
        if smiles:
            for u in expd[g]:
                if u == m:
                    if g == adb.bbag:
                        for s in expd[g][u].emos:
                            if s in smiles:
                                ecount = smiles[s]
                                if ecount > 0:
                                    expd[g][u].exp['selfsmiles'] += ecount
                                    flags['selfsmiles'] = True
                    continue
                for s in expd[g][u].emos:
                    if s in smiles:
                        ecount = smiles[s]
                        if ecount > 0:
                            await expd[g][u].addexp(adb.e_emo * ecount, mes.channel, 'smile')
                            expd[g][u].exp['smiles'] += ecount
                            flags['smiles'] = True
    if g == adb.bbag:
        await sum_achieve(m, flags)


async def process_chaos(message):
    ctx = await bot.get_context(message)
    await bot.invoke(ctx)


async def vkExp(mes):
    text = mes.content
    if not 'α' in text:
        return
    cont = ''
    att = 0
    stick = 0
    eps = 0
    if 'ε' in text:
        eps = int(text.split('ε')[1])
        text = text.split('ε')[0]
    if 'δ' in text:
        stick = int(text.split('δ')[1])
        text = text.split('δ')[0]
    if 'γ' in text:
        att = int(text.split('γ')[1].rstrip().rstrip(','))
        text = text.split('γ')[0]
    if 'β' in text:
        cont = text.split('β')[1].rstrip().rstrip(',')
        text = text.split('β')[0]
    vkid = int(text.split('α')[1].rstrip().rstrip(','))
    eadd = 0
    g = adb.bbag
    m = 0
    if eps == 0:
        eps = len(cont)
    for mem in expd[g]:
        if expd[g][mem].vkid == vkid:
            m = mem
    if not m:
        print('Кто-то проник в беседу ВК...')
        return

    flags = {'exp': True, 'vkmes': True, 'allmessages': True}
    expd[g][m].exp['allmessages'] += 1
    expd[g][m].exp['vkmes'] += 1
    if att:
        expd[g][m].exp['pictures'] += 1
        flags['pictures'] = True
        eadd += adb.e_picture
    if stick:
        expd[g][m].exp['stickers'] += 1
        eadd += adb.e_vkstick
    if len(cont) > 0:
        expd[g][m].exp['messages'] += 1
        expd[g][m].exp['symbols'] += eps
        flags['symbols'] = True
        mat = len(adb.matcounter(cont))
        if mat:
            expd[g][m].exp['mat'] += mat
            flags['mat'] = True
        if eps > adb.e_message * 3:
            eadd += eps
        else:
            eadd += adb.e_message

    await expd[g][m].addexp(eadd, reason='вк')
    await sum_achieve(m, flags)
    if cont.startswith(adb.vk_prefix):
        if cont.startswith(adb.vk_prefix+'ds'):
            cont = cont.split(adb.vk_prefix+'ds', maxsplit=1)[1]
            if len(cont) <= 1900:
                if att:
                    file = discord.File(fp=f'vk/{att}.jpg')
                    await mainchannel.send(f'`{expd[g][m].name}`{random.choice(expd[g][m].emos)} из {emosdict[51]["vk"]}:\n{cont}', file=file)
                    os.remove(f'vk/{att}.jpg')
                else:
                    await mainchannel.send(f'`{expd[g][m].name}`{random.choice(expd[g][m].emos)} из {emosdict[51]["vk"]}:\n{cont}')
                save_vk_comm(expd[g][m], 'vk_ds')
            else:
                vka.messages.send(random_id=random.randint(0, 1000000), message='Сообщение не больше 1900 символов. Кар', chat_id=3)
        if cont.startswith(adb.vk_prefix + 'tts'):
            clean_cont = cont.split(adb.vk_prefix + 'tts', maxsplit=1)[1]
            name = expd[g][m].name + '.ogg'
            tts = gTTS(text=clean_cont, lang="ru", lang_check=True)
            tts.save(name)
            a = vka.method("docs.getMessagesUploadServer", {"type": "audio_message", "peer_id": 156809784})
            b = requests.post(a['upload_url'], files={'file': open("voice.mp3", 'rb')}).json()
            c = vka.method("docs.save", {"file": b["file"]})[0]
            d = f"doc{c['owner_id']}_{c['id']}"
            vka.messages.send(random_id=random.randint(0, 1000000), message='Ваше сообщение', chat_id=3, attachment=d)
            save_vk_comm(expd[g][m], 'vk_tts')
            os.remove(name)


def save_vk_comm(e, comm):
    print(f'{e.name} применил {comm}')
    logg(f'command_vk: {e.name} ({e.server}/{e.id}) -> {comm}')
    sql_insert = 'INSERT INTO commlog(id, server, name, command, date) VALUES (?,?,?,?,?)'
    SQL.execute(sql_insert, (e.id, e.server, e.name, comm, time.strftime("%d.%m.%Y, %X", time.localtime())))
    db.commit()


@bot.command(enabled=False)
async def aerecount(ctx, password=''):
    if password != 'ghbdtn':
        await ctx.send('Пароль неверный!', delete_after=5)
        return
    oldp = [250, 300, 120, 90, 120] #old_parameters: adb.e_message, adb.e_picture, adb.e_emo, adb.e_men, adb.e_vkstick
    for g in expd:
        for m in expd[g]:
            v = expd[g][m].exp
            oldeadd = v['messages'] * oldp[0] + v['pictures'] * oldp[1] + v['smiles'] * oldp[2] + v['mentions'] * oldp[3] + expd[g][m].exp['stickers'] * oldp[4]
            diff = expd[g][m].exp['exp'] - oldeadd
            eadd = v['messages'] * adb.e_message + v['pictures'] * adb.e_picture + v['smiles'] * adb.e_emo + v['mentions'] * adb.e_men + expd[g][m].exp['stickers'] * adb.e_vkstick
            expd[g][m].exp['exp'] = eadd + diff
    await ctx.send(f'Готово!', delete_after=5)


@bot.command()
async def aesave(ctx):
    AESavedef('user request')
    await ctx.send('Готово!', delete_after=5)


@bot.command()
async def removeexp(ctx, i, count):
    if ctx.author.id != 262288342035595268:
        return
    mem = finduserindex(i, ctx.guild.id)
    mem.exp["exp"] -= int(count)
    await ctx.send(f'{random.choice(adb.exp_removes)} Снято {count} опыта у {mem.name}{random.choice(mem.emos)}', delete_after=10)


# ----------------------------------------------------------------------------------------------------------------------
# Achievements
def sum_stats(g=adb.bbag):
    res = defaultdict(int)
    for m in expd[g]:
        for key in expd[g][m].exp:
            if type(expd[g][m].exp[key]) == int:
                res[key] += expd[g][m].exp[key]
    return res


async def sum_achieve(mem, flags):
    stats = sum_stats()
    for i in adb.sum_achieves:
        s, lv, n, t, d = i['stat'], i["levelvalue"], i["name"], i["title"], i["desc"]
        if s in flags:
            cur_levels = [a['level'] for a in achs if a['name'] == n]
            lvl = int(stats[s] // lv)
            if lvl == 0: continue
            if not cur_levels or lvl > max(cur_levels):
                nextvalue = lv * lvl
                ach = {'name': n, 'level': lvl, 'value': nextvalue, 'date': time.strftime("%d.%m.%Y, %H:%M", time.localtime()), 'owner': mem}
                achs.append(ach)
                save_achieve(ach)
                title = f"{t} {adb.to_roman(lvl)}"
                desc = d.format(nextvalue)
                purl = await picfinder(n)
                emb = discord.Embed(title='Achievement get!', description=f'**{title}**\n{desc}\nНаграду получил: {rolemention(expd[adb.bbag][mem])}')
                emb.set_image(url=purl)
                await mainchannel.send(embed=emb)
                await expd[adb.bbag][mem].addexp(adb.e_sumach+lvl*adb.e_sumach_lvladd, reason=f'{n} {adb.to_roman(lvl)}')
                AESavedef('giving sum_achieve')


def save_achieve(ach):
    sql_insert = 'INSERT INTO achs(id, server, name, level, value, date) VALUES (?,?,?,?,?,?)'
    SQL.execute(sql_insert, (ach['owner'], adb.bbag, ach['name'], ach['level'], ach['value'], ach['date']))
    db.commit()


# ----------------------------------------------------------------------------------------------------------------------
# Server/Channel statistics and saving history into file
async def channelexpdef(channel, cve, flist):
    mems = channel.guild.members
    g = channel.guild.id
    async for mes in channel.history(limit=10000000):
        atts = len(mes.attachments)
        eadd = 0
        v = mes.author.id
        if v not in cve:
            continue
        cve[v].exp['allmessages'] += 1
        cve[v].exp['pictures'] += atts
        if len(mes.content) > 0:
            cve[v].exp['messages'] += 1
            if len(mes.content) > adb.e_message * 3:
                eadd += len(mes.content)
            else:
                eadd += adb.e_message
        eadd += atts * adb.e_picture

        if g == adb.bbag:
            if len(mes.content) > 0:
                mat = len(adb.matcounter(mes.content))
                cve[v].exp['symbols'] += len(mes.content)
                if mat:
                    cve[v].exp['mat'] += mat
        cve[v].exp['exp'] += eadd

        if v != bot.user.id and len(mes.content) > 0:
            for u in mems:
                if u == mes.author:
                    if g == adb.bbag:
                        for s in flist[u.id][1]:
                            ecount = mes.content.count(s)
                            cve[u.id].exp['selfsmiles'] += ecount
                    continue
                if rolementionchat(cve[u.id]):
                    mencount = mes.content.count(flist[u.id][0])
                    cve[v].exp["exp"] += adb.e_men * mencount
                    cve[u.id].exp['mentions'] += mencount
                if f'{u.id}>' in mes.content:
                    mencount = mes.content.count(f'{u.id}>')
                    cve[v].exp["exp"] += adb.e_men * mencount
                    cve[u.id].exp['mentions'] += mencount
                for s in flist[u.id][1]:
                    ecount = mes.content.count(s)
                    cve[v].exp["exp"] += adb.e_emo * ecount
                    cve[u.id].exp['smiles'] += ecount
    return cve


@bot.command()
async def channelexp(ctx, all=''):
    stime = time.time()
    mems = ctx.guild.members
    cve = {mem.id: Vehicle([mem.id, mem.guild.id], True) for mem in mems}
    flist = {u.id: [rolementionchat(cve[u.id]), expd[u.guild.id][u.id].emos] for u in mems}
    if all == 'all':
        embed = discord.Embed(title=f'Опыт во всех каналах {ctx.guild.name}', colour=random.choice(adb.raincolors))
        for ch in ctx.guild.text_channels:
            cve = await channelexpdef(ch, cve, flist)
    else:
        cve = await channelexpdef(ctx.channel, cve, flist)
        embed = discord.Embed(title=f'Опыт в {ctx.channel.name}', colour=random.choice(adb.raincolors))
    newvehicles = aesort([cve[v] for v in cve if cve[v].exp['exp'] != 0])
    for i in newvehicles:
        text = f'{rolemention(expd[i.server][i.id])} {adb.levelget(i.exp["exp"])} уровня'
        if i.exp["allmessages"] > 0:
            text += f', сообщений: {i.exp["allmessages"]}'
        if i.exp["messages"] > 0:
            text += f', с текстом: {i.exp["messages"]}'
        if i.exp["pictures"] > 0:
            text += f', картиночек: {i.exp["pictures"]}'
        if i.exp["mentions"] > 0:
            text += f', упоминаний: {i.exp["mentions"]}'
        if i.exp["smiles"] > 0:
            text += f', смайликов с ним: {i.exp["smiles"]}'
        if i.exp["mat"] > 0:
            text += f', лексики: {i.exp["mat"]}'
        if i.exp["symbols"] > 0:
            text += f', символов: {i.exp["symbols"]}'
        if i.exp["selfsmiles"] > 0:
            text += f', смайликов с собой: {i.exp["selfsmiles"]}'
        embed.add_field(name=f'Опыт: {i.exp["exp"]}', value=text, inline=False)
    await ctx.send(embed=embed)
    await ctx.send(f'Выполнено за {time.time() - stime}', delete_after=300)
    stamp = time.time() - stime
    print(f'channelexp {all} completed by {stamp}')
    allmes = f'server {ctx.guild.id}' if all == 'all' else f'channel {ctx.channel.id}'
    logg(f'channelexp: {allmes} completed by {stamp}')


async def channelsavedef(channel, pics='', name=None):
    stime = time.time()
    cve = {}
    if not name:
        name = channel.name
    if not os.path.exists(name):
        os.mkdir(name)
    file = open(f'{name}/{name}.txt', 'w', encoding='utf-8')
    co, sum = 0, 0
    data = []
    dic = []
    dicdate = defaultdict(str)
    atts = []
    async for i in channel.history(limit=10000000):
        co += 1
        v = i.author.id
        if v not in cve:
            cve[v] = defaultdict(int)
            cve[v]['id'] = v
            cve[v]['name'] = i.author.name
            cve[v]['onserver'] = True if i.author in channel.guild.members else False
        cve[v]['allmessages'] += 1
        cve[v]['pictures'] += len(i.attachments)
        if len(i.content) > 0:
            cve[v]['messages'] += 1
            cve[v]['symbols'] += len(i.content)
            for a in i.attachments:
                atts.append(a)
                data.append(f"∭")
            data.append(f"∬{co}, {len(i.content)} sym, {len(i.content.split(' '))} words\n")
            data.append(f"∫{i.author.id}, {i.created_at.strftime('%d.%m.%Y, %X')}\n")
            data.append(f'{i.content}\n')
            sum += len(i.content)
            mes = re.sub(r'[^\s\w-]', '', re.sub('\n_', ' ', i.content))
            split = mes.split(' ')
            dic += split
            for s in split:
                dicdate[s] = i.created_at.strftime('%d.%m.%Y, %X')
            cve[v]['words'] += len(split)
        else:
            for a in i.attachments:
                atts.append(a)
                data.append("∭")
            if len(i.attachments) > 0:
                data.append(f"∬{co}\n")
                data.append(f"∫{i.author.id}, {i.created_at.strftime('%d.%m.%Y, %X')}\n")
    data = data[::-1]
    atts = atts[::-1]
    exfiles = os.listdir(name)
    if pics != 'False':
        for i, a in enumerate(atts):
            if f'{i+1}-{a.filename}' not in exfiles:
                await a.save(f'{name}/{i+1}-{a.filename}')
    att_index = 0
    for d in data:
        if d == '∭':
            wr = f"∭{name}/{att_index+1}-{atts[att_index].filename}\n"
            att_index += 1
            file.write(wr)
        else:
            file.write(d)
    words = len(dic)
    total = f"⨌{co} messages, {sum} symbols, {words} words, {round(words / (co - len(atts)), 2)} avg, {len(atts)} pics, {time.time() - stime} seconds to parse\n\n"
    file.write(total)
    cve_main = adb.esort_ext(cve, 'allmessages', 'onserver', True)
    cve_rest = adb.esort_ext(cve, 'allmessages', 'onserver', False)
    for m in cve_main:
        if m['messages'] == 0:
            file.write(
                f"∰ID {m['id']} {m['name']}: Всего сообщений: {m['allmessages']}, текстовых: {m['messages']}, картиночек: {m['pictures']}\n")
        else:
            file.write(
                f"∰ID {m['id']} {m['name']}: Всего сообщений: {m['allmessages']}, текстовых: {m['messages']}, картиночек: {m['pictures']}\n"
                f"  Символов: {m['symbols']}, слов: {m['words']}, в среднем {round(m['words'] / m['messages'], 2)} слов/сообщение\n")
    if cve_rest:
        file.write('\nНе на сервере:\n')
    for m in cve_rest:
        if m['messages'] == 0:
            file.write(
                f"⨏ID {m['id']} {m['name']}: Всего сообщений: {m['allmessages']}, текстовых: {m['messages']}, картиночек: {m['pictures']}\n")
        else:
            file.write(
                f"⨏ID {m['id']} {m['name']}: Всего сообщений: {m['allmessages']}, текстовых: {m['messages']}, картиночек: {m['pictures']}\n"
                f"  Символов: {m['symbols']}, слов: {m['words']}, в среднем {round(m['words'] / m['messages'], 2)} слов/сообщение\n")
    file = open(f'{name}/dict.txt', 'w', encoding='utf-8')
    dic = adb.ownname(Counter(dic)).most_common()
    for x in dic:
        file.write(f"{x[0]} — {adb.postfix(x[1], ('раз', 'раза', 'раз'))}, {str(round(x[1] / words * 100, 3)) + '%'} — {dicdate[x[0]]}\n")
    file.write(f"Всего: {adb.postfix(len(dic), ('слово', 'слова', 'слов'))}")
    stamp = time.time() - stime
    await channel.send(f"Готово! ❖❖❖ {co} messages, {sum} symbols, {words} words, {round(words / (co - len(atts)), 2)} avg, {len(atts)} pics ❖❖❖ Выполнено за {stamp}")
    print(f"{channel.name} channel saved! ❖❖❖ {co} messages, {sum} symbols, {words} words, {round(words / (co - len(atts)), 2)} avg, {len(atts)} pics ❖❖❖ Выполнено за {stamp}")
    logg(f"channelsave: {channel.name} ({channel.guild.id}/{channel.id}) saved with {co} mes, {sum} sym, {words} words, {round(words / (co - len(atts)), 2)} avg, {len(atts)} pics. Done for {stamp}")


@bot.command()
async def channelsave(ctx, pics='', name=None):
    await channelsavedef(ctx.channel, pics, name)


async def guildsavedef(guild, channel=None, pics='', dirr=None):
    print(f'\033[33m\033[4mStarting backup {guild.name}...\033[0m')
    logg(f'guildsave: Backup of {guild.name} ({guild.id}) started!')
    stime = time.time()
    cve = {}
    if not dirr:
        dirr = guild.name
    if not os.path.exists(dirr):
        os.mkdir(dirr)
    count, sum, all_atts = 0, 0, 0
    dic = []
    dicdate = defaultdict(str)
    for c in guild.text_channels:
        name = c.name
        print(f'\033[32m{name}... \033[0m')
        logg(f'guildsave: Backup of {name} ({guild.id}/{c.id}) started!')
        if not os.path.exists(f'{dirr}/{name}'):
            os.mkdir(f'{dirr}/{name}')
        file = open(f'{dirr}/{name}/{name}.txt', 'w', encoding='utf-8')
        data = []
        atts = []
        ch_dic = []
        ch_dicdate = defaultdict(str)
        co, sym = 0, 0
        ntime = time.time()
        async for i in c.history(limit=10000000):
            co += 1
            count += 1
            v = i.author.id
            if v not in cve:
                cve[v] = defaultdict(int)
                cve[v]['id'] = v
                cve[v]['name'] = i.author.name
                cve[v]['onserver'] = True if i.author in guild.members else False
            cve[v]['allmessages'] += 1
            cve[v]['pictures'] += len(i.attachments)
            if len(i.content) > 0:
                cve[v]['messages'] += 1
                cve[v]['symbols'] += len(i.content)
                for a in i.attachments:
                    atts.append(a)
                    data.append(f"∭")
                    all_atts += 1
                data.append(f"∬{co}, {len(i.content)} sym, {len(i.content.split(' '))} words\n")
                data.append(f"∫{i.author.id}, {i.created_at.strftime('%d.%m.%Y, %X')}\n")
                data.append(f'{i.content}\n')
                sum += len(i.content)
                sym += len(i.content)
                mes = re.sub(r'[^\s\w-]', '', re.sub('\n_', ' ', i.content))
                split = mes.split(' ')
                dic += split
                ch_dic += split
                for s in split:
                    dicdate[s] = i.created_at.strftime('%d.%m.%Y, %X')
                    ch_dicdate[s] = i.created_at.strftime('%d.%m.%Y, %X')
                cve[v]['words'] += len(split)
            else:
                for a in i.attachments:
                    atts.append(a)
                    data.append("∭")
                    all_atts += 1
                if len(i.attachments) > 0:
                    data.append(f"∬{co}\n")
                    data.append(f"∫{i.author.id}, {i.created_at.strftime('%d.%m.%Y, %X')}\n")
        data = data[::-1]
        atts = atts[::-1]
        exfiles = os.listdir(f'{dirr}/{name}')
        if pics != 'False':
            for i, a in enumerate(atts):
                if f'{i+1}-{a.filename}' not in exfiles:
                    await a.save(f'{dirr}/{name}/{i+1}-{a.filename}')
        att_index = 0
        for d in data:
            if d == '∭':
                wr = f"∭{dirr}/{name}/{att_index+1}-{atts[att_index].filename}\n"
                att_index += 1
                file.write(wr)
            else:
                file.write(d)
        ch_words = len(ch_dic)
        nstamp = time.time() - ntime
        avgsyms = str(round(ch_words / (co - len(atts)), 2)) if co - len(atts) == 0 else 'N/A'
        file.write(f"⨌{co} messages, {sym} symbols, {ch_words} words, {avgsyms} avg, {len(atts)} pics, {nstamp} seconds to parse\n")
        file = open(f'{dirr}/{name}/dict.txt', 'w', encoding='utf-8')
        ch_dic = adb.ownname(Counter(ch_dic)).most_common()
        for x in ch_dic:
            file.write(f"{x[0]} — {adb.postfix(x[1], ('раз', 'раза', 'раз'))}, {str(round(x[1] / ch_words * 100, 3)) + '%'} — {ch_dicdate[x[0]]}\n")
        file.write(f"Всего: {adb.postfix(len(ch_dic), ('слово', 'слова', 'слов'))}")
        print(f'\033[32m{name} done!\033[0m')
        logg(f'guildsave: Backup of {name} ({guild.id}/{c.id}) done with {co} mes, {sym} sym, {ch_words} words, {avgsyms} avg, {len(atts)} pics. Done for {nstamp}')
    words = len(dic)
    stamp = time.time() - stime
    total = f"⨌{count} messages, {sum} symbols, {words} words, {round(words / (count - all_atts), 2)} avg, {all_atts} pics, {stamp} seconds to parse\n\n"
    file = open(f'{dirr}/total.txt', 'w', encoding='utf-8')
    file.write(total)
    cve_main = adb.esort_ext(cve, 'allmessages', 'onserver', True)
    cve_rest = adb.esort_ext(cve, 'allmessages', 'onserver', False)
    for m in cve_main:
        if m['messages'] == 0:
            file.write(
                f"∰ID {m['id']} {m['name']}: Всего сообщений: {m['allmessages']}, текстовых: {m['messages']}, картиночек: {m['pictures']}\n")
        else:
            file.write(
                f"∰ID {m['id']} {m['name']}: Всего сообщений: {m['allmessages']}, текстовых: {m['messages']}, картиночек: {m['pictures']}\n"
                f"  Символов: {m['symbols']}, слов: {m['words']}, в среднем {round(m['words'] / m['messages'], 2)} слов/сообщение\n")
    if cve_rest:
        file.write('\nНе на сервере:\n')
    for m in cve_rest:
        if m['messages'] == 0:
            file.write(
                f"⨏ID {m['id']} {m['name']}: Всего сообщений: {m['allmessages']}, текстовых: {m['messages']}, картиночек: {m['pictures']}\n")
        else:
            file.write(
                f"⨏ID {m['id']} {m['name']}: Всего сообщений: {m['allmessages']}, текстовых: {m['messages']}, картиночек: {m['pictures']}\n"
                f"  Символов: {m['symbols']}, слов: {m['words']}, в среднем {round(m['words'] / m['messages'], 2)} слов/сообщение\n")
    file = open(f'{dirr}/dict.txt', 'w', encoding='utf-8')
    dic = adb.ownname(Counter(dic)).most_common()
    for x in dic:
        file.write(f"{x[0]} — {adb.postfix(x[1], ('раз', 'раза', 'раз'))}, {str(round(x[1] / words * 100, 3)) + '%'} — {dicdate[x[0]]}\n")
    file.write(f"Всего: {adb.postfix(len(dic), ('слово', 'слова', 'слов'))}")
    if channel:
        await channel.send(f"Готово! ❖❖❖ {count} messages, {sum} symbols, {words} words, {round(words / (count - all_atts), 2)} avg, {all_atts} pics ❖❖❖ Выполнено за {stamp}")
    print(f"{guild.name} saved! ❖❖❖ {count} messages, {sum} symbols, {words} words, {round(words / (count - all_atts), 2)} avg, {all_atts} pics ❖❖❖ Выполнено за {stamp}")
    logg(f'guildsave: Backup of {guild.name} ({guild.id}) done with {count} mes, {sum} sym, {words} words, {round(words / (count - all_atts), 2)} avg, {all_atts} pics. Done for {stamp}')


@bot.command()
async def guildsave(ctx, pics='', dirr=None):
    await guildsavedef(ctx.guild, ctx.channel, pics, dirr)


@bot.command()
async def chencounter(ctx):
    stime = time.time()
    co, sum, atts = 0, 0, 0
    dic = []
    async for i in ctx.channel.history(limit=10000000):
        if len(i.content) > 0:
            sum += len(i.content)
            co += 1
            mes = re.sub(r'[^\s\w-]', '', re.sub('\n_', ' ', i.content))
            dic += mes.split(' ')
        atts += len(i.attachments)
    words = len(dic)
    total = f"❖❖❖\nСообщений: {co}\nВсего символов: {sum}\nВсего слов: {words}\nСреднее: {round(words / co, 2)}\nВсего фоточек: {atts}"
    await ctx.send(f"{total}\n❖❖❖\nВыполнено за {time.time() - stime}")


# ----------------------------------------------------------------------------------------------------------------------
# Vehicle functions
def aesort(l):
    a = [v for v in l]
    for i in range(len(a) - 1):
        for j in range(len(a) - i - 1):
            if a[j].exp["exp"] < a[j + 1].exp["exp"]:
                a[j], a[j + 1] = a[j + 1], a[j]
    return a


def finduserindex(men, gid):
    for g in expd[gid]:
        s = expd[gid][g]
        if str(men).lower() in [f'<@!{s.id}>', f'<@{s.id}>', f'<@&{s.role["id"]}>', str(s.bbagid), s.name.lower(), str(s.id)]:
            return s
    try:
        for g in expd[gid]:
            s = expd[gid][g]
            if men.id == s.id:
                return s
        return None
    except:
        return None


def rolemention(e, opt=None):
    if e.server == adb.bbag:
        try:
            if 0 < e.bbagid < 11:
                return f'{bot.get_guild(e.server).get_role(e.role["id"]).mention}{random.choice(e.emos)}'
        except:
            return bot.get_guild(e.server).get_member(e.id).mention
    if opt:
        return f'**{opt}**'
    return bot.get_guild(e.server).get_member(e.id).mention


def rolementionfixed(e, opt=None):
    if e.server == adb.bbag:
        try:
            if 0 < e.bbagid < 11:
                return f'{bot.get_guild(e.server).get_role(e.role["id"]).mention}{random.choice(e.emos)}'
        except:
            return bot.get_guild(e.server).get_member(e.id).display_name
    if opt:
        return f'**{opt}**'
    return bot.get_guild(e.server).get_member(e.id).display_name


def rolementionchat(e):
    try:
        if e.bbagid <= 10:
            return f'<@&{e.role["id"]}>'
    except:
        return None


@bot.command()
async def exp(ctx, mem=None):
    if not mem:
        newvehicles = aesort([expd[ctx.guild.id][e] for e in expd[ctx.guild.id]])
        embed = discord.Embed(title=f'Опыт {ctx.guild.name}', colour=random.choice(adb.raincolors))
        memids = [x.id for x in ctx.guild.members]
        e = sum_stats(ctx.guild.id)
        text = f'ВСЕ<:Akari:824752874231431178>'
        text += f'   сообщений: {e["allmessages"]}'
        text += f', текстовых: {e["messages"]}'
        text += f', картиночек: {e["pictures"]}'
        text += f', упоминаний: {e["mentions"]}'
        text += f', смайликов с ним: {e["smiles"]}'
        text += f', лексики: {e["mat"]}'
        text += f', часов онлайн: {e["online"] // 60}'
        text += f', символов: {e["symbols"]}'
        text += f', смайликов с собой: {e["selfsmiles"]}'
        embed.add_field(name=f'Опыт: {e["exp"]}', value=text, inline=False)
        for i in newvehicles:
            if i.id in memids and (i.bbagid <= 10 or i.server != adb.bbag):
                e = i.exp
                lvl = adb.levelget(e["exp"], all=True)
                text = f'{rolemention(i)} {lvl[0]} уровня'
                if e['allmessages'] > 0:
                    text += f', сообщений: {e["allmessages"]}'
                if e['messages'] > 0:
                    text += f', текстовых: {e["messages"]}'
                if e["pictures"] > 0:
                    text += f', картиночек: {e["pictures"]}'
                if e["mentions"] > 0:
                    text += f', упоминаний: {e["mentions"]}'
                if e["smiles"] > 0:
                    text += f', смайликов с ним: {e["smiles"]}'
                if e["mat"] > 0:
                    text += f', лексики: {e["mat"]}'
                if e["online"] > 0:
                    online = f'{e["online"]//60}ч {e["online"]%60}мин'
                    text += f', онлайн: {online}'
                if e["symbols"] > 0:
                    text += f', символов: {e["symbols"]}'
                if e["selfsmiles"] > 0:
                    text += f', смайликов с собой: {e["selfsmiles"]}'
                prog = int(round((lvl[1] / lvl[2]) * 20))
                prog = f"{'▓' * prog}{'░' * (20 - prog)}"
                perc = f'{round((lvl[1] / lvl[2]) * 100, 2)}%'
                embed.add_field(name=f'Опыт: {e["exp"]}, {prog} {perc}', value=text, inline=False)
        await ctx.send(embed=embed)
    else:
        mem = finduserindex(mem, ctx.guild.id)
        e = mem.exp
        lvl = adb.levelget(e["exp"], all=True)
        embed = discord.Embed(title=f'{mem.name} {emosdict[mem.bbagid][random.choice(list(emosdict[mem.bbagid]))]} {lvl[0]} уровня',
                              colour=mem.role["color"])
        prog = int(round((lvl[1] / lvl[2]) * 20))
        prog = f"{'▓' * prog}{'░' * (20 - prog)}"
        perc = f'{round((lvl[1] / lvl[2]) * 100, 2)}%'
        embed.add_field(name='Прогресс', value=f'{prog} {perc}', inline=False)
        embed.add_field(name='Всего опыта', value=e["exp"], inline=True)
        if e["allmessages"] > 0:
            embed.add_field(name='Сообщений', value=e["allmessages"], inline=True)
        if e["messages"] > 0:
            embed.add_field(name='Текстовых', value=e["messages"], inline=True)
        if e["pictures"] > 0:
            embed.add_field(name='Картиночек', value=e["pictures"], inline=True)
        if e["mentions"] > 0:
            embed.add_field(name='Упоминаний', value=e["mentions"], inline=True)
        if e["smiles"] > 0:
            embed.add_field(name='Смайликов с ним', value=e["smiles"], inline=True)
        if e["mat"] > 0:
            embed.add_field(name='Лексики', value=e["mat"], inline=True)
        if e["online"] > 0:
            embed.add_field(name='Онлайн', value=f'{e["online"] // 60}ч {e["online"] % 60}мин', inline=True)
        if e["symbols"] > 0:
            embed.add_field(name='Символов', value=e["symbols"], inline=True)
        if e["selfsmiles"] > 0:
            embed.add_field(name='Смайликов с собой', value=e["selfsmiles"], inline=True)
        await ctx.send(embed=embed)
        return


# ----------------------------------------------------------------------------------------------------------------------
# TGD functions
@bot.command()
async def nikki(ctx):
    async for i in ctx.channel.history(limit=1000):
        if '▲' in i.content:
            yw = i.content.split('*Неделя* __***')[1].split('*')[0]
            ano = yw[:2]
            semana = yw[3:5]
            rd = i.content.split('РД')[0][-8:-5]
            ra = i.content.split('РА')[0][-9:-5]
            rm = i.content.split('РМ')[0][-9:-5]
            rest = i.content.split('***')[-1]
            break
    try:
        semana = int(semana) + 1
        if semana < 10:
            semana = "0" + str(semana)
        mes = '▲▼▲▼▲▼▲▼▲▼▲▼▲▼▲▼▲▼▲▼▲▼▲▼▲▼▲▼▲▼▲▼▲▼▲▼▲▼▲▼\n'
        mes += f'\*Неделя\* \_\_\*\*\*{ano}w{semana}: \*\*\*\_\_\n'
        mes += f'\*{int(rd) + 7}\* \*\*\*РД\*\*\* \*{int(ra) + 7}\* \*\*\*РА\*\*\* \*{int(rm) + 7}\* \*\*\*РМ\*\*\*'
        mes += rest
        await ctx.send(mes, delete_after=15)
    except:
        await ctx.send(file=adb.errorpic, delete_after=10)


@bot.command()
async def lognull(ctx):
    global meslogs
    global mlFlags
    lst = []
    for k, v in meslogs.items():
        if not v:
            continue
        k = bot.get_channel(k)
        fv = v[0]
        for i, e in enumerate(v):
            if i == len(v)-1 or v[i+1] - e > 300:
                lst.append((k.mention, fv, e))
                if i != len(v)-1:
                    fv = v[i+1]

    m = adb.listsplit(lst)
    for vs in m:
        emb = discord.Embed(title='Печатаем...', colour=random.choice(adb.raincolors))
        for men, fv, lv in vs:
            val = time.strftime("%d.%m.%Y, %H:%M:%S", time.localtime(fv)) if fv == lv else time.strftime("%d.%m.%Y, %H:%M:%S", time.localtime(fv))+' — '+time.strftime("%H:%M:%S", time.localtime(lv))
            emb.add_field(name=val, value=men, inline=False)
        await ctx.send(embed=emb)
    meslogs = defaultdict(list)
    mlFlags = defaultdict(bool)


async def memlog(mes):
    if (mes.channel.id in adb.mlinput) and len(mes.content) > 105:
        cout = bot.get_channel(adb.memlog)
        c = mes.content
        if '<' in c and '>' in c:
            title = f"<{c.split('<')[1].split('>')[0]}> "
        else: title = f"{c[:1]} "
        c = c.replace(title, '', 1).replace('\n', ' ')
        title += f'{random.choice(adb.letter)} {mes.channel.name}'
        emb = discord.Embed(title=title, colour=random.choice(adb.raincolors))
        d = c[:100][::-1].split(' ', maxsplit=1)[1][::-1]
        emb.add_field(name='Запись', value=d+'...', inline=False)
        emb.add_field(name='Символов', value=str(len(mes.content)), inline=True)
        emb.add_field(name='Время', value=time.strftime("%d.%m.%Y, %X", time.localtime()))
        await cout.send(embed=emb)


# ----------------------------------------------------------------------------------------------------------------------
# Emoji functions
def smile(mes=None, mem=None):
    if mem:
        obj = expd[mem.guild.id][mem.id]
    elif mes:
        obj = expd[mes.guild.id][mes.author.id]
    else:
        return
    if obj.bbagid <= 10:
        return emosdict[obj.bbagid][random.choice(list(emosdict[obj.bbagid]))]
    else:
        return ''


@bot.command()
async def newemoji(ctx, e, three=0, clas=''):
    sql_insert = 'INSERT INTO emos(emoji, eid, bbagid, server, class) VALUES (?,?,?,?,?)'
    one = e.split(':')[1]
    two = e.split(':')[2].split('>')[0]
    print(one, two)
    SQL.execute(sql_insert, (one, two, three, ctx.guild.id, clas))
    db.commit()


@bot.command()
async def emoji(ctx, e):
    u = finduserindex(e, ctx.guild.id)
    if u is not None:
        return await ctx.send(''.join(u.emos))
    return await ctx.send(get_emoji(e))


@bot.command()
async def all_emoji(ctx):
    await ctx.send('\n'.join([str(s) + '  \\' + str(s) for s in ctx.guild.emojis]))


# @bot.command()
# async def all_emojis_db(ctx):
#     sql_insert = 'INSERT INTO emos(emoji, eid, server) VALUES (?,?,?)'
#     for e in ctx.guild.emojis:
#         one = str(e).split(':')[1]
#         two = str(e).split(':')[2].split('>')[0]
#         print(one, two)
#         SQL.execute(sql_insert, (one, two, ctx.guild.id))
#         db.commit()


def get_emoji(e):
    for d in emosdict:
        for a in emosdict[d]:
            if a.lower() == e.lower():
                return emosdict[d][a]

# ----------------------------------------------------------------------------------------------------------------------
# VK commands
@bot.command()
async def vksend(ctx, *text: str, keyboard=''):
    g = ctx.guild.id
    m = ctx.author.id
    mes = expd[g][m].name
    if expd[g][m].vkemo:
        mes += expd[g][m].vkemo
    mes += ':\n'
    mes += ' '.join(text)
    att = ''
    if ctx.message.attachments:
        a = ctx.message.attachments[0]
        if a.filename.endswith((".png", ".jpg")):
            a.save(a.filename)
            b = vka.method('photos.getMessages.UploadServer', {'type': "doc", "peer_id": 156809784})
            c = requests.post(b['upload_url'], files={'photo': open(a.filename, 'rb')}).json()
            d = vka.method('photos.saveMessagesPhoto', {'photo': c['photo'], 'server': c['server'], 'hash': c['hash']})[0]
            att = f'photo{d["owner_id"]}_{d["id"]}'
            os.remove(a.filename)
        if a.filename.endswith((".docx", ".txt", ".gif")):
            a.save(a.filename)
            b = vka.method('docs.getMessagesUploadServer')
            c = requests.post(b['upload_url'], files={'file': open(a.filename, 'r')}).json()
            d = vka.method('docs.save', {'file': c['file'], 'title': a.filename})[0]
            att = f'doc{d["owner_id"]}_{d["id"]}'
            os.remove(a.filename)
        if a.filename.endswith((".mp3", ".wav", ".ogg")):
            a.save(a.filename)
            b = vka.method('audio.getUploadServer')
            c = requests.post(b['upload_url'], files={'file': open(a.filename, 'rb')}).json()
            d = vka.method('audio.save', {'audio': c['audio'], 'server': c['server'], 'hash': c['hash'], 'artist': 'BBAG', 'title': a.filename})
            att = f'photo{d["owner_id"]}_{d["id"]}'
            os.remove(a.filename)
    return vka.messages.send(user_id=156809784, message=mes, random_id=random.randint(0, 1000000), keyboard=keyboard, attachment=att)


@bot.command()
async def vk(ctx, *text: str, chat_id=3, keyboard=''):
    g = ctx.guild.id
    m = ctx.author.id
    mes = expd[g][m].name
    if expd[g][m].vkemo:
        mes += expd[g][m].vkemo
    att = ''
    if ctx.message.attachments:
        a = ctx.message.attachments[0]
        if a.filename.endswith((".png", ".jpg")):
            a.save(a.filename)
            b = vka.method('photos.getMessages.UploadServer', {'type': "doc", "peer_id": 156809784})
            c = requests.post(b['upload_url'], files={'photo': open(a.filename, 'rb')}).json()
            d = vka.method('photos.saveMessagesPhoto', {'photo': c['photo'], 'server': c['server'], 'hash': c['hash']})[0]
            att = f'photo{d["owner_id"]}_{d["id"]}'
            mes += ' прислал мемчик'
            os.remove(a.filename)
        if a.filename.endswith((".docx", ".txt", ".gif")):
            a.save(a.filename)
            b = vka.method('docs.getMessagesUploadServer')
            c = requests.post(b['upload_url'], files={'file': open(a.filename, 'r')}).json()
            d = vka.method('docs.save', {'file': c['file'], 'title': a.filename})[0]
            att = f'doc{d["owner_id"]}_{d["id"]}'
            os.remove(a.filename)
        if a.filename.endswith((".mp3", ".wav")):
            a.save(a.filename)
            b = vka.method('audio.getUploadServer')
            c = requests.post(b['upload_url'], files={'file': open(a.filename, 'rb')}).json()
            d = vka.method('audio.save',
                          {'audio': c['audio'], 'server': c['server'], 'hash': c['hash'], 'artist': 'BBAG',
                           'title': a.filename})
            att = f'photo{d["owner_id"]}_{d["id"]}'
            os.remove(a.filename)
    mes += ':\n'
    mes += ' '.join(text)
    if '@everyone' in mes:
        mes = mes.replace('@everyone', '@all')
    return vka.messages.send(random_id=random.randint(0, 1000000), message=mes, chat_id=chat_id, keyboard=keyboard, attachment=att)

# ----------------------------------------------------------------------------------------------------------------------
# Cogs

@bot.command()
async def load(ctx, extensions):
    bot.load_extension(f'cogs.{extensions}')
    await ctx.send("loaded")


@bot.command()
async def unload(ctx, extensions):
    bot.unload_extension(f'cogs.{extensions}')
    await ctx.send("unloaded")


@bot.command()
async def reload(ctx, extensions):
    bot.unload_extension(f'cogs.{extensions}')
    bot.load_extension(f'cogs.{extensions}')
    await ctx.send("reloaded")


for i in adb.cogs:
    bot.load_extension(i)
bot.load_extension('jishaku')

token = open('token.txt').readlines()[0]
bot.run(token)

if os.path.exists('pips'):
    rusdict = open('pips/engwords.txt', 'r', encoding='utf-8').read().split('\n')
    engdict = open('pips/ruswords.txt', 'r', encoding='utf-8').read().split('\n')


def ti(func):
    def wr(*args, **kwargs):
        t = time.perf_counter()
        a = func(*args, **kwargs)
        print(time.perf_counter()-t)
        return a
    return wr


def postfix(v, ps, rv=True):
    if v % 10 in (0, 5, 6, 7, 8, 9) or v % 100 in (11, 12, 13, 14):
        p = ps[2]
    elif v % 10 == 1:
        p = ps[0]
    else:
        p = ps[1]
    if rv: return f'{v} {p}'
    return p


def list_from_str(s: str):
    return s.split(']')[0].replace('[', '').replace('\'', '').replace('\"', '').split(', ')


def chance(a, b=100):
    return random.randint(1, b) <= a


def chancelist(v, c):
    s = sum(c)
    r = random.randint(1, s)
    for i in range(len(v)):
        if r > c[i]:
            r -= c[i]
        else:
            return v[i]


def sevranchoice(li, i: int):
    l = list(li)
    a = []
    while i >= len(l):
        a += l
        i -= len(l)
    a += random.sample(li, i)
    random.shuffle(a)
    return a


def randomnick(type=0, c=None):
    if not c:
        c = [35, 35, 25, 5]
    if type == 0:
        type = chancelist([1, 2, 3, 4], c)

    a = random.choice(adjs)
    if chance(len(nouns), len(nouns + nounsf)):
        a = corradj(a)
        n = random.choice(nouns)
    else:
        a = corradj(a, 'f')
        n = random.choice(nounsf)
    p = random.choice(prefs)
    e = random.choice(ends)

    if type == 1:
        rn = f'{p}{n.lower()} {e}'
    elif type == 2:
        rn = f'{a} {p}{n.lower()}'
    elif type == 3:
        rn = f'{a} {n} {e}'
    else:
        rn = f'{a} {p}{n.lower()} {e}'
    return rn


def randomnicks(type=0, c=None, nicks=2):
    if not c:
        c = [35, 35, 25, 5]
    if type == 0:
        type = [chancelist([1, 2, 3, 4], c) for _ in range(nicks)]
    else:
        type = [type for _ in range(nicks)]

    a = sevranchoice(adjs, nicks)
    p = sevranchoice(prefs, nicks)
    e = sevranchoice(ends, nicks)
    nm = round((len(nouns) / len(nouns + nounsf)) * nicks)
    nf = nicks - nm
    n = sevranchoice(nouns, nm) + sevranchoice(nounsf, nf)
    for i in range(nm):
        a[i] = corradj(a[i])
    for i in range(nm, nicks):
        a[i] = corradj(a[i], 'f')

    rn = []
    for i in range(nicks):
        if type[i] == 1:
            rn.append(f'{p[i]}{n[i].lower()} {e[i]}')
        elif type[i] == 2:
            rn.append(f'{a[i]} {p[i]}{n[i].lower()}')
        elif type[i] == 3:
            rn.append(f'{a[i]} {n[i]} {e[i]}')
        else:
            rn.append(f'{a[i]} {p[i]}{n[i].lower()} {e[i]}')
    random.shuffle(rn)
    return rn


def corradj(a, sex='m'):
    if '/' in a:
        a = a.split('/')
        if sex == 'm' and a[1] != '':
            return a[0] + a[1]
        elif sex == 'f' and len(a) > 2:
            return a[0] + a[2]
        a = a[0]
    if sex == 'm':
        return a + 'ый'
    if sex == 'f':
        return a + 'ая'


def to_roman(number):
    out = ''
    book = ((1000, 'M'), (900, 'CM'), (500, 'D'), (400, 'CD'), (100, 'C'), (90, 'XC'), (50, 'L'), (40, 'XL'),
            (10, 'X'), (9, 'IX'), (5, 'V'), (4, 'IV'), (1, 'I'))
    while number > 0:
        exit = False
        for i in book:
            if exit == True:
                break
            if number >= i[0]:
                out += i[1]
                number -= i[0]
                exit = True
                break
    return out


def vis(god):
    return (god % 4 == 0 and god % 100 != 0) or god % 400 == 0


def day_to_day(day, year=1):
    a = [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31]
    if vis(year):
        a[1] = 29
    names = ['Января', 'Февраля', 'Марта', 'Апреля', 'Мая', 'Июня', 'Июля', 'Августа', 'Сентября', 'Октября', 'Ноября',
             'Декабря']
    for i in range(12):
        if day > a[i]:
            day -= a[i]
        else:
            return f'{day} {names[i]}'


def levelmode(x, mode=0):
    if mode == 0:
        return 2700 * x ** 1.5527
    elif mode == 1:
        return 15 * x ** 2.5
    elif mode == 2:
        return 6005 * x ** 1.4


def levelget(exp, mode=0, all=None):
    x = 1
    lvlexp = levelmode(1, mode)
    while True:
        if exp > lvlexp:
            exp -= lvlexp
            x += 1
            lvlexp = levelmode(x, mode) - levelmode(x - 1, mode)
        elif all:
            return [x, int(exp), int(lvlexp)]
        else:
            return x


def uniquesum(l):
    new = []
    dinds = []
    index = -1
    for i in range(len(l)):
        if l[i] not in dinds:
            index += 1
            new.append(l[i])
            dinds.append(l[i])
            for j in range(i + 1, len(l)):
                if l[i] == l[j]:
                    new[index] += l[j]
    return new


def ownname(d):    #принимает collections.Counter
    del d['']      #код предотвращает понижение регистра имён собственных в словаре
    for a in d:    #рассчитан на английский, русский и итальянский языки
        if (ord(a[0]) in range(65,91) or ord(a[0]) in range(1040, 1072)) and a.lower() in d:
            d[a.lower()] += d[a]
            d[a] = 0
    d += Counter()
    return d


def mode(l):
    un = list(set(l))
    co = [l.count(x) for x in un]
    print(un, '\n', co)
    return un[co.index(max(co))]


def listsplit(f, cc=10):
    r = []
    while len(f) > 0:
        if len(f) < cc:
            r.append(f)
            f = []
        else:
            r.append(f[:cc])
            f = f[cc:]
    return r


def sort(l):
    a = [v for v in l]
    for i in range(len(a) - 1):
        for j in range(len(a) - i - 1):
            if a[j] < a[j + 1]:
                a[j], a[j + 1] = a[j + 1], a[j]
    return a


def esort(l, param):
    a = [v for v in l if v[param] != 0]
    for i in range(len(a) - 1):
        for j in range(len(a) - i - 1):
            if a[j][param] < a[j + 1][param]:
                a[j], a[j + 1] = a[j + 1], a[j]
    return a


def esort_ext(l, param, secc, svalue):
    a = [l[v] for v in l if l[v][param] != 0 and l[v][secc] == svalue]
    for i in range(len(a) - 1):
        for j in range(len(a) - i - 1):
            if a[j][param] < a[j + 1][param]:
                a[j], a[j + 1] = a[j + 1], a[j]
    return a


def esortatte(l, attr, rev=False):
    a = [v for v in l if getattr(v, attr) != 0]
    for i in range(len(a) - 1):
        for j in range(len(a) - i - 1):
            if getattr(a[j], attr) > getattr(a[j+1], attr):
                a[j], a[j + 1] = a[j + 1], a[j]
    if rev:
        return a[::-1]
    return a


def longsplit(mes, n=1800):
    return [mes[i:i+n] for i in range(0, len(mes), n)]


def longsplit_lines(lst, n=1800, sep='\n'):
    res = []
    i = 0
    s = ''
    while i < len(lst):
        while i < len(lst) and len(s)+len(lst[i])+1 < n:
            if s:
                s += sep
            s += lst[i]
            i += 1
        res.append(s)
        s = ''
    return res


def ranget(l, c=1):
    return ', '.join([random.choice(l) for _ in range(c)])


def matcounter(text):
    return re.findall(r'ху[уюйияеё]|еб[аиоукнлсты]|ёб[аиоукнлсты]|д.лб[аоыьеёи]|[даыьъо][её]б|еб[её][тцмш]|еб[её]н[ьяеин]|сц?[уы][кч4]|бл[яэ]|г.ндон|г.вн|моча|жоп|п[еёи]зд|cum|конч|с[сц]ц?[уаы]|манд|минет|бзд.|др[ие]с[тн]|сра[ткл]|хер|пид.р|fuck|cunt|cock|др[ао][тч]|перд|св[ао]л[ао]|елда|муд[аиое]|з[ао]луп|п.т[ao]ску|трах.|фак|п.скуд|балбес|.н.ме', text.lower())


def matcounter2(text):
    return re.findall(r'[хxh][уyu][уyюйиuiяеeё]|[еe][б6b][аa@uio0иоуyкkнhnlлсcтыbь]|ё[б6b][аa@uio0иоуyкkнhnlлсcтыbь]|д.л[б6b][аa@o0оыbьееёиui]|[дdаa@ыьъo0о][еeё][б6b]|[еe][б6b][ееё][тцмш]|[еe][б6b][ееё]н[ьbяееиuiн]|[сc]ц?[уyыb][кч4]|[б6b]л[яэ]|г.ндон|г.вн|моч[аa@]|жоп|п[ееёиui]зд|cum|конч|[сc][сcц]ц?[уyаa@ыb]|м[аa@]нд|м[иui]н[еe]т|[б6b]зд.|др[иuiее][сc][тн]|[сc][иui]р[ыьbаa@][ткл]|[сc]р[аa@][ткл]|[хxh][еe]р|п[иui]д.р|fu[сc]k|[сc]unt|[сc]ock|др[аa@o0о][тч]|п[еe]рд|св[аa@o0о]л[аa@o0о]|[еe]лд[аa@]|муд[аa@иuio0оeе]|з[аa@o0о]луп|п.т[аa@o0о]ску|тр[аa@]х.|ф[аa@]к|п.скуд', text.lower())


def switch_lang(text):
    return ''.join([eng[rus.index(i)] if i in rus else engb[rusb.index(i)] if i in rusb else i for i in text]) if sum([text.count(i) for i in rus+rusb]) >= sum([text.count(i) for i in eng+engb]) else ''.join([rus[eng.index(i)] if i in eng else rusb[engb.index(i)] if i in engb else i for i in text])


def switch(text):
    return ''.join([eng[rus.index(i)] if i in rus else engb[rusb.index(i)] if i in rusb else rus[eng.index(i)] if i in eng else rusb[engb.index(i)] if i in engb else i for i in text])


def find_word(word):
    return word in rusdict or word in engdict


def replace_reg(match, repl_pattern):
    repl = ''.join([r_char if m_char.islower() else r_char.upper() for r_char, m_char in zip(repl_pattern, match)])
    repl += repl_pattern[len(match):]
    return repl


def correct_word(word):
    res = None
    for idx, w in enumerate(word[:-1]):
        kb = rus if w in rus else eng if w in eng else None
        if kb is None:
            continue
        kbs = listsplit(kb, 12)
        i, j = divmod(kb.index(w), 12)
        for oi, oj in checks:
            si, sj = i + oi, j + oj
            if not 0 <= si < len(kbs) or not 0 <= sj < len(kbs[si]):
                continue
            ex = word[:idx]+kbs[si][sj]+word[idx+1:]
            if find_word(ex):
                return ex
    return res


def reverse_usability(l):
    return 1-functools.reduce(lambda a, b: a*b, [1-i for i in l])


def is_float(a):
    try:
        float(a)
        return True
    except:
        return False


def pretty_nlp_tag(word, tag):
    return f'{word:<15} | {tag.normal_form:<15} | {tag.pos:<4} | {" | ".join(tag.tag.split("|"))}'.replace("_", '-')


def mceil(a, b):
    return b*math.ceil(a/b)


def stacks(x):
    return x // 64, x % 64


# Файлы и прочее
if os.path.exists('pips'):
    errorpic = discord.File(fp='pips/error.jpg')
    progerpic = discord.File(fp='pips/proger.png')
    cannon = discord.File(fp='pips/uranus.mp4')
    mischat = discord.File(fp='pips/mischat.png')
    iqpic = discord.File(fp='pips/iqpic.png')
    streetracing = discord.File(fp='pips/streetracing.png')
    phrasestxt = open('pips/phrases.txt', encoding='utf-8').readlines()

nexus_on = False
if_host = 'coconut.png' in os.listdir('.')

print(time.strftime("%d.%m.%Y, %X", time.localtime()))

class GenX(commands.Cog):
    def __init__(self, bot):
        self.bot = bot
        self.sounds = []
        self.cats = len(alphabet)
        self.colors = len(alphabet[0])
        self.mainchannel = None
        self.dyingFlag = True # Смерть существ, не нашедших себе пару

    @commands.Cog.listener()
    async def on_ready(self):
        self.mainchannel = self.bot.get_guild(adb.bbag).get_channel(adb.programistishe)
        self.bot.loop.create_task(self.tick())

    async def tick(self):
        gener = 0
        while True:
            if len(self.sounds) <= 1:
                await asyncio.sleep(2)
                continue
            new_sounds = []
            died = 0
            ddied = 0
            cells = 0
            half = math.floor(len(self.sounds) / 2)
            random.shuffle(self.sounds)
            one = self.sounds[:half]
            two = self.sounds[half:]
            for i in range(half):
                if one[i].nextgen(two[i]):
                    new_sounds.append(one[i])
                else:
                    died += 2
                    ddied += one[i].length + two[i].length
            if len(self.sounds) % 2 == 1:
                if not self.dyingFlag:
                    new_sounds.append(two[-1])
                else:
                    died += 1
                    ddied += two[-1].length
            self.sounds = new_sounds
            if self.sounds:
                send_list = [str(s) for s in self.sounds]
                cells = sum([s.length for s in self.sounds])
                gener = self.sounds[0].generation
                desc = '\n'.join(send_list)
                if len(desc) > 2000:
                    desc = desc[:2000] + '...'
                emb = discord.Embed(title=f'{gener} поколение', description=desc)
            else:
                emb = discord.Embed(title=f'{gener+1} поколение', description='Нет живых')
            emb.set_footer(text=f'Существ: {len(self.sounds)}, клеток: {cells} // Умерло: {died}, клеток: {ddied}')
            await self.mainchannel.send(embed=emb, delete_after=180)
            await asyncio.sleep(2)

    @commands.command()
    async def simulate(self, ctx, count):
        for i in range(int(count)):
            sound = Sound(random.randrange(0, self.cats), random.randrange(0, self.colors))
            self.sounds.append(Creature([sound], i+1))

    @commands.command()
    async def stop(self):
        self.sounds = []


class Sound:
    def __init__(self, cat, color):
        self.cat = cat
        self.color = color

    def __str__(self):
        return alphabet[self.cat][self.color]

    def __eq__(self, other):
        if self.cat == other.cat and self.color == other.color:
            return True
        return False


class Creature:
    def __init__(self, sounds, num):
        self.length = len(sounds)
        self.gen = sounds
        self.generation = 1
        self.luxury = 0
        self.num = num

    def nextgen(self, other):
        if self.length != other.length:
            print(f'{self.num}-{other.num} Смерть от мутации: неправильная длина')
            return False
        elif self.length == 1:
            if self.gen[0].cat != other.gen[0].cat and self.gen[0].color != other.gen[0].color:
                self.gen += other.gen
                self.length = 2
                self.generation = 1
                return True
            else:
                print(f'{self.num}-{other.num} Смерть на этапе 1')
                return False
        cats = set([i.cat for i in self.gen+other.gen])
        colors = set([i.color for i in self.gen+other.gen])
        cator = (len(cats),len(colors))
        #if self.gen[-1] == other.gen[0]:
            #print(f'{self.num} Смерть от одинаковых концов')
            #return False
        if self.length <= 2:
            for i in self.gen:
                for j in other.gen:
                    if i == j:
                        print(f'{self.num}-{other.num} Смерть от одинаковых клеток на этапе 2')
                        return False
            if cator == (2,2) or cator == (2,3) or cator == (3,2) or cator == (4,2):
                print(f'{self.num}-{other.num} Смерть от плохих генов на этапе 2')
                return False
            self.gen += other.gen
            self.length = 4
            self.generation = 2
            if cator == (2,4) or cator == (3,3) or cator == (4,3):
                self.luxury = 1
            elif cator == (3,4):
                self.luxury = 2
            elif cator == (4,4):
                self.luxury = 3
            return True
        elif self.length <= 4:
             if len(cats) < 5 or len(colors) < 5:
                 print(f'{self.num}-{other.num} Смерть от плохих генов на этапе 3')
                 return False
             gen = self.gen + other.gen
             cur_gen = self.gen[0]
             for i in range(1, self.length+other.length):
                 if cur_gen.cat == gen[i].cat or cur_gen.color == gen[i].color:
                     print(f'{self.num}-{other.num} Смерть от клеток подряд на этапе 3')
                     return False
                 cur_gen = gen[i]
             self.gen += other.gen
             self.length = 8
             self.generation = 3
             return True
        elif self.length <= 8:
            if len(colors) < 9:
                print(f'{self.num}-{other.num} Смерть от плохих генов на этапе 4')
                return False
            self.gen += other.gen
            self.length = 16
            self.generation = 4
            return True
        elif self.length <= 16:
            if len(colors) < 10:
                print(f'{self.num}-{other.num} Смерть от плохих генов на этапе 5')
                return False
            self.gen += other.gen
            self.length = 32
            self.generation = 5
            return True
        elif self.length <= 32:
            self.gen += other.gen
            self.length = 64
            self.generation = 6
            return True
        elif self.length <= 64:
            self.gen += other.gen
            self.length = 128
            self.generation = 7
            return True
        else:
            self.gen += other.gen
            self.length += other.length
            self.generation += 1
            return True

    def nextgen2(self, other):
        if self.length != other.length:
            print(f'{self.num}-{other.num} Смерть от мутации: неправильная длина')
            return False
        elif self.length == 1:
            if self.gen[0].cat == other.gen[0].cat or self.gen[0].color == other.gen[0].color:
                self.gen += other.gen
                self.length = 2
                self.generation = 1
                return True
            else:
                print(f'{self.num}-{other.num} Смерть на этапе 1')
                return False
        cats = set([i.cat for i in self.gen+other.gen])
        colors = set([i.color for i in self.gen+other.gen])
        cator = (len(cats),len(colors))
        if self.length <= 2:
            if cator == (4,4) or cator == (3,4):
                print(f'{self.num}-{other.num} Смерть от плохих генов на этапе 2')
                return False
            self.gen += other.gen
            self.length = 4
            self.generation = 2
            if cator == (2,4) or cator == (3,3) or cator == (4,3):
                self.luxury = 1
            if cator == (2, 2) or cator == (2, 3) or cator == (3, 2) or cator == (4, 2):
                self.luxury = 2
            return True
        elif self.length <= 4:
             if len(cats) > 4 and len(colors) > 4:
                 print(f'{self.num}-{other.num} Смерть от плохих генов на этапе 3')
                 return False
             self.gen += other.gen
             self.length = 8
             self.generation = 3
             return True
        elif self.length <= 8:
            self.gen += other.gen
            self.length = 16
            self.generation = 4
            return True
        elif self.length <= 16:
            self.gen += other.gen
            self.length = 32
            self.generation = 5
            return True
        elif self.length <= 32:
            self.gen += other.gen
            self.length = 64
            self.generation = 6
            return True
        elif self.length <= 64:
            self.gen += other.gen
            self.length = 128
            self.generation = 7
            return True
        elif self.length <= 128:
            self.gen += other.gen
            self.length = 256
            self.generation = 8
            return True
        else:
            self.gen += other.gen
            self.length += other.length
            self.generation += 1
            return True

    def __str__(self):
        sgen = [str(g) for g in self.gen]
        return ''.join(sgen)


def setup(bot):
    bot.add_cog(GenX(bot))

class Tables(commands.Cog):
    def __init__(self, bot):
        self.bot = bot
        self.mainchannel = None
        if not os.path.exists('tables'):
            os.mkdir('tables')

    @commands.Cog.listener()
    async def on_ready(self):
        self.mainchannel = self.bot.get_guild(adb.bbag).get_channel(adb.bbagmain)

    @commands.command()
    async def tablehelp(self, ctx):
        emb = discord.Embed(title='Akari Таблицы')
        emb.add_field(name='Создание таблицы', value='create_table <название> <размеp x> <размер y>\nМаксимальный размер: 75х50')
        await ctx.send(embed=emb)

    @commands.command()
    async def create_table(self, ctx, *args):
        name = ' '.join(args[:-2])
        if f'{name}.npy' in os.listdir(f'tables'):
            await ctx.send('Такая таблица уже есть!')
            return
        x, y = int(args[-2]), int(args[-1])
        if not 0 < x <= 75 or not 0 < y <= 50:
            await ctx.send('Максимальный размер — 75х50!')
            return
        tb = np.zeros((x, y), 'int')
        np.save(f'tables/{name}', tb)
        await self.show(ctx, name)

    @commands.command()
    async def show(self, ctx, *args):
        name = ' '.join(args)
        if f'{name}.npy' not in os.listdir(f'tables'):
            await ctx.send('Такой таблицы нет!')
            return
        tb = np.load(f'{name}.npy')
        

def setup(bot):
    bot.add_cog(Tables(bot))


start_time = time.time()
group_id = 194025963
vk_session = vk_api.VkApi(token=open('vktoken.txt').readlines()[0])
longpoll = VkBotLongPoll(vk_session, group_id)
vk = vk_session.get_api()

logchannel = None
vkchannel = None
client = discord.Client()
prefix = '*'
bot = commands.Bot(command_prefix=prefix, intents=discord.Intents.all())
bot.remove_command("help")


def sendls(event, mes, keyboard='', att=''):
    user = vk_session.method('users.get', {'user_ids': event.object['message']['from_id'], 'name_case':'dat'})[0]
    print(f"{user['first_name']} {user['last_name']}: {mes}")
    return vk.messages.send(user_id=event.object['message']['from_id'], message=mes, random_id=random.randint(0, 1000000), keyboard=keyboard, attachment=att)


def sendchat(event, mes, keyboard='', att=''):
    user = vk_session.method('users.get', {'user_ids': event.object['message']['from_id'], 'name_case':'dat'})[0]
    print(f"{user['first_name']} {user['last_name']} (беседа): {mes}")
    return vk.messages.send(random_id=random.randint(0, 1000000), message=mes, chat_id=event.chat_id, keyboard=keyboard, attachment=att)


def sendmes(chat_id, mes, keyboard='', att=''):
    print(f"В беседу: {mes}")
    return vk.messages.send(random_id=random.randint(0, 1000000), message=mes, chat_id=chat_id, keyboard=keyboard, attachment=att)


def getbutton(label, color, payload=''):
    return {
        'action': {
            'type': 'text',
            'payload': json.dumps(payload),
            'label': label
        },
        'color': color
    }


def newkb(buttons, ot=False):
    kb = {'one_time': ot, 'buttons': buttons}
    kb = json.dumps(kb, ensure_ascii=False).encode('utf-8')
    kb = str(kb.decode('utf-8'))
    return kb


def postfix(v, ps, rv=True):
    if v % 10 in [0, 5, 6, 7, 8, 9] or v % 100 in [11, 12, 13, 14]:
        p = ps[2]
    elif v % 10 == 1:
        p = ps[0]
    else:
        p = ps[1]
    if rv: return f'{v} {p}'
    return p


def longsplit(mes, n):
    l = len(mes)
    if l <= n:
        return [mes]
    c = math.ceil(l/n)
    res = []
    for i in range(c-1):
        res.append(mes[:n])
        mes = mes[n:]
    res.append(mes)
    return res


antikeyboard = newkb([])
mainkb = newkb([[getbutton('Поддержка 🔨', 'negative'), getbutton('О нас', 'secondary')], [getbutton('Таблица лидеров', 'positive')]], True)


async def vkmessage(obj):
    text = f"α{obj['from_id']}"
    if obj['text']:
        text += f", β{obj['text'][:1800]}"
    if obj['attachments']:
        if obj['attachments'][0]['type'] == 'photo':
            text += f", γ{obj['attachments'][0]['photo']['id']}"
            if obj['text'].startswith(adb.prefix+'ds'):
                name = obj['attachments'][0]['photo']['id']
                pic = requests.get(obj['attachments'][0]['photo']['sizes'][-1]['url'].split('/')[-1])
                pf = open(f'vk/{name}', 'wb')
                pf.write(pic.content)
                pf.close()
        if obj['attachments'][0]['type'] == 'sticker':
            text += f", δ{obj['attachments'][0]['sticker']['sticker_id']}"
    if len(obj['text']) > 1800:
        text += f", ε{len(obj['text'])}"
    await vkchannel.send(text)
    print(f"Передаю сообщение: id: {obj['from_id']}, text: {obj['text']}, atts: {len(obj['attachments'])}")


async def bbag_listener():
    while not bot.is_closed():
        try:
            for event in longpoll.listen():
                if event.type == VkBotEventType.MESSAGE_NEW:
                    b = event.object['message']['text'].lower()
                    print(event)
                    if event.object['message']['id'] <= 0:              # часть для беседы
                        obj = event.object['message']
                        await vkmessage(obj)
                        if b.startswith('привет'):
                            sendchat(event, 'привет')
                        elif b.startswith('клавиатура'):
                            sendchat(event, 'вотъ', mainkb)
                        elif b.startswith('зиг хайль'):
                            sendchat(event, 'НАШЕСТВИЕ ПОПУГАЕВ')
                            sendchat(event, 'НАШЕСТВИЕ ПОПУГЕЕВ')
                            sendchat(event, 'НАШЕСТВИЕ ПОПУГЕЕВ')
                    else:                                               # часть для лички
                        if b.startswith('привет'):
                            sendls(event, 'ДА РО УУ')
                        elif b.startswith('клавиатура'):
                            sendls(event, 'клава', mainkb)
                        else:
                            sendls(event, 'клаваjkjl')
                await asyncio.sleep(1)
        except Exception as e:
            print(e)
        await asyncio.sleep(1)


@bot.event
async def on_ready():
    global logchannel
    global vkchannel
    gr = 'Птичка в гнезде'
    logchannel = bot.get_channel(adb.botcage)
    vkchannel = bot.get_channel(adb.vkchannel)
    await logchannel.send(gr)
    print(gr)
    bot.loop.create_task(bbag_listener())


@bot.command()
async def ping(ctx):
    await logchannel.send('pong')


token = open('haidori_token.txt').readlines()[0]
bot.run(token)

class Pong:
    def __init__(self, channel_id, mem1, mem2):
        self.FIELD_SIZE = [57, 18]
        self.paddle_a_y = self.paddle_b_y = self.FIELD_SIZE[1] // 2
        self.ball_cords = [self.FIELD_SIZE[0] // 2, self.FIELD_SIZE[1] // 2]
        self.ball_speed = [2, 2]
        self.a_score, self.b_score = 0, 0
        self.player = 1
        self.channel = channel_id
        self.message = None
        self.active = True
        self.mem1 = mem1
        self.mem2 = mem2
        
    def draw_field(self):
        res = ''
        space_kef = 1.5789
        for y in range(self.FIELD_SIZE[1]+4):
            y -= 3
            res += '|'
            space_counter = 0
            if y == -2:
                sign, a_chars, b_chars = self.FIELD_SIZE[0] // 2, 1, 1
                if self.a_score > 9:
                    a_chars += 1
                if self.b_score > 9:
                    b_chars += 1
                if self.player == 1:
                    a_chars += 1
                else:
                    b_chars += 1
                res += ' ' * int((sign-a_chars) * space_kef)
                if self.player == 1:
                    res += "<"
                res += f"{self.a_score}:{self.b_score}"
                if self.player == 2:
                    res += ">"
                res += ' ' * int((self.FIELD_SIZE[0]-(sign+1+b_chars)) * space_kef)
                res += '|\n'
                continue
            for x in range(self.FIELD_SIZE[0]):
                if y in [-3, -1, self.FIELD_SIZE[1]]:
                    res += '-'
                elif (x == 0 and -1 <= self.paddle_a_y-y <= 1) or (x == self.FIELD_SIZE[0]-1 and -1 <= self.paddle_b_y-y <= 1):
                    res += '#'
                elif x == self.ball_cords[0] and y == self.ball_cords[1]:
                    res += '@'
                else:
                    res += ' ' * int(space_kef * x - space_counter)
                    space_counter += int(space_kef * x - space_counter)
            res += "|\n"
        return res
        
    def move_paddle(self, moving_player, value):
        if moving_player == 1:
            self.paddle_a_y = max(min(self.paddle_a_y+value, self.FIELD_SIZE[1]-1), 1) 
        elif moving_player == 2:
            self.paddle_b_y = max(min(self.paddle_b_y+value, self.FIELD_SIZE[1]-1), 1) 
            
    def tick(self):
        self.ball_cords[0] += self.ball_speed[0]
        self.ball_cords[1] += self.ball_speed[1]
        defaultFlag = False
        if self.ball_cords[0] < 1:
            if -1 <= self.ball_cords[1] - self.paddle_a_y <= 1:
                self.ball_cords[0] += (1 - self.ball_cords[0]) * 2
                self.ball_speed[0] *= -1
            else:
                self.b_score += 1
                self.player = 2
                defaultFlag = True
        elif self.ball_cords[0] > self.FIELD_SIZE[0] - 2:
            if -1 <= self.ball_cords[1] - self.paddle_b_y <= 1:
                self.ball_cords[0] += (self.ball_cords[0] - (self.FIELD_SIZE[0]-2)) * 2
                self.ball_speed[0] *= -1
            else:
                self.a_score += 1
                self.player = 1
                defaultFlag = True
        if self.ball_cords[1] < 0:
            self.ball_cords[1] *= -1
            self.ball_speed[1] *= -1
        elif self.ball_cords[1] > self.FIELD_SIZE[1] - 1:
            self.ball_cords[1] -= (self.ball_cords[1] - (self.FIELD_SIZE[1]-1)) * 2
            self.ball_speed[1] *= -1
        if self.a_score > 20:
            self.active = False
            return 1
        if self.b_score > 20:
            self.active = False
            return 2
        if defaultFlag:
            self.set_default_values()
        return 0

    def set_default_values(self):
        self.ball_cords[0] = self.FIELD_SIZE[0] // 2
        self.ball_cords[1] = self.FIELD_SIZE[1] // 2
        self.ball_speed[0] = random.choice([-1, 1])
        self.ball_speed[1] = random.choice([-1, 1])
        self.paddle_a_y = self.FIELD_SIZE[0] // 2
        self.paddle_b_y = self.FIELD_SIZE[0] // 2
            

class PongCog(commands.Cog):
    def __init__(self, bot):
        self.bot = bot
        self.pongs = defaultdict(int)

    @commands.Cog.listener()
    async def on_raw_reaction_add(self, payload):
        if self.pongs[payload.channel_id]:
            pong = self.pongs[payload.channel_id]
            if payload.user_id == pong.mem1:
                if payload.emoji == pong_a:
                    pong.move_paddle(1, -1)
                elif payload.emoji == pong_z:
                    pong.move_paddle(1, 1)
            elif payload.user_id == pong.mem2:
                if payload.emoji == pong_k:
                    pong.move_paddle(2, -1)
                elif payload.emoji == pong_m:
                    pong.move_paddle(2, 1)

    @commands.command(aliases=["pong"])
    async def run_pong(self, ctx, mem1: discord.Member = None, mem2: discord.Member = None):
        if mem1 is None:
            await ctx.channel.send(f"Determine a player!")
            return
        if mem2 is None:
            mem2 = mem1
            mem1 = ctx.author
        if not self.pongs[ctx.channel.id]:
            self.pongs[ctx.channel.id] = Pong(ctx.channel.id, mem1.id, mem2.id)
        else:
            self.pongs[ctx.channel.id].mem1 = mem1.id
            self.pongs[ctx.channel.id].mem2 = mem2.id
        pong = self.pongs[ctx.channel.id]
        if not pong.message:
            pong.message = await ctx.send(pong.draw_field())
            await pong.message.add_reaction(pong_a)
            await pong.message.add_reaction(pong_z)
            await pong.message.add_reaction(pong_k)
            await pong.message.add_reaction(pong_m)
        while not self.bot.is_closed() and pong.active:
            await asyncio.sleep(0.5)
            tick = pong.tick()
            if tick:
                await pong.message.channel.send(f"Player {tick} wins!")
                return
            await pong.message.edit(content=pong.draw_field())


def setup(bot):
    bot.add_cog(PongCog(bot))

DIR = os.path.dirname(__file__)
db = sqlite3.connect(os.path.join(DIR, "Monopoly.db"))
SQL = db.cursor()
log = logging.getLogger('Monopoly')
log.setLevel(logging.INFO)
if not os.path.exists('MonopolyLogs'):
    os.mkdir('MonopolyLogs')
fh = logging.FileHandler(f'MonopolyLogs/Monopoly-{time.strftime("%d.%m.%Y-%H.%M", time.localtime())}.txt')
fh.setLevel(logging.INFO)
formatter = logging.Formatter('%(asctime)s - %(name)s - %(levelname)s - %(message)s')
fh.setFormatter(formatter)
log.addHandler(fh)

def iconfinder(emoji):
    icons = []
    for i in range(6):
        try:
            if i == 0:
                icon = SQL.execute(f"SELECT eid FROM monop_emos WHERE emoji = '{emoji}'").fetchone()[0]
                icons.append(f'<:{emoji}:{icon}>')
            else:
                icon = SQL.execute(f"SELECT eid FROM monop_emos WHERE emoji = '{emoji}{i}'").fetchone()[0]
                icons.append(f'<:{emoji}{i}:{icon}>')
        except Exception as e:
            print(e)
    return icons


class Monopoly(commands.Cog):
    """docstring for Monopoly"""

    def __init__(self, bot):
        self.bot = bot
        self.monop_channelid = adb.monopolishe
        self.monop_channel = None
        self.maptype = 0
        self.map = None
        self.mapmes = None
        self.playmes = None
        self.infomes = None
        self.sellmes = None
        self.stockmes = None
        self.trademes = None
        self.curblock = ''
        self.players = []
        self.player_colors = []
        self.w8react = []
        self.on = False
        self.ongame = {}
        self.credits = defaultdict(dict)
        self.pledges = defaultdict(dict)
        self.stocks = []
        self.upgradeFlag = False
        self.userlist = defaultdict(dict)
        self.emosdict = defaultdict(list)
        self.emos = []
        self.ai_emos = []
        self.ai_names = []
        self.timers = []
        dbAkari = sqlite3.connect(os.path.join(DIR, "Akari.db"))
        SQLA = dbAkari.cursor()
        SQLA.execute('SELECT * FROM emos')
        emos = SQLA.fetchall()
        for e in emos:
            if e[5]:
                code = f'<a:{e[0]}:{e[1]}>'
            else:
                code = f'<:{e[0]}:{e[1]}>'
            self.emosdict[e[2]].append(code)

    async def showmap(self):
        emb = discord.Embed(title='Игроки', color=random.choice(adb.raincolors))
        for p in self.players:
            if not p.ikiru:
                text = f'Мёртв)) Очки: {p.worth}'
                emb.add_field(name=f'{p.nick}', value=text, inline=False)
                continue
            text = f'${p.money}, положение: {p.cords}\n∑{p.get_netmort()}'
            if p.credit:
                text += f', кредит: ${p.credit["money"]} ({p.credit["expires"]})'
            if p.stocks:
                text += f', акций: {len(p.stocks)})'
            text += f'\nОчки: {p.worth}'
            if p.slaps:
                text += f', {slap}{p.slaps}'
            if p.shops:
                text += f'\nСобственность: {p.show_shops()}'
            if p == self.ongame['cur_player']:
                if self.curblock:
                    emb.add_field(name=f'{p.nick}', value=text, inline=True)
                    if self.ongame['status'] == 'cubes':
                        emb.add_field(name=f'Текущий ход', value=f'Бросайте кубик!', inline=True)
                    else:
                        emb.add_field(name=f'Текущий ход', value=f'{self.curblock}', inline=True)
                    continue
            emb.add_field(name=f'{p.nick}', value=text, inline=False) # список магазов, баланс, корды и звёзды
        editFlag = False
        if self.mapmes:
            async for i in self.monop_channel.history(limit=7):
                if i.id == self.mapmes.id:
                    editFlag = True
        if editFlag:
            if self.playmes:
                try:
                    await self.playmes.edit(embed=emb)
                    if self.mapmes:
                        try:
                            await self.mapmes.edit(content=str(self.map))
                        except:
                            pass
                    else:
                        self.mapmes = await self.monop_channel.send(str(self.map))
                    return
                except:
                    pass
        if self.playmes:
            try:
                await self.playmes.delete()
            except:
                pass
        self.playmes = await self.monop_channel.send(embed=emb)
        if self.mapmes:
            try:
                await self.mapmes.delete()
            except:
                pass
        self.mapmes = await self.monop_channel.send(str(self.map))

    def update_player(self, player):
        for i, p in enumerate(self.players):
            if p.id == player.id:
                self.players[i] = player

    def finduser(self, pid):
        pid = str(pid).lower()
        for i in self.players:
            if pid in [i.name.lower(), i.men.lower(), str(i.id), i.icon.lower(), i.color.lower(), i.nick.lower()]:
                return i
            for j in [i.name.lower(), i.men.lower(), str(i.id), i.icon.lower(), i.color.lower(), i.nick.lower()]:
                if j in pid:
                    return i
        for i in self.userlist:
            if pid == str(self.userlist[i]['bbagid']) or pid in self.userlist[i]['name'].lower() or str(self.userlist[i]['roleid']) in pid:
                for p in self.players:
                    if self.userlist[i]['id'] == p.id:
                        return p

    async def cubes(self, mes, player):
        count = player.cubes
        random.seed(mes.content)
        vs = [random.randint(1, 6) for _ in range(count)]
        cubes = [Cube(vs[i]) for i in range(count)]
        self.map.inject_cubes(cubes, sum(vs))
        self.map.move_player(player, sum(vs))
        self.curblock = self.map.blockinfo(player, self.players)
        self.map.show_shops(self.players, player)
        player.update_shop(self.map.blocks[player.si])
        self.update_player(player)
        await self.showmap()

    def eclevel(self, ai):
        for i in ai.shops:
            if i.buyback:
                return 0
        if self.ongame['round'] < 20:
            return 3
        if ai.monopolies:
            return 3
        return 2

@commands.Cog.listener()
    async def on_ready(self):
        if self.monop_channelid:
            self.monop_channel = self.bot.get_channel(self.monop_channelid)

    def sellshop(self, player, shop):
        for p in self.players:
            if p.id == player:
                for i in range(len(self.map.blocks)):
                    s = self.map.blocks[i]
                    if s.cat == 'shop':
                        if s.shop == shop:
                            s.owner = None
                            s.icon = s.icons[0]
                            s.income = 0
                            s.buyback = False
                            self.map.blocks[i] = s
                            p.update_shop(s)
                            self.update_player(p)
                            del self.pledges[player][shop]
                            return

    async def sellsend(self):
        tosell, emb = self.ongame['cur_player'].to_sell()
        if tosell:
            if self.sellmes:
                await self.sellmes.delete()
                self.sellmes = None
            self.sellmes = await self.monop_channel.send(embed=emb)
            for e in tosell:
                await self.sellmes.add_reaction(e)
            self.w8react.append(('sell', self.sellmes, self.ongame['cur_player']))
        await self.monop_channel.send(f'{self.ongame["cur_player"].nick}, закончились деньги! Закладывайте филиалы, берите кредит, следайте что-нибудь!')

@commands.command()
    async def monopoly_test(self, ctx, ais=0, t: int = 2):
        if self.ongame:
            await ctx.send(f"Игра уже началась!", delete_after=10)
            return
        if not self.monop_channelid == ctx.channel.id:
            if self.monop_channel:
                monop_channel = self.bot.get_channel(self.monop_channelid)
                await ctx.send(f"Вы не можете играть в этом канале. Играть в {monop_channel.mention}", delete_after=10)
            else:
                await ctx.send("У нас нет канала для монополии. Задать канал командой **monop_setchannel**", delete_after=10)
            return
        evrv = ctx.guild.default_role
        await self.monop_channel.set_permissions(evrv, view_channel=True)
        self.map = Map(t)
        self.on = True
        self.player_colors = [pc for pc in player_colors]
        self.ai_names = [a for a in ai_names]
        self.ai_emos = [e for e in ai_emos]
        noPlayer = False
        if ais < 0:
            ais = abs(ais)
            noPlayer = True
        colors = adb.sevranchoice(self.player_colors, ais+1)
        emos = adb.sevranchoice(self.ai_emos, ais)
        names = adb.sevranchoice(self.ai_names, ais)
        for i in range(ais+1):
            if i == ais:
                if not noPlayer:
                    self.players.append(Player(ctx.author, '🤪', colors[i], t))
                    await ctx.channel.send(f'{ctx.author.mention} 🤪, ваш цвет — {colors[i]}')
            else:
                self.players.append(Player(ctx.author, emos[i], colors[i], t, ai=names[i]))
                await ctx.channel.send(f'{names[i]} {emos[i]}, ваш цвет — {colors[i]}')
        self.monop_channel = self.bot.get_channel(self.monop_channelid)
        random.shuffle(self.players)
        self.ongame = {'cp_id': 0, 'cur_player': self.players[0], 'status': 'cubes', 'round': 1, 'criminal': '', 'crm_player': None}
        self.w8react = []
        await self.mhelp()
        self.map.show_colors(self.players[1])
        await self.showmap()
        await ctx.send(f"Игра начинается!")
        if self.ongame['cur_player'].AI:
            await self.ai_processing(self.ongame['cur_player'], 'cubes', ctx.message.content)

    @commands.command()
    async def monopoly_stop(self, ctx):
        self.maptype = 0
        self.map = None
        self.mapmes = None
        self.playmes = None
        self.infomes = None
        self.sellmes = None
        self.stockmes = None
        self.trademes = None
        self.curblock = ''
        self.players = []
        self.player_colors = []
        self.w8react = []
        self.on = False
        self.ongame = {}
        self.credits = defaultdict(dict)
        self.pledges = defaultdict(dict)
        self.stocks = []
        self.upgradeFlag = False
        self.userlist = defaultdict(dict)
        self.emosdict = defaultdict(list)
        self.emos = []
        self.ai_emos = []
        self.ai_names = []
        self.timers = []

    @commands.command()
    async def monopoly_pause(self, ctx):
        self.on = False

    @commands.command()
    async def monopoly_on(self, ctx):
        self.on = True

    @commands.command()
    async def monopoly_help(self, ctx):
        await self.mhelp()

    @commands.command()
    async def monopoly(self, ctx, t=0):
        if self.monop_channel:
            evrv = ctx.guild.default_role
            await self.monop_channel.set_permissions(evrv, view_channel=True)
        if t == 'help':
            await self.mhelp()
            return
        if self.ongame:
            await ctx.send(f"Игра уже началась!", delete_after=10)
            return
        if not self.monop_channelid == ctx.channel.id:
            if self.monop_channel:
                monop_channel = self.bot.get_channel(self.monop_channelid)
                await ctx.send(f"Вы не можете играть в этом канале. Играть в {monop_channel.mention}", delete_after=10)
            else:
                await ctx.send("У нас нет канала для монополии. Задать канал командой **monop_setchannel**", delete_after=10)
            return

        self.maptype = int(t)
        self.map = Map(self.maptype)

        db = sqlite3.connect(os.path.join(self.DIR, "Akari.db"))
        SQL = db.cursor()

        for m in ctx.guild.members:
            try:
                SQL.execute(f'SELECT bbagid, name, roleid FROM exp WHERE id = {m.id} AND server = {ctx.guild.id}')
                data = SQL.fetchone()
                self.userlist[m.id] = {'id': m.id, 'bbagid': int(data[0]), 'name': data[1], 'roleid': int(data[2])}
            except:
                pass
        db.close()

        self.on = True
        self.player_colors = [pc for pc in player_colors]
        self.emos = [e for e in emos]
        self.ai_names = [a for a in ai_names]
        self.ai_emos = [e for e in ai_emos]
        await ctx.send("Добро пожаловать в Монополию! Ставьте +, чтобы присоединиться, и ++, чтобы закончить набор игроков")

    @commands.command()
    async def monop_setchannel(self, ctx):
        self.monop_channelid = ctx.channel.id
        self.monop_channel = ctx.channel
        await ctx.send(f"Монополия теперь в канале {ctx.channel.mention}", delete_after=10)

    @commands.command()
    async def monopoly_hide(self, ctx, t=0):
        evrv = ctx.guild.default_role
        await self.monop_channel.set_permissions(evrv, view_channel=False)


class Shop:
    def __init__(self, cords, data, number):
        self.cat = 'shop'
        self.shop = data['name']
        self.vinshop = data['name']
        self.rodshop = data['name']
        if 'vin' in data['special']:
            self.vinshop = data['special']['vin']
        if 'rod' in data['special']:
            self.rodshop = data['special']['rod']
        self.monopoly = data['mon_name']
        self.cost = data['buyfor']
        self.mortgage = [self.cost//10, self.cost//2, self.cost, self.cost*2, self.cost*3, self.cost*5]
        self.up = data['up']
        self.icons = iconfinder(data['brief'])
        self.icon = self.icons[0]
        self.raw_icon = self.icons[0]
        self.special = data['special']
        self.level = 0
        self.owner = None
        self.cords = cords
        self.number = number
        self.desc = ''
        self.worth = data['buyfor']
        self.income = 0
        self.in_monopoly = False
        self.buyback = False
        self.stocks = defaultdict(int)
        self.anomale = False

    def get_mort(self):
        try:
            res = self.mortgage[self.level]
        except:
            res = self.mortgage[-1]
        return res

    def __eq__(self, other):
        if not hasattr(other, 'shop'):
            if self.shop == other:
                return True
            return False
        if self.shop == other.shop:
            return True
        return False

    def __str__(self):
        return f'{self.shop}{self.raw_icon} {self.cords} owner={self.owner} level={self.level}'


class Special:
    def __init__(self, cords, typ):
        self.cat = 'special'
        self.type = typ
        self.cords = cords
        self.icons = ['<:mss:829981282649899030>', '<:msp:829981282511486977>', '<:msr:829981282310160414>', '<:msj:829981282167029760>', '<:msc:829981281973567499>', '<:msd:829981282830123059>']
        self.icon = self.icons[typ]
        self.brief = ['start', 'police', 'roulette', 'jail', 'criminal', 'ruins']
        self.roulettes = ['<:msr0:829981282486059038>', '<:msr1:829981282946777088>', '<:msr2:829981282036744203>', '<:msr3:829981282586198036>', '<:msr4:829981282464169984>', '<:msr5:829981282569158676>', '<:msr6:829981282200584243>']
        self.desc = ''
        self.chanced = 0


class Bonus:
    def __init__(self, cords, typ):
        self.cat = 'bonus'
        self.type = typ
        self.cords = cords
        self.icon = '<:msb:829981283366076457>'
        self.desc = ''


class Anti:
    def __init__(self, cords, typ):
        self.cat = 'anti'
        self.type = typ
        self.cords = cords
        self.icon = '<:msa:829981282263629835>'
        self.desc = ''


class Cube:
    def __init__(self, value):
        self.value = value
        self.icon = cube_values[value-1]


class Player:
    def __init__(self, mem, icon, color, mt=0, ai=''):
        self.mem = mem
        self.name = mem.display_name
        self.men = mem.mention
        self.id = mem.id
        self.icon = icon
        self.lockicon = locked_icons[player_colors.index(color)]
        self.levelicons = player_color_icons[player_colors.index(color)]
        self.color = color
        self.nick = color + mem.display_name + icon
        self.money = 15000
        self.cords = adb.monop_sequences[mt][0]
        self.si = 0  # sequence_i
        self.shops = []
        self.monopolies = []
        self.credit = defaultdict(int)
        self.stocks = defaultdict(int)
        self.AI = ai
        if ai:
            self.mem = ai + ' <:msi:830199941640618005>'
            self.name = ai
            self.men = ai + ' <:msi:830199941640618005>'
            self.id = random.randint(100000000, 999999999)
            self.nick = color + self.men + icon
        self.worth = 0
        self.jailed = False
        self.slaps = 0
        self.circle = 0
        self.ikiru = True
        self.cubes = 2

    def show_shops(self):
        res = ''
        for m in self.monopolies:
            for s in self.shops:
                if s.monopoly == m:
                    res += s.icon
            res += '◈'
        for s in self.shops:
            if s.monopoly not in self.monopolies:
                res += s.icon + ' '
        return res

    def to_upgrade(self, ai=''):
        toup = []
        emb_dict = {m: [] for m in self.monopolies}
        for m in self.monopolies:
            for s in self.shops:
                if s.monopoly == m and s.level < 5 and not s.anomale:
                    if ai:
                        toup.append(s)
                    else:
                        toup.append(s.raw_icon)
                        emb_dict[m].append(f'{s.icon}{s.up}')
        backs = []
        for s in self.shops:
            if s.buyback:
                if ai:
                    backs.append(s)
                else:
                    toup.append(s.raw_icon)
                    backs.append(f'{s.icon}{int(s.cost * 0.6)}')
        if ai:
            return toup, backs
        emb = discord.Embed(title='Доступно для апгрейда')
        for m in self.monopolies:
            if emb_dict[m]:
                emb.add_field(name=m, value=' '.join(emb_dict[m]), inline=True)
        if backs:
            emb.add_field(name='Доступно для выкупа', value=' '.join(backs), inline=False)
        return toup, emb

    def to_sell(self, pledge=True, ai=''):
        tosell = []
        emb_dict = {m: [] for m in self.monopolies}
        for m in self.monopolies:
            for s in self.shops:
                if s.monopoly == m and s.level > 0:
                    if ai:
                        tosell.append(s)
                    else:
                        tosell.append(s.raw_icon)
                    emb_dict[m].append(f'{s.icon}{int(s.up * 0.5)}')
        pleds = []
        if pledge or ai:
            for m in self.monopolies:
                mFlag = True
                for s in self.shops:
                    if s.monopoly == m and s.level > 0:
                        mFlag = False
                if mFlag:
                    for s in self.shops:
                        if s.monopoly == m:
                            if ai:
                                pleds.append(s)
                            else:
                                tosell.append(s.raw_icon)
                                pleds.append(f'{s.icon}{int(s.cost * 0.5)}')
            for s in self.shops:
                if s.monopoly not in self.monopolies:
                    if ai:
                        pleds.append(s)
                    else:
                        tosell.append(s.raw_icon)
                        pleds.append(f'{s.icon}{int(s.cost * 0.5)}')
        if ai:
            return tosell, pleds
        emb = discord.Embed(title='Доступно для продажи')
        for m in self.monopolies:
            if emb_dict[m]:
                emb.add_field(name=m, value=' '.join(emb_dict[m]), inline=True)
        if pleds:
            emb.add_field(name='Доступно под залог', value=' '.join(pleds), inline=False)
        return tosell, emb

    def update_shop(self, shop):
        for i in range(len(self.shops)):
            if shop.cat == 'shop':
                if self.shops[i].shop == shop.shop:
                    self.shops[i] = shop

    def get_netmort(self):
        return self.money + int(sum([s.worth for s in self.shops]))

    def get_sellmort(self):
        return self.money + int(sum([s.worth for s in self.shops]) // 2)

    def networth(self):
        res = self.money + self.worth
        return res

    def __eq__(self, other):
        if not other:
            return False
        if self.id == other.id:
            return True
        return False


class Map:
    def __init__(self, typ):
        self.type = typ
        map_grid = adb.monop_maps[typ]
        self.sequence = adb.monop_sequences[typ]
        self.prefs = adb.monop_prefs[typ]
        self.cubes = adb.monop_cubes[typ]
        self.cube_nums = adb.monop_cube_nums[typ]
        sizes = self.prefs[5]
        self.base = [['⬛' for _ in range(sizes[0])] for _ in range(sizes[1])]
        for i in self.cubes:
            self.base[i[0]][i[1]] = '🧊'
        for i in self.sequence:
            self.base[i[0]][i[1]] = '⬜'
        self.blocks = []
        get_shops, self.monopolies = self.get_shops(self.prefs[0])
        shops_idx = 0
        spec_idx = 0
        bonus_idx = 0
        anti_idx = 0
        bonuses = adb.sevranchoice([1, 2, 3, 4], self.prefs[2])
        antis = adb.sevranchoice([1, 2, 3, 4, 5], self.prefs[3])
        for i, s in enumerate(self.sequence):
            ind = map_grid[s[0]][s[1]]
            obj = None
            if ind == 1:
                obj = Shop(s, get_shops[shops_idx], shops_idx)
                shops_idx += 1
            elif ind == 2:
                obj = Special(s, spec_idx)
                spec_idx += 1
            elif ind == 3:
                obj = Bonus(s, bonuses[bonus_idx])
                bonus_idx += 1
            elif ind == 4:
                obj = Anti(s, antis[anti_idx])
                anti_idx += 1
            self.blocks.append(obj)
        #не забыть бум

    def get_shops(self, count):
        res = []
        shops = [i for i in all_shops if i['special'] != 'add' and i['name'] != 'Disabled']  # основные монополии
        addictional = [i for i in all_shops if i['special'] == 'add' and i['name'] != 'Disabled']  # дополнительные могут включиться случайно
        c = 0
        i = 0
        while c != count:  # заполняем res количеством магазов = count
            if c > count:   # если превышает, заменяем одну 4-монополию на 3- и удаляем её из addictional
                idxs = [idx for idx, j in enumerate(res) if j['length'] == 4 and j['special'] != 'shuffled']
                idx = random.choice(idxs)
                res[idx] = random.choice([k for k in addictional if k['length'] == 3])
                del addictional[addictional.index(res[idx])]
                c -= 1
                break
            else:
                res.append(shops[i])
                c += shops[i]['length']
                i += 1

        idxs = []
        for i in addictional: # дополнительные монополии (шанс начать игру не имея ни одной такой = 40,5%)
            if adb.chance(14):
                choice_list = [j for j, k in enumerate(res) if k['length'] == i['length'] and k['special'] != 'shuffled' and j not in idxs]
                if choice_list:
                    idx = random.choice(choice_list)
                    idxs.append(idx) # во избежание замены одной и той же монополии два раза
                    res[idx] = i

        monopolies = {} # список монополий
        mons = [m for m in res]
        for m in mons:
            monopolies[m['name']] = {'name': m['name'], 'length': m['length'], 'special': m['special']}

        shuffled_monopoly = None
        shuf_idxs = [] # добавляем индексы для монополии, ячейки которой разбросаны по всей карте
        if_shuf = [k for k in res if k['special'] == 'shuffled']
        if if_shuf:
            space = count // if_shuf[0]['length'] # для монополии длиной 4 и count = 31: space = 7
            cur_shuf_idx = space // 2             # первая клетка будет иметь индекс 3 (отсчёт от 0)
            shuf_idxs.append(cur_shuf_idx)
            for i in range(1, if_shuf[0]['length']):
                cur_shuf_idx += space             # следующие соответственно: 10, 17, 24
                shuf_idxs.append(cur_shuf_idx)    # разрыв между первым и последним: 11 (в случае с count = 32 будет 8)
            shuffled_monopoly = if_shuf[0]
            del res[res.index(shuffled_monopoly)] # удаляем эту монополию из общего списка и рассматриваем отдельно

        result = [{} for _ in range(count)]
        c = 0
        if shuffled_monopoly:
            for i, shop in enumerate(shuffled_monopoly['shops']):
                result[shuf_idxs[i]] = shop
        for mon in res:
            for shop in mon['shops']:
                while result[c]:
                    c += 1
                result[c] = shop
                c += 1
        return result, monopolies

    def inject_cubes(self, cubes, sum):
        a = adb.sevranchoice(self.cubes, len(cubes))
        for idx, i in enumerate(a):
            self.base[i[0]][i[1]] = cubes[idx].icon
        dec = self.cube_nums[0]
        uni = self.cube_nums[1]
        if sum >= 10:
            self.base[dec[0]][dec[1]] = cube_numbers[sum // 10]
        self.base[uni[0]][uni[1]] = cube_numbers[sum % 10]

    def move_player(self, player, value):
        player.si += value
        if player.si >= len(self.sequence):
            player.si -= len(self.sequence)
            player.circle += 1
            player.money += 2000
        player.cords = self.sequence[player.si]

    def unject_cubes(self):
        for i in self.cubes:
            self.base[i[0]][i[1]] = '🧊'
        for i in self.cube_nums:
            self.base[i[0]][i[1]] = '⬛'

    def show_colors(self, next_player):
        for idx, i in enumerate(self.sequence):
            if self.blocks[idx].cat == 'shop':
                if self.blocks[idx].owner:
                    if self.blocks[idx].buyback:
                        self.base[i[0]][i[1]] = self.blocks[idx].owner.lockicon
                    elif self.blocks[idx].level > 0:
                        self.base[i[0]][i[1]] = self.blocks[idx].owner.shopcolors[self.blocks[idx].level - 1]
                    else:
                        self.base[i[0]][i[1]] = self.blocks[idx].owner.color
                else:
                    self.base[i[0]][i[1]] = '⬜'
        i = next_player.cords
        self.base[i[0]][i[1]] = next_player.icon

    def show_shops(self, players, cur_player):
        for idx, i in enumerate(self.sequence):
            self.base[i[0]][i[1]] = self.blocks[idx].icon
        for p in players:
            if p.ikiru:
                i = p.cords
                self.base[i[0]][i[1]] = p.icon
        i = cur_player.cords
        self.base[i[0]][i[1]] = cur_player.icon

    def __str__(self):
        monopoly = ''
        for i in self.base:
            for j in i:
                monopoly += j
            monopoly += '\n'
        return monopoly


def setup(bot):
    bot.add_cog(Monopoly(bot))

translator = google_translator()


class Funx(commands.Cog):
    def __init__(self, bot):
        self.bot = bot
        self.DIR = os.path.dirname(__file__)
        self.reminder_list = []
        self.transchan_mode = 'en'
        self.nikki_en = None
        self.nikki_ja = None
        self.nikki_es = None

    @tasks.loop(seconds=15)
    async def rainbow(self):
        rainbowrole = self.bot.get_guild(adb.dmh).get_role(393305847930945536)
        await rainbowrole.edit(colour=discord.Colour(random.choice(adb.raincolors)))

    @tasks.loop(seconds=adb.reminder_cd)
    async def reminder(self):
        remchannel = self.bot.get_channel(388321118269734922)
        adm = self.bot.get_guild(adb.dmh).get_member(262288342035595268)
        if self.reminder_list:
            async for i in remchannel.history(limit=100):
                if i.embeds:
                    if i.embeds[0].title in adb.businesses:
                        await i.delete()
            emb = discord.Embed(title=random.choice(adb.businesses), colour=random.choice(adb.raincolors))
            for i in range(len(self.reminder_list)):
                t = self.reminder_list[i][1]
                if t <= 0:
                    await remchannel.send(f'{adm.mention}, настала пора {self.reminder_list[i][0]}')
                    del self.reminder_list[i]
                    continue
                send = ""
                if t // 86400 > 0: send += adb.postfix(t // 86400, ['день', 'дня', 'дней']) + ' '
                m = t % 86400
                if m // 3600 > 0: send += adb.postfix(m // 3600, ['час', 'часа', 'часов']) + ' '
                m = m % 3600
                if m // 60 > 0: send += adb.postfix(m // 60, ['минута', 'минуты', 'минут']) + ' '
                m %= 60
                if m >= 0: send += adb.postfix(m, ['секунда', 'секунды', 'секунд'])
                emb.add_field(name=f'{random.choice(adb.business)} #{i + 1}: {self.reminder_list[i][0]}',
                              value=f"Осталось: {send}", inline=False)
                self.reminder_list[i][1] -= adb.reminder_cd
            if len(emb.fields) > 0:
                await remchannel.send(embed=emb)

    @commands.Cog.listener()
    async def on_ready(self):
        self.rainbow.start()
        remchannel = self.bot.get_channel(388321118269734922)
        async for i in remchannel.history(limit=100):
            if i.embeds:
                for f in i.embeds[0].fields:
                    one = f.name.split(':')[1].lstrip()
                    two = 0
                    v = f.value
                    if 'де' in v or 'дн' in v:
                        two += int(v.split('д')[0].split(' ')[-2])
                    if 'ча' in v:
                        two += int(v.split('ча')[0].split(' ')[-2])
                    if 'мин' in v:
                        two += int(v.split('мин')[0].split(' ')[-2])
                    self.reminder_list.append([one, two])
        self.reminder.start()
        self.nikki_en = self.bot.get_channel(adb.nikkis[1])
        self.nikki_ja = self.bot.get_channel(adb.nikkis[2])
        self.nikki_es = self.bot.get_channel(adb.nikkis[3])

    async def nikkisend(self, tr, chan):
        tr1 = ''
        tr2 = ''
        if len(tr[0]) > 1900:
            tr1 = tr[0][1900:]
            tr[0] = tr[0][:1900]
        if tr[2]:
            if len(tr[2]) > 1900:
                tr2 = tr[2][1900:]
                tr[2] = tr[2][:1900]
        await chan.send(tr[0])
        if tr1:
            await chan.send(tr1)
        if tr[2]:
            await chan.send(tr[2])
            if tr2:
                await chan.send(tr2)

    @commands.Cog.listener()
    async def on_message(self, message):
        if message.type is discord.MessageType.pins_add:
            await message.delete()
        if message.channel.id == adb.transchan:
            if message.author.bot:
                return
            if message.content.startswith(adb.prefix):
                return
            tr = translator.translate(message.clean_content, lang_tgt=self.transchan_mode, pronounce=True)
            await message.channel.send(tr[0])
            if tr[2]:
                await message.channel.send(tr[2])
        if message.channel.id == adb.nikkis[0] and message.author.id != self.bot.user.id and not message.content.startswith(adb.prefix):
            if message.content:
                tr_en = translator.translate(message.clean_content, lang_tgt='en', pronounce=True)
                tr_ja = translator.translate(message.clean_content, lang_tgt='ja', pronounce=True)
                tr_es = translator.translate(message.clean_content, lang_tgt='es', pronounce=True)
                await self.nikkisend(tr_en, self.nikki_en)
                await self.nikkisend(tr_ja, self.nikki_ja)
                await self.nikkisend(tr_es, self.nikki_es)
            for a in message.attachments:
                if a.filename.endswith((".png", ".jpg", ".gif")):
                    pic = requests.get(a.url)
                    pf = open(a.filename, 'wb')
                    pf.write(pic.content)
                    pf.close()
                    await self.nikki_en.send(file=discord.File(fp=a.filename))
                    await self.nikki_ja.send(file=discord.File(fp=a.filename))
                    await self.nikki_es.send(file=discord.File(fp=a.filename))
                    await asyncio.sleep(1)
                    os.remove(a.filename)

    @commands.command()
    async def imacoder(self, ctx):
        await ctx.send("Мантра программиста перед началом проекта. Аминь", file=adb.progerpic)

    @commands.command()
    async def memeload(self, ctx, de=None):
        if not os.path.exists('memeUpload'):
            os.mkdir('memeUpload')
        for a in os.listdir('memeUpload'):
            if a.endswith((".png", ".jpg", ".gif")):
                file = discord.File(fp=f'memeUpload/{a}')
                try:
                    await ctx.send(file=file)
                    await asyncio.sleep(0.5)
                    if not de:
                        os.remove(f'memeUpload/{a}')
                except:
                    pass

    @commands.command()
    async def clear(self, ctx, amount: int):
        limit = 20
        if amount > limit:
            await ctx.message.delete()
            await ctx.send(f"Не больше {limit}", file=adb.errorpic, delete_after=5)
        else:
            await ctx.channel.purge(limit=amount + 1)
            clearemb = discord.Embed(
                title=f"{random.choice(adb.clears)} {adb.postfix(amount, ['сообщение', 'сообщения', 'сообщений'])}",
                colour=random.choice(adb.raincolors))
            await ctx.send(embed=clearemb, delete_after=5)

    @commands.command()
    async def remind(self, ctx, desc, t='0'):
        if desc == 'delete':
            del self.reminder_list[t-1]
            return
        t = str(t)
        ti = 0
        if 'd' in t: ti += int(t.split('d')[0]) * 86400
        elif 'h' in t: ti += int(t.split('h')[0]) * 3600
        elif 'm' in t: ti += int(t.split('m')[0]) * 60
        else: ti += int(t)
        t = int(ti)
        self.reminder_list.append([desc, t])

    @commands.command()
    async def r(self, ctx, *text: str):
        text = ' '.join(text)
        ctx.send(reversed(text))

    @commands.command()
    async def phrase(self, ctx, *text: str):
        text = ' '.join(text)
        file = open('pips/phrases.txt', 'a', encoding='utf-8')
        file.write(text+'\n')
        file.close()

    async def picfinder(self, text, ch=None):
        if not ch:
            ch = adb.enpics
        async for m in self.bot.get_channel(ch).history():
            if m.content == text:
                if m.attachments:
                    return m.attachments[0].url

    @commands.command()
    async def bigleha(self, ctx):
        one = await self.picfinder('Lt1')
        two = await self.picfinder('Lt2')
        three = await self.picfinder('Lt3')
        four = await self.picfinder('Lt4')
        await ctx.send(one)
        await ctx.send(two)
        await ctx.send(three)
        await ctx.send(four)

    @commands.command()
    async def leha(self, ctx):
        one = await self.picfinder('Lt21')
        two = await self.picfinder('Lt22')
        three = await self.picfinder('Lt23')
        four = await self.picfinder('Lt24')
        await ctx.send(one)
        await ctx.send(two)
        await ctx.send(three)
        await ctx.send(four)

    @commands.command()
    async def trans(self, ctx, url, lang='ru'):
        if url == 'help':
            emb = discord.Embed(description=f'Доступные языки [здесь](https://github.com/lushan88a/google_trans_new/blob/main/constant.py)')
            await ctx.send(embed=emb)
            return
        mes_id = url.split('/')[-1]
        mes = await ctx.message.channel.fetch_message(mes_id)
        tr = translator.translate(mes.clean_content, lang_tgt=lang, pronounce=True)
        emb = discord.Embed(description=f'Перевод:\n{tr[0]}\nПроизношение:{tr[2]}\n\n[Оригинал]({mes.jump_url})')
        emb.set_footer(text=f"{mes.author.name}", icon_url=mes.author.avatar_url)
        await ctx.send(embed=emb)

    @commands.command()
    async def changemode(self, ctx, lang):
        self.transchan_mode = lang
        await ctx.send(f'Language is successfully set to **{lang}**')


def setup(bot):
    bot.add_cog(Funx(bot))

import pygame
from PIL import Image, ImageSequence
import random
import os
import re
from collections import defaultdict
import ast

from config import *
from proto import *
from ai import *


def findUnits(units, caster, center, radius, team='enemies', type='all'):
    return [i for i in units if (team == 'enemies' and i.team != caster.team or i.team == team) and circleColl(center.cort(), radius, i.hitbox())]


def findModifier(unit, name, caster=None, ability=None, castersummoner=None):
    for i in unit.modifiers:
        if i.name == name and (not caster or i.ability.caster == caster) and (not ability or i.ability == ability) and (not castersummoner or i.ability.caster.summoner == castersummoner):
            return i
    return False


class AttackAbility:
    def __init__(self, caster):
        self.caster = caster
        self.data = self.caster.data['attack']
        self.dmg = caster.dmg()
        self.type = 'attack'
        self.orbEffects = tuple((i for i in self.caster.abilities if i.type == 'orb')) if not get_bit(self.caster.status, 4) else ()
        self.level = caster.level
        self.units = caster.units
        self.ticks = 0
        self.maxhits = int(self.caster.multishot * self.caster.super)
        self.targets = defaultdict(int)  # for melee
        self.angles = meleeaccuracy(self.caster.accuracy, self.data["top_angle"], self.data['bottom_angle'])  # for melee
        self.projectiles = []  # for ranged
        self.done = False  # for ranged

    def onProjectileHit(self, projectile, unit):
        res = False
        for i in self.orbEffects:
            unitcoll = i.onProjectileHit(projectile, unit)
            if unitcoll:
                res = unitcoll
        if not self.caster.team == unit.team and not unit.dead:
            self.level.runa.stats.hit(self.caster, unit)
            unit.applyDamage(self.caster, self.dmg)
            res = True
        return res

    def onProjectileCollide(self, projectile, blockpos):
        for i in self.orbEffects:
            i.onProjectileCollide(projectile, blockpos)

    def onProjectileDestroy(self, projectile):
        for i in self.orbEffects:
            i.onProjectileDestroy(projectile)
        self.projectiles.remove(projectile)
        if not self.projectiles:
            self.destroy()

    def onOwnerDied(self):
        pass
            
    def tick(self):
        self.ticks += 1

    def destroy(self):
        self.caster.abilities.remove(self)

    def meleeAttack(self, curframe, aframes, anim_speed):
        self.level.runa.stats.shoot(self.caster)
        dvx = (mouse_active(self.level, self.caster)[0] - self.level.mp[0]) / self.level.tile_size - self.caster.cords.x + self.data["spawn_offset"][0]
        self.caster.flip = True if dvx < 0 else False
        ang = self.angles[0] - (self.angles[0] - self.angles[1]) * curframe / aframes
        if 'fromBottom' in self.data and self.data['fromBottom']:
            ang = self.angles[1] - ang
        ang = ang * math.pi / 180
        if self.caster.flip:
            ang = math.pi - ang
        spos = self.caster.cords
        epos = self.caster.cords + Vector(math.cos(ang) * self.data['radius'], -1 * math.sin(ang) * self.data['radius'])
        minx, maxx = (spos.x, epos.x) if spos.x < epos.x else (epos.x, spos.x)
        miny, maxy = (spos.y, epos.y) if spos.y < epos.y else (epos.y, spos.y)
        box = (minx, maxx, miny, maxy)
        # left right top bottom
        for unit in self.units:
            if self.targets[unit] < self.maxhits and unit.boxcollide(box):
                unitcoll = self.onProjectileHit(None, unit)
                if unitcoll:
                    self.targets[unit] += 1

    def rangedAttack(self, curframe, aframes, anim_speed):
        if self.done or curframe*anim_speed < self.data["attack_frame"]:
            return
        self.level.runa.stats.shoot(self.caster)
        spawn_point = Vector(self.caster.cords.x + self.data["spawn_offset"][0], self.caster.cords.y + self.data["spawn_offset"][1])
        pos = mouse_active(self.level, self.caster)
        ppos = Vector((pos[0] - self.level.mp[0]) / self.level.tile_size, (pos[1] - self.level.mp[1]) / self.level.tile_size)
        dv = ppos - spawn_point
        ang = dv.angle()
        self.caster.flip = True if dv.x < 0 else False
        if self.caster.flip:
            if ang < math.pi - self.data["top_angle"] * math.pi / 180:
                ang = math.pi - self.data["top_angle"] * math.pi / 180
            if ang > math.pi - self.data["bottom_angle"] * math.pi / 180:
                ang = math.pi - self.data["bottom_angle"] * math.pi / 180
        else:
            if ang > self.data["top_angle"] * math.pi / 180:
                ang = self.data["top_angle"] * math.pi / 180
            if ang < self.data["bottom_angle"] * math.pi / 180:
                ang = self.data["bottom_angle"] * math.pi / 180
        ang = accuracy(self.caster.accuracy, ang)
        for shot in range(self.maxhits):
            ang2 = ang
            if shot > 0:
                ang2 += (random.randint(0, 60) - 30) / 100 * math.pi
            nvector = Vector(math.cos(ang2) * self.data["speed"] / FPS, -1 * math.sin(ang2) * self.data["speed"] / FPS)
            p = Projectile(self.caster, self, spawn_point, nvector, self.data["projectile"], **self.data)
            self.level.projectiles.append(p)
            self.projectiles.append(p)
        self.done = True


class Ability:
    def __init__(self, caster):
        self.caster = caster
        self.type = 'None'
        self.name = 'None'
        self.level = caster.level
        self.units = caster.units
        self.ticks = 0
        self.intervalThink = 0
        self.ultimate = False
        self.breaked = False  # for passives

        self.strength = self.caster.strength
        self.radius = self.caster.radius
        self.aduration = self.caster.aduration
        self.manacost = self.caster.manacost
        self.castspeed = self.caster.castspeed
        self.reduction = self.caster.reduction
        self.super = self.caster.super

    def onIntervalThink(self):
        pass

    def onAbilityCastStart(self):
        pass

    def onAbilityCastInterrupted(self):
        pass

    def onAbilityStart(self):
        pass

    def onProjectileHit(self, projectile, unit):
        return False

    def onProjectileCollide(self, projectile, blockpos):
        pass

    def onProjectileDestroy(self, projectile):
        pass

    def onOwnerDied(self):
        pass

    def tick(self):
        if self.intervalThink and self.ticks % self.intervalThink == 0:
            self.onIntervalThink()
        self.ticks += 1

    def destroy(self):
        self.caster.abilities.remove(self)

    def ability_off(self):
        self.breaked = True

    def ability_on(self):
        self.breaked = False


class Modifier:
    def __init__(self, unit, ability, duration):
        self.owner = unit
        self.ability = ability
        self.duration = duration
        self.baseduration = self.duration
        self.ticks = 0
        self.name = 'None'
        self.provides = None

        self.hidden = False
        self.debuff = False
        self.purgable = True
        self.removeOnDeath = True
        self.stackable = 1 # 0 for non-stackable, 1 for fully stackable

        self.strength = self.ability.strength
        self.radius = self.ability.radius
        self.aduration = self.ability.aduration
        self.manacost = self.ability.manacost
        self.castspeed = self.ability.castspeed
        self.reduction = self.ability.reduction
        self.super = self.ability.super

    def tick(self):
        self.ticks += 1
        if self.duration and self.ticks >= self.duration*FPS:
            self.destroy()

    def destroy(self, r=True):
        self.owner.modifiers.remove(self)
        if r:
            self.owner.recount(self.provides)

    def onAbilityCastStart(self, ability):
        pass

    def onAbilityStart(self, ability):
        pass

    def addStack(self, c=1):
        pass

    def removeStack(self, c=1):
        pass


class Item:
    data = {i.split('.txt')[0]: ast.literal_eval(open(f'items\\{i}', 'r', encoding='utf-8').read()) for i in os.listdir('items') if i.endswith('.txt')}
    icons = {i.split('.png')[0]: pygame.image.load(f'items\\{i}') for i in os.listdir('items') if i.endswith('.png')}

    def __init__(self, name, level, count=1):
        self.name = name
        self.data = Item.data[name]
        self.provides = None
        self.count = count
        self.level = level
        self.icon = pygame.transform.scale(Item.icons[name], (int(level.tile_size*0.7), int(level.tile_size*0.7)))

    @classmethod
    def init(cls):
        for i in cls.icons.values():
            i.convert_alpha()

    def save(self):
        return self.name, self.count

    @classmethod
    def load(self, level, data):
        if isinstance(data, Item):
            return data
        return Item(data[0], level, data[1])

import pygame
from PIL import Image, ImageSequence
import random

from config import *


class Particles:
    """
        speed=1.0,
        frame_rate=60,
        count=0,
        spawn=0,
        lifetime=1.0
        start=0,
        scale=(256, 256),
        changexy = lambda(obj, x, y, i),
        rotate = 0.0,
        folder='textures\\particles'
        single=False
        pos='mouse_attach' or (0, 0)
        random_offset=(-1, 1, -1, 1)
        random_speed=(0.5, 2)
        random_scale=(0.5, 2)
        random_rotate=(0, 180)
        unit_binding=False
    """
    def __init__(self, name, **kwargs):
        self.speed = kwargs['speed'] if 'speed' in kwargs else 1.0
        if 'frame_rate' in kwargs:
            self.speed *= kwargs['frame_rate'] / FPS
        self.count = kwargs['count'] if 'count' in kwargs else 0
        self.spawn_count = kwargs['spawn'] if 'spawn' in kwargs else 1.0
        kwargs['lifetime'] = FPS if 'lifetime' not in kwargs else int(kwargs['lifetime'] * FPS)
        self.lifetime = kwargs['lifetime']

        if 'folder' not in kwargs:
            kwargs['folder'] = f'textures\\particles\\{name.split(".")[0]}'

        self.changexy = kwargs['changexy'] if 'changexy' in kwargs else None
        if isinstance(self.changexy, str):
            self.changexy = eval(self.changexy)
        self.rotate = kwargs['rotate'] if 'rotate' in kwargs else None
        self.kwargs = kwargs
        self.particles = []
        self.unit_binding = kwargs['unit_binding'] if 'unit_binding' in kwargs else False

    def spawn(self, *args, **kwargs):
        spawn = int(self.spawn_count)
        spawn = spawn + 1 if self.spawn_count % 1 and chance((self.spawn_count % 1) * 1000, 1000) else spawn
        offset = 0, 0
        for i in range(spawn):
            pos = args[0]
            if 'pos' in self.kwargs:
                if self.kwargs['pos'] == 'mouse_attach':
                    pos = kwargs['pos']
                else:
                    pos = self.kwargs['pos']
            if 'random_offset' in self.kwargs:
                offset = self.kwargs['random_offset']
                offset = random.randint(offset[0]*100, offset[1]*100)/100, random.randint(offset[2]*100, offset[3]*100)/100
                pos = (pos[0]+offset[0], pos[1]+offset[1])

            speed = random.randint(self.kwargs['random_speed'][0] * 1000, self.kwargs['random_speed'][1] * 1000) * self.speed / 1000 if 'random_speed' in self.kwargs else self.speed
            folder = self.kwargs['folder'] if 'single' in self.kwargs else self.kwargs['folder'] + '\\' + random.choice(os.listdir(self.kwargs["folder"]))
            cycle = os.listdir(folder)
            frames = [pygame.image.load(f'{folder}\\{frame}').convert_alpha() for frame in cycle]
            frames = longsplit(frames, self.kwargs['lifetime'])

            if 'start' in self.kwargs:
                frames = frames[self.kwargs['start']:] + frames[:self.kwargs['start']]

            if 'scale' in self.kwargs:
                if self.kwargs['scale'][0] == 0:
                    frames = [pygame.transform.scale(i, (int(i.get_width() / i.get_height() * self.kwargs['scale'][1]), self.kwargs['scale'][1])) for i in frames]
                elif self.kwargs['scale'][1] == 0:
                    frames = [pygame.transform.scale(i, (self.kwargs['scale'][0], int(i.get_height() / i.get_width() * self.kwargs['scale'][0]))) for i in frames]
                else:
                    frames = [pygame.transform.scale(i, self.kwargs['scale']) for i in frames]

            scale = 1
            if 'random_scale' in self.kwargs:
                scale = random.randint(self.kwargs['random_scale'][0] * 100, self.kwargs['random_scale'][1] * 100) / 100
            if 'level_scale' in kwargs:
                scale *= kwargs['level_scale']
            if scale != 1:
                frames = [pygame.transform.scale(i, (int(i.get_width() * scale), int(i.get_height() * scale))) for i in frames]

            rotate = 0
            if 'random_rotate' in self.kwargs:
                rotate = random.randint(self.kwargs['random_rotate'][0] * 100, self.kwargs['random_rotate'][1] * 100) / 100
                frames = [pygame.transform.rotate(i, rotate) for i in frames]
            frame_idx = 0
            pos_idx = 0
            speed_repeats = 0
            particle = (frames, pos, scale, rotate, speed, frame_idx, pos_idx, speed_repeats, offset)
            self.particles.append(particle)

    def act(self, *args, **kwargs):
        newpos = args[0]
        trash = []
        res = []

        for i,p in enumerate(self.particles):
            frames, pos, scale, rotate, speed, frame_idx, pos_idx, speed_repeats, offset = p
            if pos_idx >= self.lifetime:
                trash.append(p)
                continue
            if frame_idx >= len(frames):
                while frame_idx >= len(frames):
                    frame_idx -= len(frames)

            frame = kwargs['img'] if 'img' in kwargs else frames[frame_idx]

            if self.unit_binding:
                pos = newpos[0]+offset[0], newpos[1]+offset[1]
            x, y = pos
            if self.changexy:
                pos = self.changexy(frame, x, y, pos_idx)

            res.append([frame, pos])

            if speed == 1.0:
                frame_idx += 1
            elif speed > 1.0:
                frame_idx += int(speed)
                mod = speed % 1
                if mod and chance(mod*100):
                    frame_idx += 1
            else:
                subspeed = 1 / speed
                subspeedmod = subspeed % 1
                speed_repeats += 1
                if speed_repeats >= subspeed:
                    speed_repeats = 0
                    frame_idx += 1
                elif speed_repeats == int(subspeed) and chance(subspeedmod*100):
                    speed_repeats = 0
                    frame_idx += 1
            pos_idx += 1
            self.particles[i] = (frames, pos, scale, rotate, speed, frame_idx, pos_idx, speed_repeats, offset)

        for i in trash:
            del self.particles[self.particles.index(i)]
        return res


class Button:
    def __init__(self, anim, **kwargs):
        self.name = anim.asset
        self.prs_name = kwargs['prs_name'] if 'prs_name' in kwargs else anim.asset
        self.folder = kwargs['folder'] if 'folder' in kwargs else f'textures\\animated_assets'
        filename = f'{self.folder}\\{self.prs_name}'
        self.img = pygame.image.load(filename).convert_alpha()
        pil_img = Image.open(filename).convert('RGBA')
        self.pixels = pil_img.load()
        self.size = pil_img.size
        self.trigger = kwargs['trigger'] if 'trigger' in kwargs else 'mb1'
        self.particles = kwargs['particles'] if 'particles' in kwargs else []
        self.kwargs = kwargs

    def act(self, *args, **kwargs):
        frame, pos, pos_idx = args
        mpos = kwargs['pos']
        actions = {}
        if 0 < mpos[0] - pos[0] < self.size[0] and 0 < mpos[1] - pos[1] < self.size[1]:
            if not self.pixels[mpos[0] - pos[0], mpos[1] - pos[1]] == (0, 0, 0, 0):
                frame = self.img
                self.press(actions, **kwargs)
                if self.particles:
                    for p in self.particles:
                        p.spawn(*[pos], **kwargs)
        if self.particles:
            actions['blit'] = []
            for p in self.particles:
                actions['blit'] += p.act(*[pos], **kwargs)
        return frame, actions

    def press(self, res, **kw2):
        if self.trigger == 'mb1' and kw2['pressed'][0]:
            if 'change_mode' in self.kwargs:
                option = self.kwargs['changelevel'] if 'changelevel' in self.kwargs else 0
                res['change_mode'] = {'mode': self.kwargs['change_mode'], 'changelevel': option}


class Animation:
    """
    duration=0,
    speed=1.0, аnimation speed
    frame_rate=60, animation speed via framerate
    start=0,
    scale=(256, 256),
    changexy = lambda(obj, x, y, i),
    rotate = 0.0,
    folder='textures\\animated_assets'
    """
    def __init__(self, asset, pos, **kwargs):
        self.speed = kwargs['speed'] if 'speed' in kwargs else 1.0
        if 'frame_rate' in kwargs:
            self.speed *= kwargs['frame_rate'] / FPS
        self.mod = self.speed % 1
        self.subspeed = 1/self.speed
        self.subspeedmod = self.subspeed % 1
        self.speed_repeats = 0
        self.asset = asset

        if 'folder' not in kwargs:
            kwargs['folder'] = f'textures\\animated_assets\\{asset.split(".")[0]}'
        self.cycle = os.listdir(f'{kwargs["folder"]}') if not 'single' in kwargs else [asset]

        frames = int(FPS*kwargs['duration']) if 'duration' in kwargs else len(self.cycle)

        self.frames = [pygame.image.load(f'{kwargs["folder"]}\\{frame}').convert_alpha() for frame in self.cycle]
        if frames < 0:
            self.inf = True
        else:
            self.inf = False
            self.frames = longsplit(self.frames, frames)

        if 'start' in kwargs:
            self.frames = self.frames[kwargs['start']:] + self.frames[:kwargs['start']]

        if 'scale' in kwargs:
            if kwargs['scale'][0] == 0:
                self.frames = [pygame.transform.scale(i, (int(i.get_width() / i.get_height() * kwargs['scale'][1]), kwargs['scale'][1])) for i in self.frames]
            elif kwargs['scale'][1] == 0:
                self.frames = [pygame.transform.scale(i, (kwargs['scale'][0], int(i.get_height() / i.get_width() * kwargs['scale'][0]))) for i in self.frames]
            else:
                self.frames = [pygame.transform.scale(i, kwargs['scale']) for i in self.frames]

        self.frame_idx = 0
        self.pos_idx = 0
        self.pos = pos
        self.changexy = kwargs['changexy'] if 'changexy' in kwargs else None
        self.rotate = kwargs['rotate'] if 'rotate' in kwargs else None
        self.particles = kwargs['particles'] if 'particles' in kwargs else []
        self.button = Button(self, **kwargs['button']) if 'button' in kwargs else None

    def animate(self, sc, **kwargs):
        if self.frame_idx >= len(self.frames):
            if self.inf:
                while self.frame_idx >= len(self.frames):
                    self.frame_idx -= len(self.frames)
            else:
                return False

        frame = kwargs['img'] if 'img' in kwargs else self.frames[self.frame_idx]
        frame = pygame.transform.rotate(frame, -1 * self.rotate * self.pos_idx) if self.rotate else frame

        if self.changexy:
            x, y = self.pos
            self.pos = self.changexy(frame, x, y, self.pos_idx)
        actions = {}
        if self.button:
            frame, actions = self.button.act(*[frame, self.pos, self.pos_idx], **kwargs)

        sc.blit(frame, self.pos)

        if self.particles:
            for p in self.particles:
                p.spawn(*[self.pos], **kwargs)
            if 'blit' not in actions:
                actions['blit'] = []
            for p in self.particles:
                actions['blit'] += p.act(*[self.pos], **kwargs)

        if 'blit' in actions:
            for x, p in actions['blit']:
                sc.blit(x, p)

        # speed calculation
        if self.speed == 1.0:
            self.frame_idx += 1
        elif self.speed > 1.0:
            self.frame_idx += int(self.speed)
            if self.mod and chance(self.mod*100):
                self.frame_idx += 1
        else:
            self.speed_repeats += 1
            if self.speed_repeats >= self.subspeed:
                self.speed_repeats = 0
                self.frame_idx += 1
            elif self.speed_repeats == int(self.subspeed) and chance(self.subspeedmod*100):
                self.speed_repeats = 0
                self.frame_idx += 1
        self.pos_idx += 1

        return actions

from config import *


class AI:
    def __init__(self, unit):
        self.unit = unit
        self.act_radius = 12
        self.ranged_attack_radius = 7
        self.target = None
        self.mode = 'idle'

    def think(self):
        enemies = [i for i in self.unit.level.visions[self.unit.team] if self.unit.team != i.team and not i.dead]
        minrange = 0
        minrangeunit = None
        for i in enemies:
            ur = self.unit.unitrange(i)
            if (not minrangeunit or ur < minrange) and ur < self.act_radius:
                minrange = ur
                minrangeunit = i
        if minrangeunit:
            if self.unit.melee:
                attack_radius = self.unit.data['attack']['radius']
            else:
                attack_radius = self.ranged_attack_radius
            if minrange < attack_radius:
                self.target = minrangeunit
                self.mode = 'attack'
            else:
                self.target = minrangeunit
                self.mode = 'move'
        if self.target and self.target.dead:
            self.target = None
            self.mode = 'idle'

    def act(self):
        if self.mode == 'move':
            if self.target.cords.x < self.unit.cords.x:
                if not self.unit.level.find_left_space(self.unit):
                    self.unit.jump()
                self.unit.moveleft()
            else:
                if not self.unit.level.find_right_space(self.unit):
                    self.unit.jump()
                self.unit.moveright()
        elif self.mode == 'attack':
            self.unit.attack()

    def choosepos(self):
        if self.target:
            return self.target.cords.x*self.unit.level.tile_size+self.unit.level.mp[0], self.target.cords.y*self.unit.level.tile_size+self.unit.level.mp[1]
        return pygame.mouse.get_pos()


def mouse_active(level, unit):
    if level.selected_unit is unit:
        return pygame.mouse.get_pos()
    if unit.mousepos:
        return unit.mousepos[0]+level.mp[0], unit.mousepos[1]+level.mp[1]
    return unit.ai.choosepos()

import pygame
import os
import sqlite3
import ast

from config import *
from level import *

name = 'cast4'
object = 'Zalgo'
folder = 'units\\heroes\\Zalgo'

pygame.init()
sc = pygame.display.set_mode(WINDOW, pygame.FULLSCREEN)
clock = pygame.time.Clock()

font = pygame.font.SysFont('calibri', 30)
font2 = pygame.font.SysFont('calibri', 36)
font3 = pygame.font.SysFont('calibri', 22)
font4 = pygame.font.SysFont('calibri', 12)
text_parts = font2.render(f'In Folder', True, (0, 0, 0))
text_curparts = font2.render(f'Parts', True, (0, 0, 0))
text_poses = font2.render(f'Poses', True, (0, 0, 0))
text_bones = font.render('Bones [F]', True, (0, 0, 0))
text_tbones = font.render('Toggle bones [G]', True, (0, 0, 0))
text_save = font.render('Saved', True, (0, 0, 0))
text_point_move_bind = font.render('Point Move Binding [H]', True, (0, 0, 0))
text_save_frames = 0
TILE_SCALE = 7
TILE_SIZE_SCALED = TILE_SIZE * TILE_SCALE
X_OFFSET, Y_OFFSET = 400, 250
AMAP_SIZE_X, AMAP_SIZE_Y = 3, 2
SCALING_POINT = (X_OFFSET + TILE_SIZE_SCALED * AMAP_SIZE_X // 2, Y_OFFSET + TILE_SIZE_SCALED * AMAP_SIZE_Y)
X_OFFSET_MINI, Y_OFFSET_MINI = 1590, 800
SCALING_POINT_MINI = (X_OFFSET_MINI + TILE_SIZE * AMAP_SIZE_X // 2, Y_OFFSET_MINI + TILE_SIZE * AMAP_SIZE_Y)

parts = [i for i in os.listdir(folder) if i.endswith('.png')]
cur_ic = pygame.image.load(f'textures\\GUI\\firesm.png').convert_alpha()
sec_ic = pygame.image.load(f'textures\\GUI\\watersm.png').convert_alpha()
plus_ic = pygame.image.load(f'textures\\GUI\\plus.png').convert_alpha()
play_ic = pygame.image.load(f'textures\\GUI\\aplay.png').convert_alpha()
playon_ic = pygame.image.load(f'textures\\GUI\\aplayon.png').convert_alpha()
bonetool = False
bonesmode = True
boneline = None
point_move_bind = False
cur_idx = -1
sec_idx = -1
curparts = []
bones = []
points = {}
obj_lock = None
point_lock = None
list_lock = None
pose_lock = None
frame_lock = None
cur_pose = -1
log = []
frames = {}
poses = []
temp_pose = {}
cur_frame = -1
play = -1


def corrang(ang):
    while ang > 360:
        ang -= 360
    while ang < -360:
        ang += 360
    if ang > 180:
        ang = -(360-ang)
    if ang < -180:
        ang = 360+ang
    return ang


def corrangpi(ang):
    while ang > 2 * math.pi:
        ang -= 2 * math.pi
    while ang < -2 * math.pi:
        ang += 2 * math.pi
    if ang > math.pi:
        ang = -(2 * math.pi-ang)
    if ang < -math.pi:
        ang = 2 * math.pi+ang
    return ang


class Bone:
    def __init__(self, pp, pd, ang=0):
        self.pp = pp
        self.pd = pd
        self.length = math.sqrt((points[pp].pos[0] - points[pd].pos[0]) ** 2 + (points[pp].pos[1] - points[pd].pos[1]) ** 2)
        self.ang = ang


class Point:
    def __init__(self, pos, id, obj, parent=None, daughters=None):
        self.id = id
        self.obj = obj
        self.parent = parent
        self.daughters = daughters if daughters else []
        self.pos = pos
        self.lastpos = pos

    def move(self, daughterid=0, checkparent=True, ps=False, pi=False):
        if self.parent and checkparent:
            if points[self.parent].parent or ps or pi:
                self.push(self.parent, ps)
                points[self.parent].move(daughterid=self.id, ps=ps)
            else:
                self.pull(self.parent, ps)
                points[self.parent].move(checkparent=False, ps=ps)
        for i in self.daughters:
            if not i == daughterid:
                self.push(i, ps)
                points[i].move(checkparent=False, ps=ps)
        self.lastpos = self.pos

    def push(self, p, ps):
        l = 0
        for i in bones:
            if i.pp == self.id and i.pd == p or i.pp == p and i.pd == self.id:
                l = i.length
        if l == 0:
            return
        newlen = math.sqrt((self.pos[0] - points[p].pos[0]) ** 2 + (self.pos[1] - points[p].pos[1]) ** 2)
        diff = newlen - l
        newv = ((self.lastpos[0] - points[p].pos[0]) / newlen, (self.lastpos[1] - points[p].pos[1]) / newlen)
        lp = points[p].pos
        points[p].pos = (points[p].pos[0] + diff * newv[0], points[p].pos[1] + diff * newv[1])
        if ps:
            return
        ang, ang2 = 0, 0
        for i in range(len(curparts)):
            if curparts[i][6] == points[p].obj:
                for b in bones:
                    if b.pp == p and b.pd == self.id:
                        w, h = points[b.pd].pos[0] - points[b.pp].pos[0], points[b.pp].pos[1] - points[b.pd].pos[1]
                        ang = math.asin(h / math.sqrt(h ** 2 + w ** 2))
                        ang = math.pi - ang if w < 0 else ang

                        ang2 = curparts[i][4]
                        curparts[i][4] = ang / math.pi * 180 - b.ang
                        ang2 = curparts[i][4] - ang2

                        for pp in curparts[i][7]:
                            curparts[i][7][pp][1] += ang2 * math.pi / 180
                        rad, ang3 = curparts[i][7][p]
                        curparts[i][2] = (int(points[p].pos[0] + rad * math.cos(ang3)), int(points[p].pos[1] - rad * math.sin(ang3)))
                    elif b.pp == self.id and b.pd == p:
                        rad, ang3 = curparts[i][7][p]
                        curparts[i][2] = (int(points[p].pos[0] + rad * math.cos(ang3)), int(points[p].pos[1] - rad * math.sin(ang3)))
        for i in range(len(curparts)):
            if curparts[i][6] == self.obj:
                rad, ang3 = curparts[i][7][self.id]
                curparts[i][2] = (int(self.pos[0] + rad * math.cos(ang3 + ang2 - ang)), int(self.pos[1] - rad * math.sin(ang3 + ang2 - ang)))

    def pull(self, p, ps):
        self.pos = self.lastpos
        l = 0
        for i in bones:
            if i.pp == self.id and i.pd == p or i.pp == p and i.pd == self.id:
                l = i.length
        if l == 0:
            return
        newlen = math.sqrt((self.pos[0] - points[p].pos[0]) ** 2 + (self.pos[1] - points[p].pos[1]) ** 2)
        diff = newlen - l
        newv = ((points[p].pos[0] - self.lastpos[0]) / newlen, (points[p].pos[1] - self.lastpos[1]) / newlen)
        lp = self.pos
        self.pos = (self.pos[0] + diff * newv[0], self.pos[1] + diff * newv[1])
        if ps:
            return
        ang, ang2 = 0, 0
        for i in range(len(curparts)):
            if curparts[i][6] == self.obj:
                for b in bones:
                    if b.pp == self.id and b.pd == p:
                        w, h = points[b.pd].pos[0] - points[b.pp].pos[0], points[b.pp].pos[1] - points[b.pd].pos[1]
                        ang = math.asin(h / math.sqrt(h ** 2 + w ** 2))
                        ang = math.pi - ang if w < 0 else ang

                        ang2 = curparts[i][4]
                        curparts[i][4] = ang / math.pi * 180 - b.ang
                        ang2 = curparts[i][4] - ang2

                        for pp in curparts[i][7]:
                            curparts[i][7][pp][1] += ang2 * math.pi / 180
                        rad, ang3 = curparts[i][7][self.id]
                        curparts[i][2] = (int(self.pos[0] + rad * math.cos(ang3)), int(self.pos[1] - rad * math.sin(ang3)))
                    elif b.pp == p and b.pd == self.id:
                        rad, ang3 = curparts[i][7][self.id]
                        curparts[i][2] = (int(self.pos[0] + rad * math.cos(ang3)), int(self.pos[1] - rad * math.sin(ang3)))


def magnetify(pos):
    for j in points:
        i = points[j].pos
        if abs(i[0]-pos[0]) <= 10 and abs(i[1]-pos[1]) <= 10:
            return (i[0], i[1])
    return False


def unscale(p, forshow=False):
    w, h = p[0] - SCALING_POINT[0], SCALING_POINT[1] - p[1]
    rad = math.sqrt(w ** 2 + h ** 2)
    ang = math.asin(h / rad)
    ang = math.pi - ang if w < 0 else ang
    rad /= TILE_SCALE
    spos = (int(SCALING_POINT_MINI[0] + rad * math.cos(ang)), int(SCALING_POINT_MINI[1] - rad * math.sin(ang)))
    if forshow:
        return spos
    else:
        return (spos[0] - SCALING_POINT_MINI[0], spos[1] - SCALING_POINT_MINI[1])


def save(sc):
    global text_save
    global text_save_frames
    try:
        save = {'frames': frames, 'poses': []}
        if cur_pose > -1:
            poses[cur_pose] = {'name': poses[cur_pose]['name'], 'parts': mkcopy(curparts), 'points': mkcopy(points), 'bones': mkcopy(bones)}
        for pose in poses:
            s_points = {p:(pose['points'][p].pos, pose['points'][p].id, pose['points'][p].obj, pose['points'][p].parent, pose['points'][p].daughters) for p in pose['points']}
            s_bones = [(b.pp, b.pd, b.ang) for b in pose['bones']]
            s_parts = [(p[0], p[2], p[3], p[4], p[6], p[7]) for p in pose['parts']]
            save['poses'].append({'name': pose['name'], 'parts': s_parts, 'points': s_points, 'bones': s_bones})
        fone, ftwo = 0, 0
        for i in range(240):
            if i in frames:
                fone = i
                break
        for i in range(240):
            if i in frames and not i == fone:
                ftwo = i
        num = ftwo-fone+1 if ftwo else 0
        save['len'] = num

        file = open(folder + '\\' + name + '.txt', 'w', encoding='utf-8')
        file.write(str(save))
        text_save = font.render(f'Saved {len(save["poses"])} poses and {save["len"]} frames', True, (0, 0, 0))
        text_save_frames = 180
    except Exception as e:
        text_save = font.render(str(e), True, (0, 0, 0))
        text_save_frames = 180
        print(e)


def mkcopy(iter):
    if type(iter) == list:
        return [mkcopy(i) for i in iter]
    if type(iter) == dict:
        return {i:mkcopy(iter[i]) for i in iter}
    if type(iter) == tuple:
        return tuple([mkcopy(i) for i in iter])
    if type(iter) == Point:
        return Point(iter.pos, iter.id, iter.obj, iter.parent, iter.daughters)
    if type(iter) == Bone:
        return Bone(iter.pp, iter.pd, iter.ang)
    return iter


def load(inter=None):
    global frames
    global curparts
    global bones
    global points
    global poses
    if inter:
        data, parts = inter
        poses = []
        frames = data['frames']
        for pi,i in enumerate(data['poses']):
            curparts = []
            bones = []
            points = {}
            for p in i['points']:
                points[p] = Point(i['points'][p][0], i['points'][p][1], i['points'][p][2], i['points'][p][3], i['points'][p][4])
            for b in i['bones']:
                bones.append(Bone(b[0], b[1], b[2]))
            for p in i['parts']:
                curparts.append([p[0], parts[p[0]], p[1], p[2], p[3], None, p[4], p[5]])
            pose = {'name': i['name'], 'parts': curparts, 'points': points, 'bones': bones}
            data['poses'][pi] = pose
            poses.append(pose)
    elif os.path.exists(folder + '\\' + name + '.txt'):
        data = ast.literal_eval(open(folder + '\\' + name + '.txt', 'r', encoding='utf-8').read())
        frames = data['frames']
        for i in data['poses']:
            curparts = []
            bones = []
            points = {}
            for p in i['points']:
                points[p] = Point(i['points'][p][0], i['points'][p][1], i['points'][p][2], i['points'][p][3], i['points'][p][4])
            for b in i['bones']:
                bones.append(Bone(b[0], b[1], b[2]))
            for p in i['parts']:
                curparts.append([p[0], pygame.image.load(f'{folder}\\{p[0]}').convert_alpha(), p[1], p[2], p[3], Image.open(f'{folder}\\{p[0]}').convert('RGBA').load(), p[4], p[5]])
            poses.append({'name': i['name'], 'parts': curparts, 'points': points, 'bones': bones})


def posesplit(one, two, kef):
    for i, p in enumerate(curparts):
        for pp in poses[frames[two]]['parts']:
            if pp[6] == p[6]:
                if not pp[3] == p[3]:
                    diff = (pp[3] - p[3]) * kef
                    old = p[3]
                    curparts[i][3] = p[3] + diff
                    for po in curparts[i][7]:
                        curparts[i][7][po][0] = curparts[i][7][po][0] / old * curparts[i][3]

    for p in points:
        if p in poses[frames[two]]['points'] and not points[p].pos == poses[frames[two]]['points'][p].pos:
            pos1 = points[p].pos
            pos2 = poses[frames[two]]['points'][p].pos
            diff = ((pos2[0] - pos1[0]) * kef, (pos2[1] - pos1[1]) * kef)
            points[p].pos = (points[p].pos[0] + diff[0], points[p].pos[1] + diff[1])

    for p in points:
        points[p].move(ps=True)

    for i, p in enumerate(curparts):
        for pp in poses[frames[two]]['parts']:
            if not pp[7]:
                continue
            if pp[6] == p[6]:
                pFlag = False
                for pt in p[7]:
                    for b in bones:
                        if b.pp == pt and b.pd in poses[frames[one]]['points']:
                            w, h = poses[frames[one]]['points'][b.pd].pos[0] - poses[frames[one]]['points'][b.pp].pos[0], poses[frames[one]]['points'][b.pp].pos[1] - poses[frames[one]]['points'][b.pd].pos[1]
                            ang = math.asin(h / math.sqrt(w ** 2 + h ** 2))
                            ang = math.pi - ang if w < 0 else ang

                            w, h = points[b.pd].pos[0] - points[b.pp].pos[0], points[b.pp].pos[1] - points[b.pd].pos[1]
                            ang2 = math.asin(h / math.sqrt(w ** 2 + h ** 2))
                            ang2 = math.pi - ang2 if w < 0 else ang2

                            curparts[i][7][pt][1] += ang2 - ang
                            pFlag = True
                            break
                    if pFlag:
                        break
                if not pFlag:
                    if pt in pp[7]:
                        if not p[7][pt][1] == pp[7][pt][1]:
                            ang = corrangpi(pp[7][pt][1] - p[7][pt][1])
                            diff = ang * kef
                            curparts[i][7][pt][1] = p[7][pt][1] + diff

    for i, p in enumerate(curparts):
        for pt in p[7]:
            pFlag = False
            for b in bones:
                if b.pp == pt:
                    w, h = points[b.pd].pos[0] - points[b.pp].pos[0], points[b.pp].pos[1] - points[b.pd].pos[1]
                    ang = math.asin(h / math.sqrt(h ** 2 + w ** 2))
                    ang = math.pi - ang if w < 0 else ang
                    ang = ang / math.pi * 180 - b.ang
                    curparts[i][4] = ang
                    pFlag = True
            if pFlag is False:
                for pp in poses[frames[two]]['parts']:
                    if pp[6] == p[6]:
                        ang = corrang(pp[4]-p[4])
                        diff = ang * kef
                        curparts[i][4] = p[4] + diff

    for i, p in enumerate(curparts):
        for pp in poses[frames[two]]['parts']:
            if pp[6] == p[6]:
                pFlag = False
                for po in curparts[i][7]:
                    for b in bones:
                        if b.pd == po:
                            rad, ang = curparts[i][7][po]
                            curparts[i][2] = (int(points[po].pos[0] + rad * math.cos(ang)), int(points[po].pos[1] - rad * math.sin(ang)))
                            pFlag = po
                if pFlag is False:
                    if not curparts[i][7]:
                        diff = ((pp[2][0] - p[2][0]) * kef, (pp[2][1] - p[2][1]) * kef)
                        curparts[i][2] = (p[2][0] + diff[0], p[2][1] + diff[0])
                    else:
                        for po in curparts[i][7]:
                            rad, ang = curparts[i][7][po]
                            curparts[i][2] = (int(points[po].pos[0] + rad * math.cos(ang)), int(points[po].pos[1] - rad * math.sin(ang)))
                            break
    return curparts, points, bones


def create_frames():
    global curparts
    global bones
    global points
    res = {}
    fone, ftwo = 0, 0
    for i in range(240):
        if i in frames:
            fone = i
            break
    for i in range(240):
        if i in frames and not i == fone:
            ftwo = i
    if not ftwo:
        return res
    for play in range(fone, ftwo + 1):
        if play in frames:
            curparts = mkcopy(poses[frames[play]]['parts'])
            points = mkcopy(poses[frames[play]]['points'])
            bones = mkcopy(poses[frames[play]]['bones'])
        else:
            one, two = None, None
            for i in range(240):
                if i < play:
                    if i in frames:
                        one = i
            for i in range(240):
                if i > play:
                    if i in frames:
                        two = i
                        break
            if two is None:
                for i in range(240):
                    if i in frames:
                        one = i
                        break
                curparts = mkcopy(poses[frames[one]]['parts'])
                points = mkcopy(poses[frames[one]]['points'])
                bones = mkcopy(poses[frames[one]]['bones'])
            else:
                curparts = mkcopy(poses[frames[one]]['parts'])
                points = mkcopy(poses[frames[one]]['points'])
                bones = mkcopy(poses[frames[one]]['bones'])
                kef = (play - one) / (two - one)

                posesplit(one, two, kef)
        res[play] = [(p[0], p[2], p[3], p[4]) for p in curparts]
    return res


if __name__ == "__main__":
    load()
    while True:
        sc.fill(pygame.Color('white'))
        pos = pygame.mouse.get_pos()
        pressed = pygame.mouse.get_pressed()
        magnet = magnetify(pos)

        for event in pygame.event.get():
            if event.type == pygame.QUIT:
                exit()
            if event.type == pygame.KEYDOWN:
                if event.key == pygame.K_f:
                    bonetool = False if bonetool else True
                if event.key == pygame.K_g:
                    bonesmode = False if bonesmode else True
                if event.key == pygame.K_u:
                    parts = [i for i in os.listdir(folder) if i.endswith('.png')]
                if event.key == pygame.K_s:
                    save(sc)
                if event.key == pygame.K_h:
                    point_move_bind = False if point_move_bind else True

                if event.key == pygame.K_z:
                    dl = log[-1]
                    if dl[0] == 'newpart':
                        for i, p in enumerate(curparts):
                            if curparts[i][6] == dl[1]:
                                delbones = []
                                delp = []
                                del curparts[i]
                                for j in points:
                                    if points[j].obj == dl[1]:
                                        for bdx, b in enumerate(bones):
                                            if b.pp == j or b.pd == j:
                                                delbones.append(bdx)
                                        delp.append(j)
                                for j in delp:
                                    for pp in points:
                                        if j in pp.daughters:
                                            del pp.daughters[pp.daughters.index(j)]
                                        if j == pp.parent:
                                            pp.parent = None
                                    del points[j]
                                for j in delbones:
                                    del bones[j]
                                if i == cur_idx:
                                    cur_idx = -1
                                if i == sec_idx:
                                    sec_idx = -1
                                break
                    elif dl[0] == 'partdrag':
                        new_cur_idx, new_sec_idx = cur_idx, sec_idx
                        llpart = curparts[dl[2]]
                        if dl[2] == cur_idx:
                            new_cur_idx = dl[1]
                        if dl[2] == sec_idx:
                            new_sec_idx = dl[1]
                        if dl[1] < dl[2]:
                            for j in range(dl[1], dl[2])[::-1]:
                                curparts[j + 1] = curparts[j]
                                if j == cur_idx:
                                    new_cur_idx = j + 1
                                if j == sec_idx:
                                    new_sec_idx = j + 1
                        else:
                            for j in range(dl[2], dl[1]):
                                curparts[j] = curparts[j + 1]
                                if j + 1 == cur_idx:
                                    new_cur_idx = j
                                if j + 1 == sec_idx:
                                    new_sec_idx = j
                        curparts[dl[1]] = llpart
                        cur_idx, sec_idx = new_cur_idx, new_sec_idx
                    elif dl[0] == 'bonecr':
                        for bdx, b in enumerate(bones):
                            if b.pp == dl[1][0] and b.pd == dl[1][1]:
                                del bones[bdx]
                                break
                        for p in dl[1]:
                            delp = False
                            for b in bones:
                                if b.pp == p or b.pd == p:
                                    delp = True
                                    break
                            if not delp:
                                for i in range(len(curparts)):
                                    if curparts[i][6] == points[p].obj:
                                        del curparts[i][7][p]
                                        break
                                del points[p]
                    elif dl[0] == 'motion':
                        for pr in dl[1]['parts']:
                            dld = dl[1]['parts'][pr]
                            for p in range(len(curparts)):
                                if curparts[p][6] == pr:
                                    curparts[p][4] = dld[4]
                                    curparts[p][2] = dld[2]
                                    curparts[p][3] = dld[3]
                                    curparts[p][7] = dld[7]
                        for p in dl[1]['points']:
                            points[p].pos = dl[1]['points'][p]
                            points[p].move()
                    elif dl[0] == 'newpos':
                        for i in poses:
                            if i['name'] == dl[1]:
                                for j in range(240):
                                    if j in frames:
                                        if frames[j] == dl[1]:
                                            del frames[j]
                                del poses[poses.index(i)]
                                break
                    elif dl[0] == 'setpos':
                        if dl[2] == None:
                            del frames[dl[1]]
                        else:
                            frames[dl[1]] = dl[2]
                    del log[-1]
                if event.key == pygame.K_ESCAPE:
                    exit()
            if event.type == pygame.MOUSEMOTION:
                if not point_lock == None:
                    points[point_lock].pos = (points[point_lock].pos[0] + event.rel[0], points[point_lock].pos[1] + event.rel[1])
                    for b in bones:
                        if b.pd == point_lock:
                            b.length = math.sqrt((points[b.pp].pos[0] - points[b.pd].pos[0]) ** 2 + (points[b.pp].pos[1] - points[b.pd].pos[1]) ** 2)
                    for i,p in enumerate(curparts):
                        if p[6] == points[point_lock].obj:
                            for pp in p[7]:
                                if pp == point_lock:
                                    w, h = curparts[i][2][0] - points[point_lock].pos[0], points[point_lock].pos[1] - curparts[i][2][1]
                                    rad = math.sqrt(h ** 2 + w ** 2)
                                    ang = math.asin(h / rad)
                                    ang = math.pi - ang if w < 0 else ang
                                    curparts[i][7][point_lock] = [rad, ang]
                            break
                    if point_move_bind:
                        points[point_lock].move()
                    else:
                        points[point_lock].move(pi=True)
                elif not obj_lock == None:
                    if event.buttons[0]:
                        opos = curparts[obj_lock][2]
                        pFlag = False
                        logdict = {'parts': {}, 'points': {}}
                        logdict['parts'][curparts[obj_lock][6]] = {4: curparts[obj_lock][4], 2: curparts[obj_lock][2], 7: curparts[obj_lock][7], 3: curparts[obj_lock][3]}
                        for p in curparts[obj_lock][7]:
                            for b in bones:
                                if b.pd == p:
                                    rad, ang = curparts[obj_lock][7][p]

                                    w, h = pos[0] - points[p].pos[0], points[p].pos[1] - pos[1]
                                    rad2 = math.sqrt(w ** 2 + h ** 2)
                                    ang2 = math.asin(h / rad2)
                                    ang2 = math.pi - ang2 if w < 0 else ang2

                                    curparts[obj_lock][4] += (ang2 - ang)*180/math.pi
                                    curparts[obj_lock][7][p][1] = ang2
                                    pos1 = (int(points[p].pos[0] + rad * math.cos(ang2)), int(points[p].pos[1] - rad * math.sin(ang2)))
                                    if rad*2 < rad2:
                                        curparts[obj_lock][2] = pos1
                                    else:
                                        pos2 = (int(points[p].pos[0] + rad2 * math.cos(ang2)), int(points[p].pos[1] - rad2 * math.sin(ang2)))
                                        offset = (pos2[0] - pos1[0], pos2[1] - pos1[1])
                                        curparts[obj_lock][2] = pos1
                                        logdict['points'][p] = points[p].pos
                                        points[p].pos = (points[p].pos[0] + offset[0], points[p].pos[1] + offset[1])
                                        points[p].move()
                                    pFlag = p
                                    break
                            if pFlag:
                                break
                        if pFlag:
                            for p in curparts[obj_lock][7]:
                                rad, ang3 = curparts[obj_lock][7][p]
                                ang3 += math.pi
                                logdict['points'][p] = points[p].pos
                                points[p].pos = (int(curparts[obj_lock][2][0] + rad * math.cos(ang3)), int(curparts[obj_lock][2][1] - rad * math.sin(ang3)))
                                points[p].move()
                                for b in bones:
                                    if b.pp == p:
                                        ang = (curparts[obj_lock][4] + b.ang) * math.pi / 180
                                        points[b.pd].pos = (int(points[b.pp].pos[0] + b.length * math.cos(ang)), int(points[b.pp].pos[1] - b.length * math.sin(ang)))
                                        points[b.pd].move()
                        elif not curparts[obj_lock][7]:
                            p = curparts[obj_lock]
                            part = p[1]
                            if not p[3] == 1:
                                part = pygame.transform.scale(part, (int(part.get_width() * p[3]), int(part.get_height() * p[3])))
                            if p[4]:
                                part = pygame.transform.rotate(part, p[4])
                            rad = (part.get_width() + part.get_height()) / 8
                            w, h = pos[0] - curparts[obj_lock][2][0], curparts[obj_lock][2][1] - pos[1]
                            rad2 = math.sqrt(w ** 2 + h ** 2)
                            if rad2 > rad:
                                ang2 = math.asin(h / rad2)
                                ang2 = math.pi - ang2 if w < 0 else ang2
                                ang2 += math.pi/2
                                curparts[obj_lock][4] = ang2/math.pi*180
                            else:
                                curparts[obj_lock][2] = (opos[0] + event.rel[0], opos[1] + event.rel[1])
                        else:
                            curparts[obj_lock][2] = (opos[0] + event.rel[0], opos[1] + event.rel[1])
                            for i in curparts[obj_lock][7]:
                                logdict['points'][i] = points[i].pos
                                points[i].pos = (points[i].pos[0] + event.rel[0], points[i].pos[1] + event.rel[1])
                                points[i].move()
                                for b in bones:
                                    if b.pp == i:
                                        points[b.pd].pos = (points[b.pd].pos[0] + event.rel[0], points[b.pd].pos[1] + event.rel[1])
                                        points[b.pd].move(pi=True)
                        laFlag = True
                        if log and log[-1][0] == 'motion':
                            laFlag = False
                            for pr in logdict['parts']:
                                if pr not in log[-1][1]['parts']:
                                    laFlag = True
                            for p in logdict['points']:
                                if p not in log[-1][1]['points']:
                                    laFlag = True
                        if laFlag:
                            log.append(('motion', logdict))
            if event.type == pygame.MOUSEBUTTONDOWN:
                if event.button < 4:
                    if bonetool and pos[0] < 1535 and pos[1] < 950 and cur_idx > -1 and sec_idx > -1:
                        p = curparts[cur_idx]
                        part = p[1]
                        if not p[3] == 1:
                            part = pygame.transform.scale(part, (int(part.get_width() * p[3]), int(part.get_height() * p[3])))
                        if p[4]:
                            part = pygame.transform.rotate(part, p[4])
                        if p[2][0] - part.get_width() // 2 < pos[0] < p[2][0] + part.get_width() // 2 and p[2][1] - part.get_height() // 2 < pos[1] < p[2][1] + part.get_height() // 2:
                            mpos = magnet if magnet else pos
                            boneline = mpos
                    if not bonetool and pos[0] < 1535 and pos[1] < 950:
                        if event.button == 1 or event.button == 3:
                            for i in range(len(curparts))[::-1]:
                                p = curparts[i]
                                part = p[1]
                                if not p[3] == 1:
                                    part = pygame.transform.scale(part, (int(part.get_width() * p[3]), int(part.get_height() * p[3])))
                                if p[4]:
                                    part = pygame.transform.rotate(part, p[4])
                                if p[2][0] - part.get_width()//2 < pos[0] < p[2][0] + part.get_width()//2 and p[2][1] - part.get_height()//2 < pos[1] < p[2][1] + part.get_height()//2:
                                    obj_lock = i
                                    break
                        elif event.button == 2:
                            if magnet:
                                for j in points:
                                    if magnet == points[j].pos:
                                        point_lock = j
                    for i, p in enumerate(curparts):
                        if 1535 < pos[0] < 1750 and 50 + 25 * i < pos[1] < 75 + 25 * i:
                            if event.button == 2:
                                id = curparts[i][6]
                                delbones = []
                                delp = []
                                del curparts[i]
                                for j in points:
                                    if points[j].obj == id:
                                        for bdx, b in enumerate(bones):
                                            if b.pp == j or b.pd == j:
                                                delbones.append(bdx)
                                        delp.append(j)
                                for j in delp:
                                    for pp in points:
                                        if j in pp.daughters:
                                            del pp.daughters[pp.daughters.index(j)]
                                        if j == pp.parent:
                                            pp.parent = None
                                    del points[j]
                                for j in delbones:
                                    del bones[j]
                                if i == cur_idx:
                                    cur_idx = -1
                                if i == sec_idx:
                                    sec_idx = -1
                                # сделать отмену удаления
                                break
                            list_lock = i
                    posesplus = 25 if temp_pose else 0
                    for i, p in enumerate(poses):
                        if 50 < pos[0] < 125 and 50 + posesplus + 25 * i < pos[1] < 75 + posesplus + 25 * i:
                            pose_lock = i
                            obj_lock = None
                if pos[1] > 970:
                    for i in range(240):
                        if i in frames:
                            fyoffset = 0 if i < 120 else 55
                            if 16 + i%120 * 15 < pos[0] < 28 + i%120 * 15 and 970 + fyoffset < pos[1] < 994 + fyoffset:
                                frame_lock = frames[i]
                                break
                elif not obj_lock == None:
                    if event.button == 4 or event.button == 5:
                        logdict = {'parts': {}, 'points': {}}
                        logdict['parts'][curparts[obj_lock][6]] = {4: curparts[obj_lock][4], 2: curparts[obj_lock][2], 7: curparts[obj_lock][7], 3: curparts[obj_lock][3]}
                        if event.button == 5:
                            curparts[obj_lock][3] *= 0.9
                        else:
                            curparts[obj_lock][3] /= 0.9
                        for p in curparts[obj_lock][7]:
                            curparts[obj_lock][7][p][0] = curparts[obj_lock][7][p][0]/logdict['parts'][curparts[obj_lock][6]][3]*curparts[obj_lock][3]
                        for p in curparts[obj_lock][7]:
                            for b in bones:
                                if b.pd == p:
                                    rad, ang = curparts[obj_lock][7][p]
                                    curparts[obj_lock][2] = (int(points[p].pos[0] + rad * math.cos(ang)), int(points[p].pos[1] - rad * math.sin(ang)))
                        for p in curparts[obj_lock][7]:
                            for b in bones:
                                if not b.pd == p:
                                    rad, ang = curparts[obj_lock][7][p]
                                    ang += math.pi
                                    points[p].pos = (int(curparts[obj_lock][2][0] + rad * math.cos(ang)), int(curparts[obj_lock][2][1] - rad * math.sin(ang)))
                                    points[p].move()
                        log.append(('motion', logdict))
            if event.type == pygame.MOUSEBUTTONUP:
                if boneline:
                    if cur_idx > -1 and sec_idx > -1:
                        p = curparts[sec_idx]
                        part = p[1]
                        if not p[3] == 1:
                            part = pygame.transform.scale(part, (int(part.get_width() * p[3]), int(part.get_height() * p[3])))
                        if p[4]:
                            part = pygame.transform.rotate(part, p[4])
                        if p[2][0] - part.get_width() // 2 < pos[0] < p[2][0] + part.get_width() // 2 and p[2][1] - part.get_height() // 2 < pos[1] < p[2][1] + part.get_height() // 2:
                            p1, p2 = None, None
                            mpos = magnet if magnet else pos
                            for i in points:
                                if points[i].pos == boneline:
                                    p1 = i
                                if points[i].pos == mpos:
                                    p2 = i
                            if p1 is None:
                                p1 = curparts[cur_idx][6]
                                while p1 in points:
                                    p1 += 100
                                points[p1] = Point(boneline, p1, curparts[cur_idx][6])
                                w, h = curparts[cur_idx][2][0] - boneline[0], boneline[1] - curparts[cur_idx][2][1]
                                rad = math.sqrt(h ** 2 + w ** 2)
                                ang = math.asin(h / rad)
                                ang = math.pi - ang if w < 0 else ang
                                curparts[cur_idx][7][p1] = [rad, ang]
                            if p2 is None:
                                p2 = curparts[sec_idx][6]
                                while p2 in points:
                                    p2 += 100
                                points[p2] = Point(mpos, p2, curparts[sec_idx][6])
                                w, h = curparts[sec_idx][2][0] - mpos[0], mpos[1] - curparts[sec_idx][2][1]
                                rad = math.sqrt(h ** 2 + w ** 2)
                                ang = math.asin(h / rad)
                                ang = math.pi - ang if w < 0 else ang
                                curparts[sec_idx][7][p2] = [rad, ang]

                            w, h = mpos[0] - boneline[0], boneline[1] - mpos[1]
                            ang = math.asin(h / math.sqrt(h ** 2 + w ** 2))
                            ang = math.pi - ang if w < 0 else ang
                            ang = ang/math.pi*180 - curparts[cur_idx][4]
                            points[p1].daughters.append(p2)
                            points[p2].parent = p1
                            bones.append(Bone(p1, p2, ang))
                            cur_idx = sec_idx
                            sec_idx = -1
                            log.append(('bonecr', (p1, p2)))
                    boneline = None
                elif 110 < pos[0] < 145 and 15 < pos[1] < 50:
                    pose = {'name': len(poses)+1, 'parts': mkcopy(curparts), 'points': mkcopy(points), 'bones': mkcopy(bones)}
                    poses.append(pose)
                    log.append(('newpos', pose['name']))
                elif 1830 < pos[0] < 1880 and 970 < pos[1] < 1020:
                    if play < 0:
                        if len(frames) > 1:
                            if cur_pose > -1:
                                poses[cur_pose] = {'name': poses[cur_pose]['name'], 'parts': mkcopy(curparts), 'points': mkcopy(points), 'bones': mkcopy(bones)}
                            for i in range(240):
                                if i in frames:
                                    play = i
                                    break
                    else:
                        play = -1
                        if cur_pose > -1:
                            curparts = mkcopy(poses[cur_pose]['parts'])
                            points = mkcopy(poses[cur_pose]['points'])
                            bones = mkcopy(poses[cur_pose]['bones'])
                elif pos[1] >= 970:
                    for i in range(240):
                        fyoffset = 0 if i < 120 else 55
                        if 16 + i%120 * 15 < pos[0] < 28 + i%120 * 15 and 970 + fyoffset < pos[1] < 994 + fyoffset:
                            if event.button == 3:
                                if i in frames:
                                    f = frames[i]
                                    log.append(('setpos', i, f))
                                    del frames[i]
                            elif not frame_lock == None:
                                if i in frames:
                                    f = frames[i]
                                else:
                                    f = None
                                log.append(('setpos', i, f))
                                frames[i] = frame_lock
                            elif not pose_lock == None:
                                if i in frames:
                                    f = frames[i]
                                else:
                                    f = None
                                log.append(('setpos', i, f))
                                frames[i] = pose_lock
                            elif i in frames:
                                if cur_pose > -1:
                                    poses[cur_pose] = {'name': poses[cur_pose]['name'], 'parts': mkcopy(curparts), 'points': mkcopy(points), 'bones': mkcopy(bones)}
                                elif curparts:
                                    temp_pose = {'name': 'temp', 'parts': mkcopy(curparts), 'points': mkcopy(points), 'bones': mkcopy(bones)}
                                cur_pose = frames[i]
                                curparts = mkcopy(poses[cur_pose]['parts'])
                                points = mkcopy(poses[cur_pose]['points'])
                                bones = mkcopy(poses[cur_pose]['bones'])
                elif temp_pose:
                    if 50 < pos[0] < 125 and 50 < pos[1] < 75:
                        if cur_pose > -1:
                            poses[cur_pose] = {'name': poses[cur_pose]['name'], 'parts': mkcopy(curparts), 'points': mkcopy(points), 'bones': mkcopy(bones)}
                            cur_pose = -1
                        curparts = mkcopy(temp_pose['parts'])
                        points = mkcopy(temp_pose['points'])
                        bones = mkcopy(temp_pose['bones'])
                        temp_pose = {}
                    elif not pose_lock == None:
                        for i, p in enumerate(poses):
                            if 50 < pos[0] < 125 and 75 + 25 * i < pos[1] < 100 + 25 * i:
                                if event.button == 1 or event.button == 3:
                                    if cur_pose > -1:
                                        poses[cur_pose] = {'name': poses[cur_pose]['name'], 'parts': mkcopy(curparts),
                                                           'points': mkcopy(points), 'bones': mkcopy(bones)}
                                    cur_pose = i
                                    curparts = mkcopy(poses[cur_pose]['parts'])
                                    points = mkcopy(poses[cur_pose]['points'])
                                    bones = mkcopy(poses[cur_pose]['bones'])
                                elif event.button == 2:
                                    for f in range(240):
                                        if f in frames:
                                            if frames[f] == i:
                                                del frames[f]
                                            elif frames[f] > i:
                                                frames[f] -= 1
                                    del poses[i]
                                    for pi in range(i, len(poses)):
                                        poses[pi]['name'] -= 1
                elif not pose_lock == None:
                    for i, p in enumerate(poses):
                        if 50 < pos[0] < 125 and 50 + 25 * i < pos[1] < 75 + 25 * i:
                            if event.button == 1 or event.button == 3:
                                if cur_pose > -1:
                                    poses[cur_pose] = {'name': poses[cur_pose]['name'], 'parts': mkcopy(curparts), 'points': mkcopy(points), 'bones': mkcopy(bones)}
                                elif curparts:
                                    temp_pose = {'name': 'temp', 'parts': mkcopy(curparts), 'points': mkcopy(points), 'bones': mkcopy(bones)}
                                cur_pose = i
                                curparts = mkcopy(poses[cur_pose]['parts'])
                                points = mkcopy(poses[cur_pose]['points'])
                                bones = mkcopy(poses[cur_pose]['bones'])
                            elif event.button == 2:
                                for f in range(240):
                                    if f in frames:
                                        if frames[f] == i:
                                            del frames[f]
                                        elif frames[f] > i:
                                            frames[f] -= 1
                                del poses[i]
                                for pi in range(i, len(poses)):
                                    poses[pi]['name'] -= 1
                elif obj_lock == None and pose_lock == None:
                    for i, p in enumerate(curparts):
                        if 1535 < pos[0] < 1750 and 50 + 25 * i < pos[1] < 75 + 25 * i:
                            if not list_lock == None and not i == list_lock:
                                log.append(('partdrag', list_lock, i))
                                new_cur_idx, new_sec_idx = cur_idx, sec_idx
                                llpart = curparts[list_lock]
                                if list_lock == cur_idx:
                                    new_cur_idx = i
                                if list_lock == sec_idx:
                                    new_sec_idx = i
                                if i < list_lock:
                                    for j in range(i, list_lock)[::-1]:
                                        curparts[j+1] = curparts[j]
                                        if j == cur_idx:
                                            new_cur_idx = j+1
                                        if j == sec_idx:
                                            new_sec_idx = j+1
                                else:
                                    for j in range(list_lock, i):
                                        curparts[j] = curparts[j+1]
                                        if j+1 == cur_idx:
                                            new_cur_idx = j
                                        if j+1 == sec_idx:
                                            new_sec_idx = j
                                curparts[i] = llpart
                                cur_idx, sec_idx = new_cur_idx, new_sec_idx
                            else:
                                if event.button == 1:
                                    if cur_idx == i:
                                        cur_idx = -1
                                    else:
                                        cur_idx = i
                                    if sec_idx == i:
                                        sec_idx = -1
                                if event.button == 3:
                                    if sec_idx == i:
                                        sec_idx = -1
                                    else:
                                        sec_idx = i
                                    if cur_idx == i:
                                        cur_idx = -1
                            break
                    for i, p in enumerate(parts):
                        if 1750 < pos[0] < 1950 and 50 + 25 * i < pos[1] < 75 + 25 * i:
                            max = 0
                            for i in curparts:
                                if i[6] > max:
                                    max = i[6]
                            curparts.append([p, pygame.image.load(f'{folder}\\{p}').convert_alpha(), (1000, 500), 1, 0, Image.open(f'{folder}\\{p}').convert('RGBA').load(), max+1, {}])
                            log.append(('newpart', max+1))
                if not event.button == 4 and not event.button == 5:
                    obj_lock = None
                    point_lock = None
                list_lock = None
                pose_lock = None
                frame_lock = None

        for i in range(AMAP_SIZE_X-1):
            pygame.draw.aaline(sc, YELLANGE, (i * TILE_SIZE_SCALED + TILE_SIZE_SCALED + X_OFFSET, Y_OFFSET), (i * TILE_SIZE_SCALED + TILE_SIZE_SCALED + X_OFFSET, Y_OFFSET + TILE_SIZE_SCALED * AMAP_SIZE_Y))
        for i in range(AMAP_SIZE_Y):
            pygame.draw.aaline(sc, YELLANGE, (X_OFFSET, i * TILE_SIZE_SCALED + TILE_SIZE_SCALED + Y_OFFSET), (X_OFFSET + TILE_SIZE_SCALED * AMAP_SIZE_X, i * TILE_SIZE_SCALED + TILE_SIZE_SCALED + Y_OFFSET))
            pygame.draw.aaline(sc, YELLOW, (X_OFFSET, (i - 0.25) * TILE_SIZE_SCALED + TILE_SIZE_SCALED + Y_OFFSET), (X_OFFSET + TILE_SIZE_SCALED * AMAP_SIZE_X, (i - 0.25) * TILE_SIZE_SCALED + TILE_SIZE_SCALED + Y_OFFSET))
        pygame.draw.circle(sc, DARK_RED, SCALING_POINT, 1)
        sc.blit(font.render(str((pos[0]-SCALING_POINT[0], pos[1]-SCALING_POINT[1])), True, (0, 0, 0)), (200, 15))

        for i in range(AMAP_SIZE_X - 1):
            pygame.draw.aaline(sc, YELLANGE, (i * TILE_SIZE + TILE_SIZE + X_OFFSET_MINI, Y_OFFSET_MINI), (i * TILE_SIZE + TILE_SIZE + X_OFFSET_MINI, Y_OFFSET_MINI + TILE_SIZE * AMAP_SIZE_Y))
        for i in range(AMAP_SIZE_Y):
            pygame.draw.aaline(sc, YELLANGE, (X_OFFSET_MINI, i * TILE_SIZE + TILE_SIZE + Y_OFFSET_MINI), (X_OFFSET_MINI + TILE_SIZE * AMAP_SIZE_X, i * TILE_SIZE + TILE_SIZE + Y_OFFSET_MINI))
            pygame.draw.aaline(sc, YELLOW, (X_OFFSET_MINI, (i - 0.25) * TILE_SIZE + TILE_SIZE + Y_OFFSET_MINI), (X_OFFSET_MINI + TILE_SIZE * AMAP_SIZE_X, (i - 0.25) * TILE_SIZE + TILE_SIZE + Y_OFFSET_MINI))

        pygame.draw.circle(sc, DARK_RED, SCALING_POINT_MINI, 1)
        for i,p in enumerate(curparts):
            if i == cur_idx:
                sc.blit(cur_ic, (1535, 50 + 25 * i))
                pygame.draw.rect(sc, BLUE, (1550, 50 + 25 * i, 180, 25))
            if i == sec_idx:
                sc.blit(sec_ic, (1535, 55 + 25 * i))
                pygame.draw.rect(sc, DARK_RED, (1550, 50 + 25 * i, 180, 25))
            sc.blit(font.render(p[0].split('.png')[0], True, (0, 0, 0)), (1550, 50+25*i))
            part = p[1]
            if not p[3] == 1:
                part = pygame.transform.scale(part, (int(part.get_width()*p[3]), int(part.get_height()*p[3])))
            if p[4]:
                part = pygame.transform.rotate(part, p[4])
            if i == cur_idx:
                pygame.draw.rect(sc, BLUE, (p[2][0]-part.get_width()//2, p[2][1]-part.get_height()//2, part.get_width(), part.get_height()), 1)
            if i == sec_idx:
                pygame.draw.rect(sc, DARK_RED, (p[2][0]-part.get_width()//2, p[2][1]-part.get_height()//2, part.get_width(), part.get_height()), 1)
            sc.blit(part, (p[2][0]-part.get_width()//2, p[2][1]-part.get_height()//2))
            pygame.draw.circle(sc, BLUE, p[2], 5)
            minipart = pygame.transform.scale(p[1], (int(p[1].get_width() * p[3] / TILE_SCALE), int(p[1].get_height() * p[3] / TILE_SCALE)))
            if p[4]:
                minipart = pygame.transform.rotate(minipart, p[4])
            minipos = unscale(p[2], True)
            sc.blit(minipart, (minipos[0] - minipart.get_width() // 2, minipos[1] - minipart.get_height() // 2))
        if not obj_lock == None:
            pFlag = False
            for p in curparts[obj_lock][7]:
                for b in bones:
                    if b.pd == p:
                        rad = curparts[obj_lock][7][p][0]*2
                        pygame.draw.circle(sc, GREY, curparts[obj_lock][2], rad, 1)
                        pFlag = True
            if not pFlag and not curparts[obj_lock][7]:
                p = curparts[obj_lock]
                part = p[1]
                if not p[3] == 1:
                    part = pygame.transform.scale(part, (int(part.get_width() * p[3]), int(part.get_height() * p[3])))
                if p[4]:
                    part = pygame.transform.rotate(part, p[4])
                rad = (part.get_width() + part.get_height()) / 8
                pygame.draw.circle(sc, GREY, curparts[obj_lock][2], rad, 1)
        if bonesmode:
            for i in bones:
                pygame.draw.aaline(sc, YELLOW, points[i.pp].pos, points[i.pd].pos)
                pygame.draw.circle(sc, LIGHT_GREEN, points[i.pp].pos, 8, 2)
                pygame.draw.circle(sc, LIGHT_BLUE, points[i.pd].pos, 5)

        if play > -1:
            if play in frames:
                curparts = mkcopy(poses[frames[play]]['parts'])
                points = mkcopy(poses[frames[play]]['points'])
                bones = mkcopy(poses[frames[play]]['bones'])
            else:
                one, two = None, None
                for i in range(240):
                    if i < play:
                        if i in frames:
                            one = i
                for i in range(240):
                    if i > play:
                        if i in frames:
                            two = i
                            break
                if two is None:
                    for i in range(240):
                        if i in frames:
                            one = i
                            break
                    curparts = mkcopy(poses[frames[one]]['parts'])
                    points = mkcopy(poses[frames[one]]['points'])
                    bones = mkcopy(poses[frames[one]]['bones'])
                    play = one
                else:
                    curparts = mkcopy(poses[frames[one]]['parts'])
                    points = mkcopy(poses[frames[one]]['points'])
                    bones = mkcopy(poses[frames[one]]['bones'])
                    kef = (play - one) / (two - one)

                    posesplit(one, two, kef)
            play += 1

        sc.blit(text_parts, (1750, 15))
        for i, p in enumerate(parts):
            sc.blit(font.render(p.split('.png')[0], True, (0, 0, 0)), (1750, 50 + 25 * i))
        sc.blit(text_curparts, (1550, 15))
        sc.blit(text_poses, (15, 15))
        if text_save_frames:
            text_save_frames -= 1
            sc.blit(text_save, (600, 15))
        sc.blit(plus_ic, (110, 15))
        posesplus = 0
        if temp_pose:
            sc.blit(font.render(str(temp_pose['name']), True, (0, 0, 0)), (50, 50))
            posesplus = 25
        for i, p in enumerate(poses):
            if i == cur_pose:
                pygame.draw.rect(sc, YELLOW, (40, 50 + posesplus + 25 * i, 40, 25))
            sc.blit(font.render(str(p['name']), True, (0, 0, 0)), (50, 50 + posesplus + 25 * i))
        sc.blit(text_bones, (1250, 20))
        sc.blit(text_tbones, (1250, 50))
        color = GREEN if bonetool else RED
        sc.blit(font.render(str(bonetool), True, color), (1370, 20))
        sc.blit(text_point_move_bind, (880, 50))
        color = GREEN if point_move_bind else RED
        sc.blit(font.render(str(point_move_bind), True, color), (1170, 50))
        pygame.draw.aaline(sc, DARK_RED, (1535, 0), (1535, 950))
        pygame.draw.aaline(sc, DARK_RED, (0, 950), (2000, 950))
        for i in range(240):
            fyoffset = 0 if i < 120 else 55
            if i == play-1:
                pygame.draw.rect(sc, DARK_RED, (16 + i%120 * 15, 970+fyoffset, 12, 24))
            else:
                pygame.draw.rect(sc, DARK_RED, (16+i%120*15, 970+fyoffset, 12, 24), 1)
            if i in frames:
                pygame.draw.circle(sc, BLACK, (22 + i%120 * 15, 988+fyoffset), 4)
                sc.blit(font3.render(str(poses[frames[i]]['name']), True, (0, 0, 0)), (17 + i%120 * 15, 995+fyoffset))
            if i % 5 == 4:
                sc.blit(font4.render(str(i+1), True, (0, 0, 0)), (17 + i % 120 * 15, 958 + fyoffset))
        if play > -1:
            sc.blit(playon_ic, (1830, 970))
        else:
            sc.blit(play_ic, (1830, 970))
        if boneline:
            mpos = magnet if magnet else pos
            pygame.draw.aaline(sc, YELLOW, boneline, mpos)
            pygame.draw.circle(sc, LIGHT_GREEN, boneline, 8, 2)
            pygame.draw.circle(sc, LIGHT_BLUE, mpos, 5)
        pygame.display.flip()
        clock.tick(FPS)

import os
import math
import random
import pygame
import re
import time
import numpy as np
from numba import njit
from collections import defaultdict
import string
from perlin_noise import PerlinNoise


WINDOW = 1900, 1000
FULL_WINDOW = 1920, 1080
HALF_WINDOW = tuple((i//2 for i in FULL_WINDOW))
FPS = 60

TILE_SIZE = 47
MAP_X_OFFSET = 116
MAP_Y_OFFSET = 259
MAP_SIZE_X = 36
MAP_SIZE_Y = 16
TEST_MAP_SIZE_X = 500
TEST_MAP_SIZE_Y = 250
CAMERA_SPEED = 20/TILE_SIZE
GRAVITY = 1 / FPS / 3
JUMP_SPEED = -0.11
FLYING_ACCEL_TO_SPEED = 0.1
DAMAGE_VALUE_TIME = 60
DAMAGE_VALUE_TRANSPARENT_START = 45
DAMAGE_VALUE_TRANSPARENT_TIME = DAMAGE_VALUE_TIME - DAMAGE_VALUE_TRANSPARENT_START
DAMAGE_VALUE_VSPEED = 150/FPS
DAMAGE_BAR_TIME = 180
DAMAGE_BAR_FRESH_START = 60
DAMAGE_BAR_FRESH_END = 120
DAMAGE_BAR_FRESH_TIME = DAMAGE_BAR_FRESH_END - DAMAGE_BAR_FRESH_START
DAMAGE_BAR_TRANSPARENT_TIME = 20
DAMAGE_BAR_TRANSPARENT_START = DAMAGE_BAR_TIME - DAMAGE_BAR_TRANSPARENT_TIME
UNIT_BAR_SIZE = (300, 55)


YELLOW = (255, 255, 0)
YELLANGE = (255, 192, 0)
ORANGE = (255, 128, 0)
BLUE = (0, 0, 225)
LIGHT_BLUE = (135, 208, 250)
RED = (255, 0, 0)
DARK_RED = (128, 0, 0)
GREEN = (64, 255, 64)
LIGHT_GREEN = (128, 255, 128)
BLACK = (0, 0, 0)
BROWN = (96, 38, 0)
GREY = (128, 128, 128)
GREEN_MASK = (0, 255, 29)
DMGCOLORS = {'n': (0, 0, 0), 'a': (128, 128, 128), 'w': (28, 56, 128), 'f': (224, 60, 30), 'e': (60, 224, 60), 'd': (96, 38, 220), 'l': (240, 240, 60), 'h': (118, 255, 122)}

INGAME_GUI = ((0, 60), (132, 0), (1016, 0), (516, 966))
MAIN_GUI = (175, 300)
MAIN_CIRCLE = (MAIN_GUI[0]+316, MAIN_GUI[1]+316, 316)
NAME_POS = (47, 24)
NAME_SIZES = (856, 276)
MAIN_CIRCLE_RSPEED = 22/60
MAIN_ELEMENTS_RSPEED = MAIN_CIRCLE_RSPEED*math.pi/180
BUTTON_PLAY = (322, 300)
BUTTON_PLAY_CIRCLE = (200,)

GUI_ICON_SIZE = (101, 101)
GUI_SMALL_ICON_SIZE = (50, 51)
GUI_CUR_AVATAR = (7, 172)
GUI_SKILLS = ((7, 367), (7, 476), (7, 585), (7, 694))
GUI_ITEMS = ((4, 816), (59, 816), (4, 871), (59, 871), (4, 926), (59, 926))
GUI_ALLIES = ((184, 7), (293, 7), (402, 7), (511, 7), (620, 7), (729, 7), (838, 7))
GUI_ENEMIES = ((1066, 7), (1175, 7), (1284, 7), (1393, 7), (1502, 7), (1611, 7), (1720, 7))
GUI_BAR_POSES = ((7, 282), (7, 307), (7, 332))
GUI_BAR_SIZE = (101, 22)
GUI_BAR_TRIANGLE = ((0, 0), (0, 1), (0, 2), (0, 3), (0, 4), (0, 5), (0, 6), (0, 7), (0, 8), (0, 9), (0, 10), (0, 11), (0, 12), (0, 13), (0, 14), (0, 15), (0, 16), (0, 17), (0, 18), (0, 19), (0, 20), (0, 21), (1, 0), (1, 1), (1, 2), (1, 3), (1, 4), (1, 5), (1, 6), (1, 7), (1, 8), (1, 9), (1, 10), (1, 11), (1, 12), (1, 13), (1, 14), (1, 15), (1, 16), (1, 17), (1, 18), (1, 19), (1, 20), (2, 0), (2, 1), (2, 2), (2, 3), (2, 4), (2, 5), (2, 6), (2, 7), (2, 8), (2, 9), (2, 10), (2, 11), (2, 12), (2, 13), (2, 14), (2, 15), (2, 16), (2, 17), (2, 18), (3, 0), (3, 1), (3, 2), (3, 3), (3, 4), (3, 5), (3, 6), (3, 7), (3, 8), (3, 9), (3, 10), (3, 11), (3, 12), (3, 13), (3, 14), (3, 15), (3, 16), (3, 17), (4, 0), (4, 1), (4, 2), (4, 3), (4, 4), (4, 5), (4, 6), (4, 7), (4, 8), (4, 9), (4, 10), (4, 11), (4, 12), (4, 13), (4, 14), (4, 15), (5, 0), (5, 1), (5, 2), (5, 3), (5, 4), (5, 5), (5, 6), (5, 7), (5, 8), (5, 9), (5, 10), (5, 11), (5, 12), (5, 13), (6, 0), (6, 1), (6, 2), (6, 3), (6, 4), (6, 5), (6, 6), (6, 7), (6, 8), (6, 9), (6, 10), (6, 11), (7, 0), (7, 1), (7, 2), (7, 3), (7, 4), (7, 5), (7, 6), (7, 7), (7, 8), (7, 9), (7, 10), (8, 0), (8, 1), (8, 2), (8, 3), (8, 4), (8, 5), (8, 6), (8, 7), (8, 8), (9, 0), (9, 1), (9, 2), (9, 3), (9, 4), (9, 5), (9, 6), (10, 0), (10, 1), (10, 2), (10, 3), (10, 4), (11, 0), (11, 1), (11, 2), (11, 3), (12, 0), (12, 1))
GUI_BAR_TRIANGLE_RIGHT = ((88, 21), (89, 19), (89, 20), (89, 21), (90, 18), (90, 19), (90, 20), (90, 21), (91, 16), (91, 17), (91, 18), (91, 19), (91, 20), (91, 21), (92, 14), (92, 15), (92, 16), (92, 17), (92, 18), (92, 19), (92, 20), (92, 21), (93, 12), (93, 13), (93, 14), (93, 15), (93, 16), (93, 17), (93, 18), (93, 19), (93, 20), (93, 21), (94, 11), (94, 12), (94, 13), (94, 14), (94, 15), (94, 16), (94, 17), (94, 18), (94, 19), (94, 20), (94, 21), (95, 9), (95, 10), (95, 11), (95, 12), (95, 13), (95, 14), (95, 15), (95, 16), (95, 17), (95, 18), (95, 19), (95, 20), (95, 21), (96, 7), (96, 8), (96, 9), (96, 10), (96, 11), (96, 12), (96, 13), (96, 14), (96, 15), (96, 16), (96, 17), (96, 18), (96, 19), (96, 20), (96, 21), (97, 5), (97, 6), (97, 7), (97, 8), (97, 9), (97, 10), (97, 11), (97, 12), (97, 13), (97, 14), (97, 15), (97, 16), (97, 17), (97, 18), (97, 19), (97, 20), (97, 21), (98, 4), (98, 5), (98, 6), (98, 7), (98, 8), (98, 9), (98, 10), (98, 11), (98, 12), (98, 13), (98, 14), (98, 15), (98, 16), (98, 17), (98, 18), (98, 19), (98, 20), (98, 21), (99, 2), (99, 3), (99, 4), (99, 5), (99, 6), (99, 7), (99, 8), (99, 9), (99, 10), (99, 11), (99, 12), (99, 13), (99, 14), (99, 15), (99, 16), (99, 17), (99, 18), (99, 19), (99, 20), (99, 21), (100, 0), (100, 1), (100, 2), (100, 3), (100, 4), (100, 5), (100, 6), (100, 7), (100, 8), (100, 9), (100, 10), (100, 11), (100, 12), (100, 13), (100, 14), (100, 15), (100, 16), (100, 17), (100, 18), (100, 19), (100, 20), (100, 21))
GUI_BAR_RECTANGLE_OFFSET = 13

GUI_MBARS_ALLIES = ((187, 117), (187, 131), (187, 145)), ((296, 117), (296, 131), (296, 145)), ((405, 117), (405, 131), (405, 145)), ((514, 117), (514, 131), (514, 145)), ((623, 117), (623, 131), (623, 145)), ((732, 117), (732, 131), (732, 145)), ((841, 117), (841, 131), (841, 145))
GUI_MBARS_ENEMIES = ((1069, 117), (1069, 131), (1069, 145)), ((1178, 117), (1178, 131), (1178, 145)), ((1287, 117), (1287, 131), (1287, 145)), ((1396, 117), (1396, 131), (1396, 145)), ((1505, 117), (1505, 131), (1505, 145)), ((1614, 117), (1614, 131), (1614, 145)), ((1723, 117), (1723, 131), (1723, 145))
GUI_MBAR_SIZE = (95, 11)
GUI_MBAR_TRIANGLE = ((0, 0), (0, 1), (0, 2), (0, 3), (0, 4), (0, 5), (0, 6), (0, 7), (0, 8), (1, 0), (1, 1), (1, 2), (1, 3), (1, 4), (1, 5), (1, 6), (2, 0), (2, 1), (2, 2), (2, 3), (2, 4), (3, 0), (3, 1), (3, 2), (3, 3), (4, 0), (4, 1))
GUI_MBAR_TRIANGLE_RIGHT = ((89, 9), (89, 10), (90, 7), (90, 8), (90, 9), (90, 10), (91, 5), (91, 6), (91, 7), (91, 8), (91, 9), (91, 10), (92, 4), (92, 5), (92, 6), (92, 7), (92, 8), (92, 9), (92, 10), (93, 2), (93, 3), (93, 4), (93, 5), (93, 6), (93, 7), (93, 8), (93, 9), (93, 10), (94, 1), (94, 2), (94, 3), (94, 4), (94, 5), (94, 6), (94, 7), (94, 8), (94, 9), (94, 10))
GUI_MBAR_RECTANGLE_OFFSET = 6

RUNESTONE_SIZE = 1196, 1038
RUNESTONE_RUNE = 16, 12
RUNESTONE_MAP = 21, 17
RUNESTONE_PIECES = 1285, 12
RUNESTONE_PIECES_END = 1902, 1070
RUNESTONE_PIECE_FIRST = 1320, 50
RUNESTONE_PIECE = 100, 100
RUNESTONE_PIECE_GAP = 17

FILTER_ALLIES = [1]
FILTER_ENEMIES = [2]
FILTER_SELF = [3]
FILTER_SUMMONS = [4]
FILTER_WALKING = [5]
FILTER_FLYING = [6]
FILTER_SWIMMING = [7]
FILTER_WALLS = [8]
FILTER_CAVES = [9]
FILTER_MELEE = [10]
FILTER_RANGED = [11]
FILTER_UNITS = [12]

MIN_HP = 1
MIN_MANA = 1
MIN_SPEED = 1
MIN_SIGHT = 1
MIN_ATTACK_SPEED = 30
MIN_SIZE_PERCENT = 0.1

# Ability provides
# Three bits for provide type, four for type value, one for percent
# Values of one type is separated

PROVIDE_DMG = 0b00100010
PROVIDE_DMG_PERCENT = 0b00100011
PROVIDE_ATTACK_SPEED = 0b00100100
PROVIDE_ATTACK_SPEED_PERCENT = 0b00100101
PROVIDE_ACCURACY = 0b00101000
PROVIDE_ACCURACY_PERCENT = 0b00101001
PROVIDE_MULTISHOT = 0b00100110
PROVIDE_MULTISHOT_PERCENT = 0b00100111
PROVIDE_ATTACK_TYPE = 0b00101010
PROVIDE_ATTACK = 0b00101100

PROVIDE_HP = 0b01000010
PROVIDE_HP_PERCENT = 0b01000011
PROVIDE_MANA = 0b01000100
PROVIDE_MANA_PERCENT = 0b01000101
PROVIDE_ARMOR = 0b01000110
PROVIDE_ARMOR_PERCENT = 0b01000111
PROVIDE_SPEED = 0b01001000
PROVIDE_SPEED_PERCENT = 0b01001001
PROVIDE_SIZE = 0b01001010
PROVIDE_SIZE_PERCENT = 0b01001011
PROVIDE_SIGHT = 0b01001100
PROVIDE_SIGHT_PERCENT = 0b01001101

PROVIDE_STRENGTH = 0b01100010
PROVIDE_STRENGTH_PERCENT = 0b01100011
PROVIDE_RADIUS = 0b01100110
PROVIDE_RADIUS_PERCENT = 0b01100111
PROVIDE_ADURATION = 0b01100100
PROVIDE_ADURATION_PERCENT = 0b01100101
PROVIDE_MANACOST = 0b01101000
PROVIDE_MANACOST_PERCENT = 0b01101001
PROVIDE_CASTSPEED = 0b01101010
PROVIDE_CASTSPEED_PERCENT = 0b01101011
PROVIDE_REDUCTION = 0b01101100
PROVIDE_REDUCTION_PERCENT = 0b01101101
PROVIDE_SUPER = 0b01101110
PROVIDE_SUPER_PERCENT = 0b01101111

PROVIDE_STATUS = 0b11100010
PROVIDE_SPELL_CASTING = 0b11100100
PROVIDE_SPELL_STARTING = 0b11100110

# Statuses
# 1 means locking ability to jump, move, cast, attack and use passive abs
# the last two are providing invisible and forbids to be invisible
# The default status is 0
# 7 bits: jmcapiv
STATUS_DEAD = 0b1111101
STATUS_STUN = 0b1111000
STATUS_ROOT = 0b0100001
STATUS_SILENCE = 0b0010000
STATUS_DISARM = 0b0001000
STATUS_BREAK = 0b0000101
STATUS_INVISIBLE = 0b0000010
STATUS_VISIBLE = 0b0000001
STATUS_PSYCHOSIS = 0b0011101


def get_bit(value, n):
    return value >> n & 1


def set_bit(value, n):
    return value | (1 << n)


def clear_bit(value, n):
    return value & ~(1 << n)


def longsplit(mes, n):
    mes = [i for i in mes]
    l = len(mes)
    if l <= n:
        return mes[:n]
    c = math.ceil(l/n)
    res = []
    for i in range(c-1):
        res += mes[:n]
        mes = mes[n:]
    res += mes
    return res


@njit(fastmath=True)
def chance(a, b=100):
    if random.randint(1, b) <= a:
        return True
    return False


def search_unit_folder(data):
    for i in os.listdir('units'):
        if data in os.listdir(f'units\\{i}'):
            return f'units\\{i}\\{data}'


def select_next_unit(level, pos):
    level.selected_unit.mousepos = (pos[0]-level.mp[0], pos[1]-level.mp[1])
    rolls = 1
    idx = level.units.index(level.selected_unit) + 1
    idx = 0 if idx == len(level.units) else idx
    while not level.units[idx].canbecontrolled or level.units[idx].dead and rolls <= len(level.units):
        idx += 1
        idx = 0 if idx == len(level.units) else idx
        rolls += 1
    level.selected_unit = level.units[idx]
    level.camera_bind = level.selected_unit
    level.camera_bind_offset = (0, 0)
    level.selected_skill = None
    level.selected_item = None


def select_prev_unit(level, pos):
    level.selected_unit.mousepos = (pos[0]-level.mp[0], pos[1]-level.mp[1])
    rolls = 1
    idx = level.units.index(level.selected_unit) - 1
    idx = len(level.units) - 1 if idx == -1 else idx
    while not level.units[idx].canbecontrolled or level.units[idx].dead and rolls <= len(level.units):
        idx -= 1
        idx = len(level.units) - 1 if idx == -1 else idx
        rolls += 1
    level.selected_unit = level.units[idx]
    level.camera_bind = level.selected_unit
    level.camera_bind_offset = (0, 0)
    level.selected_skill = None
    level.selected_item = None


@njit(fastmath=True)
def accuracy(a, ang):
    if a >= 100:
        return ang
    if chance(a):
        return ang
    b = random.randint(0, 100-a)/100*math.pi
    c = random.randint(0, 1)
    ang = ang+b if c else ang-b
    return ang


@njit(fastmath=True)
def meleeaccuracy(a, top, bot):
    if a >= 100:
        return top, bot
    if chance(a):
        return top, bot
    b = random.randint(0, 100-a)/100*math.pi
    c = random.randint(0, 1)
    top = top+b if c else top-b
    bot = bot+b if c else bot-b
    return top, bot


@njit(fastmath=True)
def getrange(axy, bxy):
    ax, ay = axy
    bx, by = bxy
    return math.sqrt((bx-ax)**2+(by-ay)**2)


def find_provides(unit, prv, prvp):
    s, sp = {}, {}
    for i in unit.modifiers:
        if prv in i.provides:
            if i.name in s:
                if i.stackable:
                    s[i.name] += i.provides[prv]
                elif i.provides[prv] > s[i.name]:
                    s[i.name] = i.provides[prv]
            else:
                s[i.name] = i.provides[prv]
    for i in unit.modifiers:
        if prvp in i.provides:
            if i.name in sp:
                if i.stackable:
                    sp[i.name] += i.provides[prvp]
                elif i.provides[prvp] > sp[i.name]:
                    sp[i.name] = i.provides[prvp]
            else:
                sp[i.name] = i.provides[prvp]
    return s, sp


@njit(fastmath=True)
def circleColl(center, rad, box):
    if rad < 0:
        return False
    tx, ty = center
    tx = box[0] if tx < box[0] else box[1] if tx > box[1] else tx
    ty = box[2] if ty < box[2] else box[3] if ty > box[3] else ty
    return (center[0]-tx)**2+(center[1]-ty)**2 < rad**2


def circleCollMany(centers_rads, box):
    for tx, ty, r in centers_rads:
        c = tx, ty
        tx = box[0] if tx < box[0] else box[1] if tx > box[1] else tx
        ty = box[2] if ty < box[2] else box[3] if ty > box[3] else ty
        if (c[0]-tx)**2+(c[1]-ty)**2 < r**2:
            return True
    return False


def ti(func):
    def wr(*args, **kwargs):
        t = time.perf_counter()
        a = func(*args, **kwargs)
        print(time.perf_counter()-t)
        return a
    return wr


def deepsum(items):
    s = items[0]
    for i in items[1:]:
        s += i
    return s


def deepmax(items):
    s = items[0]
    for i in items[1:]:
        if i > s:
            s = i
    return s


def alphanum_random(length):
    letters_and_digits = string.ascii_letters + string.digits
    rand_string = ''.join(random.sample(letters_and_digits, length))
    return rand_string


def forcenpsave(fname, map):
    if not os.path.exists('temp'):
        os.mkdir('temp')
    code = alphanum_random(5)
    np.save(f'temp\\{code}', map)
    os.replace(f'temp\\{code}.npy', fname+'.npy')


def forcesave(fname, data):
    if not os.path.exists('temp'):
        os.mkdir('temp')
    code = alphanum_random(5)
    file = open(f'temp\\{code}.txt', 'w', encoding='utf-8')
    file.write(str(data))
    file.close()
    os.replace(f'temp\\{code}.txt', fname)


def perlin_noise(x, y):
    noise1 = PerlinNoise(octaves=3)
    noise2 = PerlinNoise(octaves=6)
    noise3 = PerlinNoise(octaves=12)
    noise4 = PerlinNoise(octaves=24)

    xpix, ypix = x, y
    pic = []
    for i in range(ypix):
        row = []
        for j in range(xpix):
            noise_val = noise1([i / xpix, j / ypix])
            noise_val += 0.5 * noise2([i / xpix, j / ypix])
            noise_val += 0.25 * noise3([i / xpix, j / ypix])
            noise_val += 0.125 * noise4([i / xpix, j / ypix])
            row.append(noise_val)
        pic.append(row)
    return pic


from config import *


class GUI:
    texd = {i.split('.png')[0]: pygame.image.load(f'textures\\GUI\\{i}') for i in os.listdir('textures\\GUI') if i.endswith('.png')}

    def __init__(self):
        for i in GUI.texd.values():
            i.convert_alpha()
        self.level = None
        self.panel = GUI.texd['game1']

        self.hpbar = GUI.texd['hpbar']
        self.hpbar_mask = GUI.texd['hpbar_mask']
        self.hpbarsize = self.hpbar.get_width(), self.hpbar.get_height()
        self.hpbaroffset = 0, 0
        self.manabar = GUI.texd['manabar']
        self.manabar_mask = GUI.texd['manabar_mask']
        self.manabarsize = self.manabar.get_width(), self.manabar.get_height()
        self.manabaroffset = 0, self.hpbarsize[1]+7

        self.color = (0, 0, 0)
        self.color_panel()

        self.selected_unit = None
        self.selected_unit_menu = ''
        self.selected_unit_menu_pos = (0,0)
        self.bigmenu = None

    def load(self, level):
        self.level = level

    def blit(self, sc):
        pass
        sc.blit(self.panel, (0, 100))
        if self.selected_unit:
            sc.blit(self.panel, self.selected_unit_menu_pos)

    def make_unit_bar(self, unit):
        bar = pygame.Surface(UNIT_BAR_SIZE, pygame.SRCALPHA, 32)

        hpvalue = pygame.Surface((int(self.hpbarsize[0]*unit.hp/unit.maxhp), self.hpbarsize[1]), pygame.SRCALPHA, 32)
        hpvalue.set_colorkey(GREEN_MASK)
        hpvalue.fill(RED)
        hpvalue.blit(self.hpbar_mask, (0, 0))
        manavalue = pygame.Surface((int(self.manabarsize[0] * unit.mana / unit.maxmana), self.manabarsize[1]), pygame.SRCALPHA, 32)
        manavalue.set_colorkey(GREEN_MASK)
        manavalue.fill(BLUE)
        manavalue.blit(self.manabar_mask, (0, 0))

        bar.blit(hpvalue, self.hpbaroffset)
        bar.blit(manavalue, self.manabaroffset)
        bar.blit(self.hpbar, self.hpbaroffset)
        bar.blit(self.manabar, self.manabaroffset)
        return bar

    def make_fresh_from_bar(self, unit, bar, kef):
        if kef < 0:
            return bar
        freshvalue = pygame.Surface((int(self.hpbarsize[0] * (unit.lasthp[1]-unit.hp) / unit.maxhp * kef), self.hpbarsize[1]), pygame.SRCALPHA, 32)
        freshvalue.set_colorkey(GREEN_MASK)
        freshvalue.fill(YELLANGE)
        xoffset = int(self.hpbarsize[0]*unit.hp/unit.maxhp)
        freshvalue.blit(self.hpbar_mask, (-xoffset, 0))

        bar.blit(freshvalue, (self.hpbaroffset[0]+xoffset, self.hpbaroffset[1]))
        bar.blit(self.hpbar, self.hpbaroffset)
        return bar

    def recolor(self):
        if self.level.sp.sum() == 0:
            self.color = (0, 0, 0)
        else:
            count = 0
            color = [0, 0, 0]
            for k, v in self.level.sp:
                if v > 0:
                    count += 1
                    color[0] += DMGCOLORS[k][0]
                    color[1] += DMGCOLORS[k][1]
                    color[2] += DMGCOLORS[k][2]
            color[0] //= count
            color[1] //= count
            color[2] //= count
            self.color = tuple(color)
        self.color_panel()

    def color_panel(self):
        w, h = self.panel.get_size()
        # r, g, b = self.color
        # for x in range(w):
        #     for y in range(h):
        #         a = self.panel.get_at((x, y))[3]
        #         self.panel.set_at((x, y), (r, g, b, a))

    # TODO: интерфейс на позиции мыши (юниты, предметы, способности)
    #  Общй инвентарь блоков
    #

    def fetch_click(self, button, mpos):
            pos = (mpos[0]-self.level.mp[0])/self.level.tile_size, (mpos[1]-self.level.mp[1])/self.level.tile_size
            menuActivateFlag = False
            for u in self.level.units:
                if u.cords.x + u.size.x / 2 > pos[0] > u.cords.x - u.size.x / 2 and u.cords.y > pos[1] > u.cords.y - u.size.y:
                    if button == 3:
                        if u.canbecontrolled and not u.dead:
                            self.level.selected_unit.mousepos = (pos[0] - self.level.mp[0], pos[1] - self.level.mp[1])
                            self.level.selected_unit = u
                            self.level.camera_bind = u
                            self.level.camera_bind_offset = (0, 0)
                            self.level.selected_skill = None
                            self.level.selected_item = None
                    elif button == 2:
                        menuActivateFlag = True
                        self.selected_unit = u
                        self.selected_unit_menu = 'main'
                        self.selected_unit_menu_pos = mpos
            if not menuActivateFlag:
                self.selected_unit = None
                self.selected_unit_menu = ''
                self.selected_unit_menu_pos = (0,0)


class Dialogs:
    def __init__(self):
        self.level = None

    def load(self, level):
        self.level = level

    # TODO: интерфейс для диалогов, сохранение и загрузка, интеракции

import os
import math
import random
import pygame
import sqlite3
from PIL import Image

from config import *
from level import *


pygame.init()
sc = pygame.display.set_mode(FULL_WINDOW)
clock = pygame.time.Clock()

font30 = pygame.font.SysFont('calibri', 30)
font36 = pygame.font.SysFont('calibri', 36)

runa = Runa()
gui = GUI()
dialogs = Dialogs()
level = Level(1001001, runa, gui, dialogs, editor=True).load()

cur_block_id = 1

while True:
    sc.fill(pygame.Color('white'))
    pos = pygame.mouse.get_pos()
    pressed = pygame.mouse.get_pressed()
    keys = pygame.key.get_pressed()

    for event in pygame.event.get():
        if event.type == pygame.QUIT:
            exit()
        if event.type == pygame.KEYDOWN:
            if event.key == pygame.K_ESCAPE:
                exit()
        if event.type == pygame.MOUSEBUTTONDOWN:
            if event.button == 5:
                if level.camera_scale > 0.2:
                    level.camera_scale *= 0.9
                    level.tile_size = int(TILE_SIZE * level.camera_scale)
                    level.chunk_size_px = level.tile_size * level.chunk_size
                    chunksize = int(level.nsc[0][0].get_width() * level.camera_scale)
                    level.sc = [[pygame.transform.scale(j, (chunksize, chunksize)) for j in i] for i in level.nsc]
            elif event.button == 4:
                if level.camera_scale < 5:
                    level.camera_scale /= 0.9
                    level.tile_size = int(TILE_SIZE * level.camera_scale)
                    level.chunk_size_px = level.tile_size * level.chunk_size
                    chunksize = int(level.nsc[0][0].get_width() * level.camera_scale)
                    level.sc = [[pygame.transform.scale(j, (chunksize, chunksize)) for j in i] for i in level.nsc]

    bcords = int((pos[0] - level.mp[0]) / level.tile_size), int((pos[1] - level.mp[1]) / level.tile_size)
    if pressed[0] or pressed[2]:
        if 0 <= bcords[0] < level.size.y and 0 <= bcords[1] < level.size.x:
            level.tilemap[bcords[0]][bcords[1]] = cur_block_id if pressed[0] else 0
            level.update_chunk(bcords)

    level.move_camera(pos)
    level.tick()
    level.paint(sc, (), ())
    sc.blit(font30.render(str(bcords), True, (0, 0, 0)), (1680, 10))
    sc.blit(font30.render(str(int(clock.get_fps())), True, (0, 0, 0)), (1850, 10))
    pygame.display.flip()
    clock.tick(FPS)

import pygame
import os
import sqlite3
from PIL import Image, ImageFilter
import time
import ast
import matplotlib.pyplot as plt
import numpy as np

from config import *
from animation import *
from gui import *
from runestone import *
from unit import *


def load_block(i, data):
    part = pygame.image.load(f'blocks\\{i}.png')
    part = pygame.transform.scale(part, (TILE_SIZE, TILE_SIZE))
    data['tex'] = part
    return data['id'], data


def search_last_level():
    maxlptime = 0
    maxlplevel = 0
    with open('leveldata\\levels.txt', 'r', encoding='utf-8') as levels:
        levels = ast.literal_eval(levels.read())
        for i in levels:
            if levels[i]['last_played'] > maxlptime:
                maxlptime = levels[i]['last_played']
                maxlplevel = i
    return maxlplevel


@njit(fastmath=True)
def getmp(pos, camera, camera_bind, camera_bind_cords, camera_bind_offset, tile_size, chunk_size_px, map_size, chunkmap_size):
    cbox, cboy = camera_bind_offset
    if camera_bind:
        if pos[0] < 100:
            cbox -= CAMERA_SPEED
            if cbox < -HALF_WINDOW[0] / tile_size:
                cbox = -HALF_WINDOW[0] / tile_size
        if pos[1] < 100:
            cboy -= CAMERA_SPEED
            if cboy < -HALF_WINDOW[1] / tile_size:
                cboy = -HALF_WINDOW[1] / tile_size
        if pos[0] > FULL_WINDOW[0] - 100:
            cbox += CAMERA_SPEED
            if cbox > HALF_WINDOW[0] / tile_size:
                cbox = HALF_WINDOW[0] / tile_size
        if pos[1] > FULL_WINDOW[1] - 100:
            cboy += CAMERA_SPEED
            if cboy> HALF_WINDOW[1] / tile_size:
                cboy = HALF_WINDOW[1] / tile_size
        camera = (camera_bind_cords[0] + cbox, camera_bind_cords[1] + cboy)
        # if self.camera.x < 0:
        #     self.camera.x = 0
        # if self.camera.x > self.size.x:
        #     self.camera.x = self.size.x
        # if self.camera.y < 0:
        #     self.camera.y = 0
        # if self.camera.y > self.size.y:
        #     self.camera.y = self.size.y
    else:
        one, two = camera
        if pos[0] < 200:
            one = camera[0] - CAMERA_SPEED
            if one < 0:
                one = 0
        if pos[1] < 200:
            two = camera[1] - CAMERA_SPEED
            if two < 0:
                two = 0
        if pos[0] > FULL_WINDOW[0] - 200:
            one = camera[0] + CAMERA_SPEED
            if one > map_size[0]:
                one = map_size[0]
        if pos[1] > FULL_WINDOW[1] - 200:
            two = camera[1] + CAMERA_SPEED
            if two > map_size[1]:
                two = map_size[0]
        if not camera == (one, two):
            camera = (one, two)
    mp = (int(HALF_WINDOW[0] - camera[0] * tile_size), int(HALF_WINDOW[1] - camera[1] * tile_size))
    if mp[0] > 0:
        mp = 0, mp[1]
    if mp[1] > 0:
        mp = mp[0], 0
    if mp[0] < -map_size[0] * tile_size + FULL_WINDOW[0]:
        mp = -map_size[0] * tile_size + FULL_WINDOW[0], mp[1]
    if mp[1] < -map_size[1] * tile_size + FULL_WINDOW[1]:
        mp = mp[0], -map_size[1] * tile_size + FULL_WINDOW[1]
    mchunks = [(i, j, mp[0] + chunk_size_px * i, mp[1] + chunk_size_px * j)
               for i in range(chunkmap_size[0]) if -chunk_size_px <= mp[0] + chunk_size_px * i < FULL_WINDOW[0]
               for j in range(chunkmap_size[1]) if -chunk_size_px <= mp[1] + chunk_size_px * j < FULL_WINDOW[1]]
    return camera, (cbox, cboy),  mp, mchunks


def findClearSpaceForUnits(tilemap, sizes, place):
    tilemap = tilemap.copy()
    size = tilemap.shape
    res = []
    for x, y in sizes:
        dst = 0
        while True:
            dirs = []
            for i in range(dst):
                dirs += [(place[0]-(dst-i), place[1]+i), (place[0]+(dst-i), place[1]-i), (place[0]+i, place[1]+(dst-i)), (place[0]-i, place[1]-(dst-i))]
            dirs = [place] if not dirs else dirs[::-1]
            breakFlag = False
            for i,j in dirs:
                flag = True
                for iy in range(y):
                    if not flag:
                        break
                    if not 0 <= i - iy < size[1]:
                        flag = False
                        break
                    for jx in range(x):
                        if not 0 <= j + jx < size[0] or tilemap[i+iy][j+jx]:
                            flag = False
                            break
                if flag:
                    ri = random.randint(0, 50) / 50
                    res.append((i+ri, j))
                    for iy in range(y):
                        for jx in range(x):
                            tilemap[i+iy][j+jx] = -1
                    breakFlag = True
            dst += 1
            if breakFlag or dst > size[0]:
                break
    return res


def findRandomSpaceForUnits(tilemap, sizes, place, radius):
    tilemap = tilemap.copy()
    size = tilemap.shape
    res = []
    dirs = [place]
    for dst in range(1, radius+1):
        for i in range(dst):
            dirs += [(place[0] - (dst - i), place[1] + i), (place[0] + (dst - i), place[1] - i),
                     (place[0] + i, place[1] + (dst - i)), (place[0] - i, place[1] - (dst - i))]
    for x, y in sizes:
        v = 0
        while v < len(dirs):
            i, j = random.choice(dirs)
            flag = True
            for iy in range(y):
                if not flag:
                    break
                if not 0 <= i - iy < size[1]:
                    flag = False
                    break
                for jx in range(x):
                    if not 0 <= j + jx < size[0] or tilemap[i + iy][j + jx]:
                        flag = False
                        break
            if flag:
                ri = random.randint(0, 50) / 50
                res.append((i + ri, j))
                for iy in range(y):
                    for jx in range(x):
                        tilemap[i + iy][j + jx] = -1
                break
            v += 1

    return res


class Level:
    blocks = {}
    blocks_offset = {}
    with open('blocks\\blocks.txt', 'r', encoding='utf-8') as blocksfile:
        blocksfile = ast.literal_eval(blocksfile.read())
        for i in blocksfile:
            blockid, block = load_block(i, blocksfile[i])
            blocks[blockid] = block
            if 'offset' in block:
                blocks_offset[blockid] = block['offset']
    #  TODO:
    #   расширить тайлсет новыми блоками
    #   задний уровень: подуровень со стенами и декорациями
    #   AI

    def __init__(self, id, runa, gui, dialogs, **kwargs):
        self.id = id
        self.bck = pygame.image.load('textures\\bck.png').convert_alpha() # Временный бекграунд
        self.bck = pygame.transform.scale(self.bck, FULL_WINDOW)
        if id == 0: # для проецирования последней сыгранной карты на фоне в меню
            self.id = search_last_level()
        self.kwargs = kwargs
        self.size = Vector(TEST_MAP_SIZE_X, TEST_MAP_SIZE_Y)
        self.chunk_size = 20
        self.chunkmap_size = Vector(math.ceil(TEST_MAP_SIZE_X/self.chunk_size), math.ceil(TEST_MAP_SIZE_Y/self.chunk_size))
        self.tilemap = np.zeros((self.size.x, self.size.y), 'int')
        self.block_data = {}
        self.spawn = tuple((Vector(10+2*i, 10) for i in range(7)))
        self.enemy_spawn = tuple((Vector(30+i, 10) for i in range(7)))
        self.camera = (0, 0)
        self.camera_bind = None
        self.camera_bind_offset = (0, 0)
        self.camera_scale = 1
        self.tile_size = TILE_SIZE
        self.chunk_size_px = TILE_SIZE * self.chunk_size
        self.nsc = [[pygame.Surface((self.chunk_size * TILE_SIZE, self.chunk_size * TILE_SIZE), pygame.SRCALPHA, 32) for _ in range(self.chunkmap_size.y)] for _ in range(self.chunkmap_size.x)]
        self.sc = [[j for j in i] for i in self.nsc]
        self.projectiles = []
        self.ticks = 0
        self.mp = (0,0)
        self.mchunks = ()
        self.selected_unit = None
        self.selected_skill = None
        self.selected_item = None
        self.allvision = False
        self.units = []
        self.sp = DamageTable()
        self.gui = gui
        self.runa = runa
        self.dialogs = dialogs
        self.dropped = []
        self.teams = ['ally', 'enemy']
        self.visions = {i: () for i in self.teams}
        self.levelmap_tex = None

    def load(self, regen=False):
        self.runa.load(self)
        self.gui.load(self)
        self.dialogs.load(self)
        if self.id == 0:
            return self
        level = self.id // 1000
        var = self.id % 1000
        fn = f'{level}-{var}'
        if 'editor' in self.kwargs and self.kwargs['editor']:
            fn += 'editor'
        if f'{fn}.npy' not in os.listdir(f'leveldata') or regen:
            self.generate_terrain()
            self.save_terrain()
        else:
            self.tilemap = np.load(f'leveldata\\{fn}.npy')
        self.render_terrain()
        allies = self.runa.load_units()
        self.spawn = tuple((Vector(i) for i in findClearSpaceForUnits(self.tilemap, [i.size.cort() for i in allies], (10, 10))))
        enemies = [Unit('Rock', self, e=True) for _ in range(50)]
        self.enemy_spawn = tuple((Vector(i) for i in findRandomSpaceForUnits(self.tilemap, [i.size.cort() for i in enemies], (40, 10), 10)))
        self.units[:] = allies + enemies
        return self

    def vision(self, team='ally'):
        if self.allvision:
            return self.units
        crs = [(u.cords.x, u.cords.y-u.size.y/2, u.sight) for u in self.units if u.team == team and not u.dead]
        return [i for i in self.units if i.team == team or i.dead or not get_bit(i.status, 1) and circleCollMany(crs, i.hitbox()) or get_bit(i.status, 0)]

    def paint(self, sc, objs, odata):
        [sc.blit(self.sc[i][j], (x,y)) for i, j, x, y in self.mchunks]

        v = self.visions['ally']
        for b in v:
            b.blit(sc)

        projectiles_trash = []
        for i, a in enumerate(self.projectiles):
            anim = a.animate(sc)
            if anim is False:
                projectiles_trash.append(a)
        self.projectiles[:] = [a for a in self.projectiles if a not in projectiles_trash]

        sc.blits(((d.icon, (cords.x * self.tile_size + self.mp[0] - d.icon.get_width() // 2, cords.y * self.tile_size + self.mp[1] - d.icon.get_height())) for d,cords in self.dropped))

        for b in v:
            b.blit_dmgvs(sc)

        self.gui.blit(sc)

    def move_camera(self, pos):
        if self.camera_bind:
            self.camera, self.camera_bind_offset, self.mp, self.mchunks = getmp(pos, self.camera,
                         True, self.camera_bind.cords.cort(), self.camera_bind_offset,
                         self.tile_size, self.chunk_size_px, self.size.cort(), self.chunkmap_size.cort())
        else:
            self.camera, self.camera_bind_offset, self.mp, self.mchunks = getmp(pos, self.camera,
                         False, (0,0), self.camera_bind_offset, self.tile_size, self.chunk_size_px,
                         self.size.cort(), self.chunkmap_size.cort())

    def paint_bckgr(self, sc):
        sc.blit(self.bck, (0,0))
        if self.id == 0:
            return

    def play(self):
        aidx, eidx = 0, 0
        self.selected_unit = self.units[0] if self.units else None
        self.camera_bind = self.selected_unit if self.selected_unit else None
        self.camera_bind_offset = (0, 0)
        self.selected_skill = None
        self.selected_item = None
        for i,u in enumerate(self.units):
            if u.team == 'ally':
                u.cords = self.spawn[aidx]()
                aidx += 1
            elif u.team == 'enemy':
                u.cords = self.enemy_spawn[eidx]()
                eidx += 1

    def find_upper_space(self, unit, ofs=-0.1):
        ycord = unit.cords.y-unit.size.y+ofs
        if ycord < 0:
            return False
        ycord = int(ycord)
        for i in range(int(unit.cords.x-unit.size.x/2+0.25), int(unit.cords.x+unit.size.x/2-0.25)+1):
            if not self.tilemap[i][ycord] == 0:
                return False
        return True

    def find_under_space(self, unit, ofs=0.1):
        ycord = int(unit.cords.y+ofs)
        if ycord >= self.size.y:
            return False
        for i in range(int(unit.cords.x-unit.size.x/2+0.25), int(unit.cords.x+unit.size.x/2-0.25)+1):
            if not self.tilemap[i][ycord] == 0:
                return False
        return True

    def find_left_space(self, unit, ofs=-0.1):
        xcord = unit.cords.x-unit.size.x/2+ofs
        if xcord < 0:
            return False
        xcord = int(xcord)
        for j in range(int(unit.cords.y-unit.size.y+0.25), int(unit.cords.y-0.25)+1):
            if not self.tilemap[xcord][j] == 0:
                return False
        return True

    def find_right_space(self, unit, ofs=0.1):
        xcord = int(unit.cords.x+unit.size.x/2+ofs)
        if xcord >= self.size.x:
            return False
        for j in range(int(unit.cords.y-unit.size.y+0.25), int(unit.cords.y-0.25)+1):
            if not self.tilemap[xcord][j] == 0:
                return False
        return True

    def tick(self):
        self.ticks += 1
        if self.id > 0 and self.ticks % 360 == 0:
            self.save_terrain()
        if self.ticks % 5 == 0:
            for i in self.teams:
                self.visions[i] = self.vision(i)

    def generate_terrain(self):
        # start_time = time.time()
        height = 60
        pic = perlin_noise(5, self.size.x)
        self.tilemap = np.concatenate((np.zeros((1, height), 'int'), np.ones((1, self.size.y - height), 'int')), axis=1)
        for i in range(1, self.size.x):
            height += int(pic[i][0]*5)
            col = np.concatenate((np.zeros((1, height), 'int'), np.ones((1, self.size.y - height), 'int')), axis=1)
            self.tilemap = np.concatenate((self.tilemap, col), axis=0)
        # for i in range(self.size.x):
        #     for j in range(self.size.y):
        #         if pic[j][i] < 0:
        #             self.tilemap[i][j] = 1
        #         else:
        #             self.tilemap[i][j] = 0

        # plt.imshow(pic, cmap='gray')
        # plt.show()
        # print(time.time()-start_time)

    def save_terrain(self):
        fn = f'leveldata\\{self.id // 1000}-{self.id % 1000}'
        if 'editor' in self.kwargs and self.kwargs['editor']:
            fn += 'editor'
        forcenpsave(fn, self.tilemap)
        leveldata = ast.literal_eval(open('leveldata\\levels.txt', 'r', encoding='utf-8').read())
        if 'editor' not in self.kwargs:
            if self.id in leveldata:
                leveldata[self.id]['last_played'] = int(time.time())
            else:
                leveldata[self.id] = {'last_played': int(time.time())}
        forcesave(f'leveldata\\levels.txt', str(leveldata))

    def render_terrain(self):
        self.nsc = [[pygame.Surface((self.chunk_size * TILE_SIZE, self.chunk_size * TILE_SIZE), pygame.SRCALPHA, 32) for _ in range(self.chunkmap_size.y)] for _ in range(self.chunkmap_size.x)]
        for i in range(self.size.x):
            xcord = i % self.chunk_size * TILE_SIZE
            xchunk = i//self.chunk_size
            for j in range(self.size.y):
                ycord = j % self.chunk_size * TILE_SIZE
                ychunk = j // self.chunk_size
                # if self.tilemap[i][j] in Level.blocks_offset:
                #     offset = Level.blocks_offset[self.tilemap[i][j]]
                #     self.nsc.blit(Level.blocks[self.tilemap[i][j]]['tex'], (xcord + offset[0], ycord + offset[1]))
                # else:
                self.nsc[xchunk][ychunk].blit(Level.blocks[self.tilemap[i][j]]['tex'], (xcord, ycord))
        self.sc = [[j for j in i] for i in self.nsc]

    def update_chunk(self, cords):
        xchunk, ychunk = cords[0]//self.chunk_size, cords[1]//self.chunk_size
        usc = pygame.Surface((self.chunk_size * TILE_SIZE, self.chunk_size * TILE_SIZE), pygame.SRCALPHA, 32)
        for i in range(self.chunk_size):
            xcord = i * TILE_SIZE
            xtile = i + xchunk * self.chunk_size
            for j in range(self.chunk_size):
                ycord = j * TILE_SIZE
                ytile = i + ychunk * self.chunk_size
                # if tilemap[i][j] in Level.blocks_offset:
                #     offset = Level.blocks_offset[tilemap[i][j]]
                #     nsc.blit(Level.blocks[tilemap[i][j]]['tex'], (xcord + offset[0], ycord + offset[1]))
                # else:
                usc.blit(Level.blocks[self.tilemap[xtile][ytile]]['tex'], (xcord, ycord))
        self.nsc[xchunk][ychunk] = usc
        chunksize = int(self.chunk_size * TILE_SIZE * self.camera_scale)
        self.sc[xchunk][ychunk] = pygame.transform.scale(usc, (chunksize, chunksize))

    def drop_rescale(self):
        for i, _ in self.dropped:
            i.icon = pygame.transform.scale(Item.icons[i.name], (int(self.tile_size*0.7), int(self.tile_size*0.7)))

    def make_scale(self, scale=None):
        if scale is not None:
            self.camera_scale = scale
        self.tile_size = int(TILE_SIZE * self.camera_scale)
        self.chunk_size_px = self.tile_size * self.chunk_size
        self.sc = [[pygame.transform.scale(j, (self.chunk_size_px, self.chunk_size_px)) for j in i] for i in self.nsc]
        self.drop_rescale()

    def load_levelmap(self):
        levelid = search_last_level() // 1000
        with open('leveldata\\maps.txt', 'r', encoding='utf-8') as mapsfile:
            data = ast.literal_eval(mapsfile.read())
        planet, part = 'Earth', 1
        self.levelmap_tex = pygame.image.load(f'textures\\maps\\{planet}{part}.png').convert_alpha()
        for i in data['levels']:
            if i[0] == levelid:
                planet, part = i[1:3]
        levels = [i for i in data['levels'] if i[1] == planet and i[2] == part]
        anims = []
        for lvl in levels:
            if lvl[0] in self.runa.unlocked_levels:
                anims.append(Animation('button_level.png', (lvl[3][0]-15, lvl[3][1]-15), speed=1 / 60, duration=-1, button={'prs_name': 'button_level_pressed.png', 'folder': 'textures\\GUI', 'change_mode': 'ingame', 'changelevel': 1000*lvl[0]+1, 'particles': [Particles('sparkle', changexy=lambda o, x, y, i: (x - 15 / (i + 1), y - i // 2), pos='mouse_attach', spawn=0.3, random_offset=(-20, 0, -20, 20), random_scale=(0.6, 1.2), random_rotate=(0, 180), random_speed=(0.6, 1.2)), Particles('sparkle', changexy=lambda o, x, y, i: (x + 15 / (i + 1), y - i // 2), pos='mouse_attach', spawn=0.3, random_offset=(0, 20, -20, 20), random_scale=(0.6, 1.2), random_rotate=(0, 180), random_speed=(0.6, 1.2))]}, folder='textures\\GUI', single=True))
            else:
                anims.append(Animation('button_level_locked.png', (lvl[3][0]-15, lvl[3][1]-15), speed=1 / 60, duration=-1, folder='textures\\GUI', single=True))
        return anims

    def paint_levelmap_bckgr(self, sc):
        sc.blit(self.bck, (0,0))
        sc.blit(self.levelmap_tex, (0, 0))
        if self.id == 0:
            return

from config import *
from level import *
from animation import *
from unit import *
from runestone import *

pygame.init()
sc = pygame.display.set_mode(FULL_WINDOW, pygame.SCALED)
clock = pygame.time.Clock()

font30 = pygame.font.SysFont('calibri', 30)
font36 = pygame.font.SysFont('calibri', 36)

Item.init()
runa = Runa()
gui = GUI()
dialogs = Dialogs()
level = Level(0, runa, gui, dialogs).load()

animations = []
game_mode = ''


# TODO: меню инвентаря, руны, кузницы, синтезатора предметов и юнитов, переключение между ними по вкладкам сверху
#  в главном меню отображаются сегменты всей руны в уменьшенном масштабе, менять при изменении руны
def change_mode(mode, option=0):
    global animations
    global game_mode
    global level
    if game_mode == 'runestone':
        runa.save()

    if mode == 'mainmenu':
        animations = [Animation('name.png', NAME_POS, speed=1/54, start=random.randrange(6), scale=NAME_SIZES, duration=-1),
                      Animation('main.png', MAIN_GUI, speed=1/60, duration=-1, rotate=MAIN_CIRCLE_RSPEED, changexy=lambda o,x,y,i: (MAIN_CIRCLE[0]-o.get_width()//2, MAIN_CIRCLE[1]-o.get_height()//2), folder='textures\\GUI', single=True),
                      Animation('fire.png', MAIN_GUI, speed=1/60, duration=-1, scale=(0, 170), changexy=lambda o,x,y,i: (MAIN_CIRCLE[0]-o.get_width()//2+MAIN_CIRCLE[2]*math.cos(i*MAIN_ELEMENTS_RSPEED-2*math.pi/3), MAIN_CIRCLE[1]-o.get_height()//2+MAIN_CIRCLE[2]*math.sin(i*MAIN_ELEMENTS_RSPEED-2*math.pi/3)), folder='textures\\GUI', single=True),
                      Animation('dark.png', MAIN_GUI, speed=1/60, duration=-1, scale=(0, 130), changexy=lambda o,x,y,i: (MAIN_CIRCLE[0]-o.get_width()//2+MAIN_CIRCLE[2]*math.cos(i*MAIN_ELEMENTS_RSPEED-math.pi/3), MAIN_CIRCLE[1]-o.get_height()//2+MAIN_CIRCLE[2]*math.sin(i*MAIN_ELEMENTS_RSPEED-math.pi/3)), folder='textures\\GUI', single=True),
                      Animation('earth.png', MAIN_GUI, speed=1/60, duration=-1, scale=(0, 180), changexy=lambda o,x,y,i: (MAIN_CIRCLE[0]-o.get_width()//2+MAIN_CIRCLE[2]*math.cos(i*MAIN_ELEMENTS_RSPEED), MAIN_CIRCLE[1]-o.get_height()//2+MAIN_CIRCLE[2]*math.sin(i*MAIN_ELEMENTS_RSPEED)), folder='textures\\GUI', single=True),
                      Animation('water.png', MAIN_GUI, speed=1/60, duration=-1, scale=(0, 130), changexy=lambda o,x,y,i: (MAIN_CIRCLE[0]-o.get_width()//2+MAIN_CIRCLE[2]*math.cos(i*MAIN_ELEMENTS_RSPEED+math.pi/3), MAIN_CIRCLE[1]-o.get_height()//2+MAIN_CIRCLE[2]*math.sin(i*MAIN_ELEMENTS_RSPEED+math.pi/3)), folder='textures\\GUI', single=True),
                      Animation('light.png', MAIN_GUI, speed=1/60, duration=-1, scale=(0, 190), changexy=lambda o,x,y,i: (MAIN_CIRCLE[0]-o.get_width()//2+MAIN_CIRCLE[2]*math.cos(i*MAIN_ELEMENTS_RSPEED+2*math.pi/3), MAIN_CIRCLE[1]-o.get_height()//2+MAIN_CIRCLE[2]*math.sin(i*MAIN_ELEMENTS_RSPEED+2*math.pi/3)), folder='textures\\GUI', single=True),
                      Animation('air.png', MAIN_GUI, speed=1/60, duration=-1, scale=(180, 0), changexy=lambda o,x,y,i: (MAIN_CIRCLE[0]-o.get_width()//2+MAIN_CIRCLE[2]*math.cos(i*MAIN_ELEMENTS_RSPEED+math.pi), MAIN_CIRCLE[1]-o.get_height()//2+MAIN_CIRCLE[2]*math.sin(i*MAIN_ELEMENTS_RSPEED+math.pi)), folder='textures\\GUI', single=True),
                      Animation('button_play.png', MAIN_GUI, speed=1/60, duration=-1, changexy=lambda o,x,y,i: (MAIN_CIRCLE[0]-o.get_width()//2+BUTTON_PLAY_CIRCLE[0]*math.cos(i*MAIN_ELEMENTS_RSPEED-2*math.pi/3), MAIN_CIRCLE[1]-o.get_height()//2+BUTTON_PLAY_CIRCLE[0]*math.sin(i*MAIN_ELEMENTS_RSPEED-2*math.pi/3)), button={'prs_name': 'button_play_pressed.png', 'folder': 'textures\\GUI', 'change_mode': 'levelmap', 'particles': [Particles('sparkle', changexy=lambda o,x,y,i: (x-15/(i+1), y-i//2), pos='mouse_attach', spawn=0.3, random_offset=(-20, 0, -20, 20), random_scale=(0.6, 1.2), random_rotate=(0, 180), random_speed=(0.6, 1.2)), Particles('sparkle', changexy=lambda o,x,y,i: (x+15/(i+1), y-i//2), pos='mouse_attach', spawn=0.3, random_offset=(0, 20, -20, 20), random_scale=(0.6, 1.2), random_rotate=(0, 180), random_speed=(0.6, 1.2))]}, folder='textures\\GUI', single=True),
                      Animation('button_inventory.png', MAIN_GUI, speed=1/60, duration=-1, changexy=lambda o,x,y,i: (MAIN_CIRCLE[0]-o.get_width()//2+BUTTON_PLAY_CIRCLE[0]*math.cos(i*MAIN_ELEMENTS_RSPEED-1*math.pi/3), MAIN_CIRCLE[1]-o.get_height()//2+BUTTON_PLAY_CIRCLE[0]*math.sin(i*MAIN_ELEMENTS_RSPEED-1*math.pi/3)), button={'prs_name': 'button_inventory_pressed.png', 'folder': 'textures\\GUI', 'change_mode': 'inventory', 'particles': [Particles('sparkle', changexy=lambda o,x,y,i: (x-15/(i+1), y-i//2), pos='mouse_attach', spawn=0.3, random_offset=(-20, 0, -20, 20), random_scale=(0.6, 1.2), random_rotate=(0, 180), random_speed=(0.6, 1.2)), Particles('sparkle', changexy=lambda o,x,y,i: (x+15/(i+1), y-i//2), pos='mouse_attach', spawn=0.3, random_offset=(0, 20, -20, 20), random_scale=(0.6, 1.2), random_rotate=(0, 180), random_speed=(0.6, 1.2))]}, folder='textures\\GUI', single=True),
                      Animation('button_rune.png', MAIN_GUI, speed=1/60, duration=-1, changexy=lambda o,x,y,i: (MAIN_CIRCLE[0]-o.get_width()//2+BUTTON_PLAY_CIRCLE[0]*math.cos(i*MAIN_ELEMENTS_RSPEED), MAIN_CIRCLE[1]-o.get_height()//2+BUTTON_PLAY_CIRCLE[0]*math.sin(i*MAIN_ELEMENTS_RSPEED)), button={'prs_name': 'button_rune_pressed.png', 'folder': 'textures\\GUI', 'change_mode': 'runestone', 'particles': [Particles('sparkle', changexy=lambda o,x,y,i: (x-15/(i+1), y-i//2), pos='mouse_attach', spawn=0.3, random_offset=(-20, 0, -20, 20), random_scale=(0.6, 1.2), random_rotate=(0, 180), random_speed=(0.6, 1.2)), Particles('sparkle', changexy=lambda o,x,y,i: (x+15/(i+1), y-i//2), pos='mouse_attach', spawn=0.3, random_offset=(0, 20, -20, 20), random_scale=(0.6, 1.2), random_rotate=(0, 180), random_speed=(0.6, 1.2))]}, folder='textures\\GUI', single=True),
                      Animation('button_smith.png', MAIN_GUI, speed=1/60, duration=-1, changexy=lambda o,x,y,i: (MAIN_CIRCLE[0]-o.get_width()//2+BUTTON_PLAY_CIRCLE[0]*math.cos(i*MAIN_ELEMENTS_RSPEED+1*math.pi/3), MAIN_CIRCLE[1]-o.get_height()//2+BUTTON_PLAY_CIRCLE[0]*math.sin(i*MAIN_ELEMENTS_RSPEED+1*math.pi/3)), button={'prs_name': 'button_smith_pressed.png', 'folder': 'textures\\GUI', 'change_mode': 'smith', 'particles': [Particles('sparkle', changexy=lambda o,x,y,i: (x-15/(i+1), y-i//2), pos='mouse_attach', spawn=0.3, random_offset=(-20, 0, -20, 20), random_scale=(0.6, 1.2), random_rotate=(0, 180), random_speed=(0.6, 1.2)), Particles('sparkle', changexy=lambda o,x,y,i: (x+15/(i+1), y-i//2), pos='mouse_attach', spawn=0.3, random_offset=(0, 20, -20, 20), random_scale=(0.6, 1.2), random_rotate=(0, 180), random_speed=(0.6, 1.2))]}, folder='textures\\GUI', single=True),
                      ]
    if mode == 'ingame':
        animations = []
        level = Level(option, runa, gui, dialogs).load()
        level.make_scale(0.81)
        level.play()
    if mode == 'levelmap':
        animations[:] = level.load_levelmap()
    if mode == 'inventory':
        animations = []
    if mode == 'runestone':
        animations = []
    if mode == 'smith':
        animations = []
    game_mode = mode


change_mode('mainmenu')
# change_mode('ingame')


while True:
    sc.fill(pygame.Color('white'))
    pos = pygame.mouse.get_pos()
    pressed = pygame.mouse.get_pressed()
    keys = pygame.key.get_pressed()

    for event in pygame.event.get():
        if event.type == pygame.QUIT:
            exit()
        if event.type == pygame.KEYDOWN:
            if event.key == pygame.K_ESCAPE:
                if game_mode == 'ingame':
                    change_mode('levelmap')
                elif game_mode == 'levelmap':
                    change_mode('mainmenu')
                elif game_mode == 'inventory':
                    change_mode('mainmenu')
                elif game_mode == 'runestone':
                    change_mode('mainmenu')
                elif game_mode == 'smith':
                    change_mode('mainmenu')
                elif game_mode == 'mainmenu':
                    exit()
            if game_mode == 'ingame':
                if level.selected_unit:
                    if event.key == pygame.K_SPACE:
                        level.selected_unit.jump()
                    if event.key == pygame.K_q:
                        level.selected_unit.cast(1)
                    if event.key == pygame.K_w:
                        level.selected_unit.cast(2)
                    if event.key == pygame.K_e:
                        level.selected_unit.cast(3)
                    if event.key == pygame.K_r:
                        level.selected_unit.cast(4)
                    if event.key == pygame.K_z:
                        select_prev_unit(level, pos)
                    if event.key == pygame.K_c:
                        select_next_unit(level, pos)
                if not level.selected_unit and level.units:
                    if event.key == pygame.K_z or event.key == pygame.K_c:
                        level.selected_unit = level.units[0]
                        level.selected_skill = None
                        level.selected_item = None
        if event.type == pygame.MOUSEBUTTONDOWN:
            if game_mode == 'ingame':  # TODO: сделать два варианта: игровой и отлодочный, буфер масштабов в словарь
                if event.button == 5:
                    if level.camera_scale > 0.2:
                        level.camera_scale *= 0.9
                        level.make_scale()
                elif event.button == 4:
                    if level.camera_scale < 5:
                        level.camera_scale /= 0.9
                        level.make_scale()
                else:
                    gui.fetch_click(event.button, pos)
            elif game_mode == 'runestone':
                if event.button == 1:
                    runa.hold_piece(pos)

        if event.type == pygame.MOUSEBUTTONUP:
            if game_mode == 'runestone':
                if runa.piece_lock and event.button == 1:
                    runa.place_piece(pos)

    if game_mode == 'mainmenu':
        level.paint_bckgr(sc)

    if game_mode == 'levelmap':
        level.paint_levelmap_bckgr(sc)

    if game_mode == 'runestone':
        level.paint_bckgr(sc)
        level.runa.paint_runestone(sc, pos)

    if game_mode == 'ingame':
        if level.selected_unit:
            if keys[pygame.K_a]:
                level.selected_unit.moveleft()
            if keys[pygame.K_d]:
                level.selected_unit.moveright()
            if keys[pygame.K_SPACE]:
                level.selected_unit.flyup()
            if keys[pygame.K_s]:
                level.selected_unit.flydown()
            if pressed[0]:
                level.selected_unit.attack()
        level.move_camera(pos)
        level.tick()
        for idx,u in enumerate(level.units):
            u.tick(sc, pos)
        level.paint(sc, (), ())
        sc.blit(font30.render(str(int(clock.get_fps())), True, (0, 0, 0)), (1850, 10))
        sc.blit(font30.render(str(round(level.camera_scale, 2)), True, (0, 0, 0)), (1750, 10))

    runa.tick()

    animations_trash = []
    for i,a in enumerate(animations):
        kw = {'pos': pos, 'pressed': pressed} if a.button else {}
        anim = a.animate(sc, **kw)
        if anim is False:
            animations_trash.append(a)
        elif anim:
            for k,v in anim.items():
                if k == 'change_mode':
                    change_mode(v['mode'], v['changelevel'])
    animations[:] = [a for a in animations if a not in animations_trash]

    pygame.display.flip()
    clock.tick(FPS)

class Map:
    textures = {i.split('.png')[0]: pygame.image.load(f'textures\\maps\\{i}') for i in os.listdir('textures\\maps') if i.endswith('.png')}

    def __init__(self):
        pass

planet = 'Earth'
part = 1
tex = pygame.image.load('textures\\maps\\Earth1.png')
data = ast.literal_eval(open(f'leveldata\\maps.txt', 'r', encoding='utf-8').read())

pygame.init()
sc = pygame.display.set_mode(WINDOW)

clock = pygame.time.Clock()
cur_point = (0, 0)
cur_num = 0
log = []
points = []
lines = []
new_mode = True
font = pygame.font.SysFont('calibri', 36)
text_mode = font.render('Last point binding [W]:', True, (0, 0, 0))
text_save = font.render('Save [Ctrl+S]', True, (0, 0, 0))
text_undo = font.render('Undo [Ctrl+Z]', True, (0, 0, 0))


def load():
    if planet in data['map_graphs'] and part in data['map_graphs'][planet]:
        ids_to_points = {}
        cur_id = 0
        for i in data['levels']:
            if i[1] == planet and i[2] == part:
                points.append(i[3])
                ids_to_points[i[0]] = cur_id
                cur_id += 1
        for i, j in data['map_graphs'][planet][part]:
            f1, f2 = False, False
            for k in data['levels']:
                if i == k[0] and k[1] == planet and k[2] == part:
                    f1 = True
                if j == k[0] and k[1] == planet and k[2] == part:
                    f2 = True
            if not f1 or not f2:
                continue
            lines.append((ids_to_points[i], ids_to_points[j]))


load()


def magnetify(pos):
    for p in points:
        if abs(p[0]-pos[0]) <= 20 and abs(p[1]-pos[1]) <= 20:
            return p
    return False


def save():
    points_to_ids = {}
    maxid = 1
    for i in data['levels']:
        if i[0] >= maxid:
            maxid = i[0]+1
    for i, p in enumerate(points):
        level = [maxid, planet, part, p]
        data['levels'].append(level)
        points_to_ids[i] = maxid
        maxid += 1
    if not planet in data['map_graphs']:
        data['map_graphs'][planet] = {}
    data['map_graphs'][planet][part] = [(points_to_ids[i], points_to_ids[j]) for i,j in lines]
    forcesave('leveldata\\maps.txt', data)
    print('Saved!')
    
    
while True:
    sc.fill(pygame.Color('white'))

    for event in pygame.event.get():
        if event.type == pygame.QUIT:
            exit()
        if event.type == pygame.KEYDOWN:
            if event.key == pygame.K_ESCAPE:
                exit()
            if event.key == pygame.K_w:
                new_mode = False if new_mode else True
            if points:
                if event.key == pygame.K_a or event.key == pygame.K_LEFT:
                    cur_num = points.index(cur_point)
                    if cur_num == 0:
                        cur_num = len(points)
                        cur_point = points[-1]
                    else:
                        cur_point = points[cur_num - 1]
                    new_mode = False
                if event.key == pygame.K_d or event.key == pygame.K_RIGHT:
                    cur_num = points.index(cur_point) + 2
                    if cur_num > len(points):
                        cur_num = 1
                        cur_point = points[0]
                    else:
                        cur_point = points[cur_num - 1]
                    new_mode = False
            if event.key == pygame.K_z and pygame.KMOD_CTRL:
                if log[-1] == 2:
                    del lines[-1]
                del points[-1]
                del log[-1]
                if not points:
                    cur_point = (0, 0)
                    cur_num = 0
                elif cur_point not in points:
                    cur_num = len(points)
                    cur_point = points[-1]
            if event.key == pygame.K_s and pygame.KMOD_CTRL:
                save()
    sc.blit(tex, (0, 0))
    pos = pygame.mouse.get_pos()
    pressed = pygame.mouse.get_pressed()
    magnet = magnetify(pos)

    if pressed[0]:
        if not magnet:
            points.append((pos[0], pos[1]))
            if cur_num:
                if new_mode:
                    lines.append((points.index(points[-2]), points.index(pos)))
                else:
                    lines.append((points.index(cur_point), points.index(pos)))
                log.append(2)
            else:
                log.append(1)
            if new_mode or not cur_num:
                cur_point = (pos[0], pos[1])
                cur_num = len(points)

    if cur_num:
        if new_mode:
            if magnet:
                pygame.draw.aaline(sc, YELLOW, points[-1], magnet)
            else:
                pygame.draw.aaline(sc, YELLOW, points[-1], pos)
        else:
            if magnet:
                pygame.draw.aaline(sc, YELLOW, cur_point, magnet)
            else:
                pygame.draw.aaline(sc, YELLOW, cur_point, pos)
    for l in lines:
        p1, p2 = points[l[0]], points[l[1]]
        pygame.draw.aaline(sc, YELLOW, p1, p2)
    for p in points:
        if (p == cur_point and not new_mode) or (p == points[-1] and new_mode):
            pygame.draw.circle(sc, GREEN, p, 10, 2)
        else:
            pygame.draw.circle(sc, YELLOW, p, 10, 2)
    if magnet:
        pygame.draw.rect(sc, BLUE, (magnet[0] - 10, magnet[1] - 10, 20, 20))
    else:
        pygame.draw.rect(sc, BLUE, (pos[0]-10, pos[1]-10, 20, 20))
    sc.blit(text_mode, (1000, 100))
    sc.blit(text_save, (1000, 150))
    sc.blit(text_undo, (1000, 200))
    text_mode_toogle_color = GREEN if new_mode else RED
    text_mode_toogle = font.render(str(new_mode), True, text_mode_toogle_color)
    sc.blit(text_mode_toogle, (1340, 100))

    pygame.display.flip()
    clock.tick(FPS)

from config import *


class Vector:
    def __init__(self, x=0, y=0):
        if isinstance(x, (list, tuple)):
            self.x, self.y = x
            return
        self.x = x
        self.y = y

    def __call__(self):
        return Vector(self.x, self.y)

    def getlen(self):
        return math.sqrt(self.x**2+self.y**2)

    def setlen(self, l):
        self.normalize()
        self.x *= l
        self.y *= l

    def normalize(self):
        l = self.getlen()
        self.x /= l
        self.y /= l

    def cort(self):
        return self.x, self.y

    def toint(self):
        self.x = int(self.x)
        self.y = int(self.y)
        return self

    def angle(self):
        nvec = self()
        nvec.normalize()
        ang = math.asin(-nvec.y)
        ang = math.pi - ang if nvec.x < 0 else ang
        return ang

    def __add__(self, other):
        return Vector(self.x+other.x, self.y+other.y)

    def __sub__(self, other):
        return Vector(self.x-other.x, self.y-other.y)

    def __eq__(self, other):
        if self.x == other.x and self.y == other.y:
            return True
        return False

    def __gt__(self, other):
        if self.getlen() > other.getlen():
            return True
        return False

    def __mul__(self, other):
        return Vector(self.x*other, self.y*other)

    def __truediv__(self, other):
        return Vector(self.x/other, self.y/other)

    def __floordiv__(self, other):
        return Vector(self.x//other, self.y//other)

    def __str__(self):
        return f'({self.x}, {self.y})'


class Provides:
    def __init__(self, *args):
        self.provides, self.values = tuple(zip(*args)) or ((), ())

    def __contains__(self, item):
        if item in self.provides:
            return True
        return False

    def __getitem__(self, item):
        return self.values[self.provides.index(item)]

    def __call__(self):
        res = Provides()
        res.provides = self.provides
        res.values = self.values
        return res

    def __mul__(self, other):
        res = Provides()
        res.provides = self.provides
        res.values = tuple((i*other for i in self.values))
        return res


class DamageTable:
    bigkeys = ('normal', 'air', 'water', 'fire', 'earth', 'dark', 'light')
    keys = ('n', 'a', 'w', 'f', 'e', 'd', 'l')

    def __init__(self, n=0, a=0, w=0, f=0, e=0, d=0, l=0):
        if isinstance(n, str):
            if n.isdigit():
                n = float(n)
            else:    # Эта штука не принимает дробные числа из файла
                dl = re.findall(r'\d+n|\d+a|\d+w|\d+f|\d+e|\d+d|\d+l', n)
                n = 0
                for i in dl:
                    if 'n' in i:
                        n = int(i.split('n')[0])
                    if 'a' in i:
                        a = int(i.split('a')[0])
                    if 'w' in i:
                        w = int(i.split('w')[0])
                    if 'f' in i:
                        f = int(i.split('f')[0])
                    if 'e' in i:
                        e = int(i.split('e')[0])
                    if 'd' in i:
                        d = int(i.split('d')[0])
                    if 'l' in i:
                        l = int(i.split('l')[0])
        self.values = (n, a, w, f, e, d, l)

    def __call__(self):
        return DamageTable(*self.values)

    def __getitem__(self, item):
        if item in DamageTable.keys:
            return self.values[DamageTable.keys.index(item)]
        return self.values[DamageTable.bigkeys.index(item)]

    def __iter__(self):
        self.a = -1
        return self

    def __next__(self):
        if self.a < 6:
            self.a += 1
            return DamageTable.keys[self.a], self.values[self.a]
        else:
            raise StopIteration

    def __add__(self, other):
        if isinstance(other, DamageTable):
            return DamageTable(*tuple((v+other[i] for i,v in self)))
        return DamageTable(*tuple((i+other for i in self.values)))

    def __mul__(self, other):
        if isinstance(other, DamageTable):
            return DamageTable(*tuple((v*other[i] for i,v in self)))
        return DamageTable(*tuple((i*other for i in self.values)))

    def __truediv__(self, other):
        if isinstance(other, DamageTable):
            return DamageTable(*tuple((v/other[i] for i,v in self)))
        return DamageTable(*tuple((i/other for i in self.values)))

    def __gt__(self, other):
        if self.sum() > other.sum():
            return True
        return False

    def __str__(self):
        return f'DamageTable{self.values}'

    def sum(self):
        return sum(self.values)

    def add(self, value, key):
        values = list(self.values)
        if key in DamageTable.keys:
            values[DamageTable.keys.index(key)] += value
        else:
            values[DamageTable.bigkeys.index(key)] += value
        self.values = tuple(values)


class UnitStats:
    def __init__(self):
        self.shoots = 0
        self.hits = 0
        self.received_hits = 0
        self.dist = 0
        self.flydist = 0
        self.jumps = 0
        self.kills = 0
        self.deaths = 0
        self.casts = 0
        self.ultimates = 0
        self.damage = 0
        self.raw_damage = 0
        self.blocked_damage = 0
        self.received_damage = 0

    def __str__(self):
        return f'shoots={self.shoots}, hits={self.hits}, jumps={self.jumps}, dist={self.dist}, kills={self.kills}, casts={self.casts}, dmg={self.damage}, raw={self.raw_damage}'

    def load(self, data):
        self.shoots = data[0]
        self.hits = data[1]
        self.received_hits = data[2]
        self.dist = data[3]
        self.flydist = data[4]
        self.jumps = data[5]
        self.kills = data[6]
        self.deaths = data[7]
        self.casts = data[8]
        self.ultimates = data[9]
        self.damage = data[10]
        self.raw_damage = data[11]
        self.blocked_damage = data[12]
        self.received_damage = data[13]

    def save(self):
        return [self.shoots, self.hits, self.received_hits, self.dist, self.flydist, self.jumps, self.kills,
                self.deaths, self.casts, self.ultimates, self.damage, self.raw_damage, self.blocked_damage,
                self.received_damage]


class GameStats:
    def __init__(self):
        self.shoots = defaultdict(int)
        self.hits = defaultdict(int)
        self.received_hits = defaultdict(int)
        self.dist = defaultdict(int)
        self.flydist = defaultdict(int)
        self.jumps = defaultdict(int)
        self.kills = defaultdict(int)
        self.deaths = defaultdict(int)
        self.casts = defaultdict(int)
        self.ultimates = defaultdict(int)
        self.damage = defaultdict(int)
        self.raw_damage = defaultdict(int)
        self.blocked_damage = defaultdict(int)
        self.received_damage = defaultdict(int)

    def __str__(self):
        team = 'ally'
        return f'shoots={self.shoots[team]}, hits={self.hits[team]}, jumps={self.jumps[team]}, dist={self.dist[team]}, kills={self.kills[team]}, casts={self.casts[team]}, dmg={self.damage[team]}, raw={self.raw_damage[team]}'

    def load(self, data):
        for k, v in data.items():
            self.shoots[k] = v[0]
            self.hits[k] = v[1]
            self.received_hits[k] = v[2]
            self.dist[k] = v[3]
            self.flydist[k] = v[4]
            self.jumps[k] = v[5]
            self.kills[k] = v[6]
            self.deaths[k] = v[7]
            self.casts[k] = v[8]
            self.ultimates[k] = v[9]
            self.damage[k] = v[10]
            self.raw_damage[k] = v[11]
            self.blocked_damage[k] = v[12]
            self.received_damage[k] = v[13]
        return self

    def save(self):
        return {k: [self.shoots[k], self.hits[k], self.received_hits[k], self.dist[k], self.flydist[k], self.jumps[k],
                    self.kills[k], self.deaths[k], self.casts[k], self.ultimates[k], self.damage[k], self.raw_damage[k],
                    self.blocked_damage[k], self.received_damage[k]] for k in self.dist.keys()}

    def shoot(self, unit):
        self.shoots[unit.team] += 1
        unit.stats.shoots += 1

    def hit(self, unit_from, unit_to):
        self.hits[unit_from.team] += 1
        unit_from.stats.hits += 1
        self.received_hits[unit_to.team] += 1
        unit_to.stats.received_hits += 1

    def move(self, unit, dist):
        self.dist[unit.team] += dist
        unit.stats.dist += dist
        if unit.canfly:
            self.flydist[unit.team] += dist
            unit.stats.flydist += dist

    def jump(self, unit):
        self.jumps[unit.team] += 1
        unit.stats.jumps += 1

    def dmg(self, unit_from, unit_to, value, raw_value):
        self.damage[unit_from.team] += value
        unit_from.stats.damage += value
        self.raw_damage[unit_from.team] += raw_value
        unit_from.stats.raw_damage += raw_value
        self.received_damage[unit_to.team] += value
        unit_to.stats.received_damage += value
        self.blocked_damage[unit_to.team] += raw_value - value
        unit_to.stats.blocked_damage += raw_value - value

    def dead(self, unit_from, unit_to):
        self.kills[unit_from.team] += 1
        unit_from.stats.kills += 1
        self.deaths[unit_to.team] += 1
        unit_to.stats.deaths += 1

    def cast(self, unit, ability):
        self.casts[unit.team] += 1
        unit.stats.casts += 1
        if ability.ultimate:
            self.ultimates[unit.team] += 1
            unit.stats.ultimates += 1


class Projectile:
    textures = {i.split('.png')[0]: pygame.image.load('textures\\projectiles\\'+i).convert_alpha() for i in os.listdir('textures\\projectiles')}
    anims = {a: tuple((pygame.image.load(f'textures\\proj_anims\\{a}\\{i}').convert_alpha() for i in os.listdir(f'textures\\proj_anims\\{a}'))) for a in os.listdir(f'textures\\proj_anims')}

    def __init__(self, caster, ability, spawn_point, fspeed, tex, **kwargs):
        self.caster = caster
        self.ability = ability
        self.level = self.caster.level
        self.units = self.caster.units
        self.spawn_point = spawn_point
        self.pos = spawn_point()
        self.distance = 0
        self.speed = fspeed
        self.accel = kwargs['accel'] if 'accel' in kwargs else Vector(0, GRAVITY)
        self.tex = Projectile.textures[tex].copy()
        self.ticks = 0
        self.collisions = []
        self.collision_cd = kwargs['collision_cd'] if 'collision_cd' in kwargs else FPS
        self.destroyed = False
        self.stopped = False
        if 'size' in kwargs:
            self.size = kwargs['size']*TILE_SIZE
            self.size.toint()
            self.tex = pygame.transform.scale(self.tex, self.size.cort())
        else:
            self.size = Vector(self.tex.get_width(), self.tex.get_height())
        self.duration = kwargs['duration'] if 'duration' in kwargs else 0
        self.baseduration = self.duration
        self.stopbyUnitCollisions = kwargs['stopbyUnitCollisions'] if 'stopbyUnitCollisions' in kwargs else 0
        self.stopbyMapCollisions = kwargs['stopbyMapCollisions'] if 'stopbyMapCollisions' in kwargs else 0
        self.destroybyUnitCollisions = kwargs['destroybyUnitCollisions'] if 'destroybyUnitCollisions' in kwargs else 0
        self.destroybyMapCollisions = kwargs['destroybyMapCollisions'] if 'destroybyMapCollisions' in kwargs else 0
        self.ricochetbyUnitCollisions = kwargs['ricochetbyUnitCollisions'] if 'ricochetbyUnitCollisions' in kwargs else 0
        self.ricochetbyMapCollisions = kwargs['ricochetbyMapCollisions'] if 'ricochetbyMapCollisions' in kwargs else 0

        self.destroyAnimation = []
        if 'destroyAnimation' in kwargs:
            self.destroyAnimation = Projectile.anims[kwargs['destroyAnimation']]

    def animate(self, sc):
        if self.destroyed is False:
            tex = self.tex
            if not self.stopped:
                oldpos = self.pos
                self.speed += self.accel
                self.pos += self.speed
                dv = self.pos - oldpos
                self.distance += dv.getlen()
                if self.speed.x or self.speed.y:
                    ang = math.asin(self.speed.y / self.speed.getlen())
                    ang = math.pi - ang if self.speed.x < 0 else ang
                    ang = ang/math.pi*180
                    tex = pygame.transform.rotate(self.tex, ang)
            tex = pygame.transform.scale(tex, (int(tex.get_width() * self.level.camera_scale), int(tex.get_height() * self.level.camera_scale)))
            sc.blit(tex, (self.pos.x*self.level.tile_size+self.level.mp[0]-tex.get_width()//2, self.pos.y*self.level.tile_size+self.level.mp[1]-tex.get_height()//2))
            self.collide(tex)
            self.ticks += 1
            if self.duration > 0 and self.ticks > self.duration * FPS:
                self.destroyed = True
        else:
            if self.destroyed is True:
                self.destroyed = -1
                self.ability.onProjectileDestroy(self)
            self.destroyed += 1
            if self.destroyed >= len(self.destroyAnimation):
                return False
            if not self.stopped:
                oldpos = self.pos
                self.speed += self.accel
                self.pos += self.speed
                dv = self.pos - oldpos
                self.distance += dv.getlen()
            tex = self.destroyAnimation[self.destroyed]
            tex = pygame.transform.scale(tex, self.size.cort())
            self.collide(tex)
            self.ticks += 1
            tex = pygame.transform.scale(tex, (int(tex.get_width() * self.level.camera_scale), int(tex.get_height() * self.level.camera_scale)))
            sc.blit(tex, (self.pos.x * self.level.tile_size + self.level.mp[0] - tex.get_width() // 2, self.pos.y * self.level.tile_size + self.level.mp[1] - tex.get_height() // 2))

    def collide(self, tex):
        box = (self.pos.x-tex.get_width()/4/TILE_SIZE, self.pos.x+tex.get_width()/4/TILE_SIZE, self.pos.y-tex.get_height()/4/TILE_SIZE, self.pos.y+tex.get_height()/4/TILE_SIZE)
        # left right top bottom
        if box[0] < 0 or box[1] >= self.level.size.x or box[2] < 0 or box[3] >= self.level.size.y:
            if self.destroyed is False:
                self.destroyed = True
            self.stopped = True
            return
        if self.destroyed is False:
            for i in self.units:
                if box[0] < i.cords.x+i.size.x/2 and box[1] > i.cords.x-i.size.x/2 and box[2] < i.cords.y and box[3] > i.cords.y-i.size.y:
                    f = True
                    for u, t in self.collisions:
                        if self.ticks - t < self.collision_cd and u == i:
                            f = False
                            break
                    if not f:
                        continue
                    unitcoll = self.ability.onProjectileHit(self, i)
                    if unitcoll:
                        self.collisions.append((i, self.ticks))
                        if self.stopbyUnitCollisions and len(self.collisions) >= self.stopbyUnitCollisions:
                            self.stopped = True
                        if self.ricochetbyUnitCollisions and len(self.collisions) % self.ricochetbyUnitCollisions == 0:
                            self.ricochetbyUnitCollisions -= 1
                            self.speed = Vector(-self.speed.x, -self.speed.y)
                        if self.destroyed is False and self.destroybyUnitCollisions and len(self.collisions) >= self.destroybyUnitCollisions:
                            self.destroyed = True
                            break
        mapcollision = False
        if not self.level.tilemap[int(box[0])][int(box[2])] == 0:
            mapcollision = (int(box[0]), int(box[2]))
        if not self.level.tilemap[int(box[1])][int(box[2])] == 0:
            mapcollision = (int(box[1]), int(box[2]))
        if not self.level.tilemap[int(box[0])][int(box[3])] == 0:
            mapcollision = (int(box[0]), int(box[3]))
        if not self.level.tilemap[int(box[1])][int(box[3])] == 0:
            mapcollision = (int(box[1]), int(box[3]))
        if not mapcollision is False:
            self.ability.onProjectileCollide(self, mapcollision)
            if self.destroyed is False and self.destroybyMapCollisions:
                self.destroybyMapCollisions -= 1
                if self.destroybyMapCollisions == 0:
                    self.destroyed = True
            if self.stopbyMapCollisions:
                self.stopbyMapCollisions -= 1
                if self.stopbyMapCollisions == 0:
                    self.stopped = True
            if self.ricochetbyMapCollisions:
                self.ricochetbyMapCollisions -= 1
                self.speed = Vector(-self.speed.x, -self.speed.y)

import ast
import numpy as np

from config import *
from unit import *


def search_last_player_data():
    maxlptime = 0
    data = None
    name = None
    rune = None
    for p in os.listdir(f'saves'):
        if p.endswith('.txt') and p.split('.txt')[0] + '.npy' in os.listdir(f'saves'):
            file = ast.literal_eval(open(f'saves\\{p}', 'r', encoding='utf-8').read())
            lptime = file['last_played']
            if lptime > maxlptime:
                maxlptime = lptime
                data = file
                name = p.split('.txt')[0]
                rune = np.load(f'saves\\{p.split(".txt")[0]}.npy')
    if data is None:
        data = {'units': [], 'inventory': [[]], 'storage': [[]], 'player_exp': 0, 'last_played': int(time.time()), 'stats': {}, 'pieces': [], 'unlocked_levels': [1]}
        name = alphanum_random(6)
        forcesave(f'saves\\{name}.txt', str(data))
        rune = np.zeros((22, 22), 'int')
        forcenpsave(f'saves\\{name}', rune)
    return data, name, rune


class Piece:
    def __init__(self, data):
        self.name = data[0]
        self.id = data[1]
        self.icon = pygame.image.load(f'pieces\\{self.id}.png')
        self.part = data[2]
        self.connections = data[3]
        if self.part == 'verb':
            self.text_name = data[4]


class Runa:
    pieces = {d[1]: Piece(d) for d in ast.literal_eval(open('pieces\\pieces.txt', 'r', encoding='utf-8').read())}
    checks = ((0, 1), (-1, 0), (0, -1), (1, 0), (-1, 1), (1, 1), (-1, -1), (1, -1))

    def __init__(self):
        self.level = None
        self.runestone_rune = pygame.image.load(f'textures\\GUI\\runestone_rune.png').convert_alpha()
        self.runestone_pieces = pygame.image.load(f'textures\\GUI\\runestone_pieces.png').convert_alpha()

        data, self.name, self.runestone = search_last_player_data()
        self.size = self.runestone.shape
        self.tile_size = min([RUNESTONE_SIZE[1]//(self.size[0]-1), RUNESTONE_SIZE[0]//(self.size[1]-1)])
        self.sc = pygame.Surface((self.tile_size*(self.size[1]-1)+10, self.tile_size*(self.size[0]-1)+10), pygame.SRCALPHA, 32)
        self.runestone_rune_scaled = pygame.transform.scale(self.runestone_rune, (self.tile_size*(self.size[1]-1)+20, self.tile_size*(self.size[0]-1)+20))
        [pygame.draw.aaline(self.sc, BLACK, (0, (i+0.5)*self.tile_size+5), (self.sc.get_width(), (i+0.5)*self.tile_size+5)) for i in range(self.size[0])]
        [pygame.draw.aaline(self.sc, BLACK, ((i+0.5)*self.tile_size+5, 0), ((i+0.5)*self.tile_size+5, self.sc.get_height())) for i in range(self.size[1])]

        self.units = data['units']
        self.inventory = data['inventory']
        self.storage = data['storage']
        self.exp = data['player_exp']
        self.stats = GameStats().load(data['stats'])
        self.pieces = data['pieces']
        self.unlocked_levels = data['unlocked_levels']
        self.ticks = 0
        self.piece_lock = None
        self.piece_lock_return = None
        self.piece_lock_pos = None

    def load(self, level):
        self.level = level
        self.inventory = [[Item.load(self.level, j) for j in i] for i in self.inventory]

    def save(self):
        self.units = [u.save() for u in self.level.units if u.game_id]
        maxlpdata = {'units': self.units, 'inventory': [[j.save() for j in i] for i in self.inventory], 'storage': self.storage, 'player_exp': self.exp, 'last_played': int(time.time()), 'stats': self.stats.save(), 'pieces': self.pieces, 'unlocked_levels': self.unlocked_levels}
        forcesave(f'saves\\{self.name}.txt', str(maxlpdata))
        forcenpsave(f'saves\\{self.name}', self.runestone)

    def paint_runestone(self, sc, pos):
        sc.blit(self.runestone_rune_scaled, RUNESTONE_RUNE)
        sc.blit(self.runestone_pieces, RUNESTONE_PIECES)
        sc.blit(self.sc, RUNESTONE_MAP)
        for i, p in enumerate(self.pieces):
            piece = pygame.transform.scale(Runa.pieces[p].icon, RUNESTONE_PIECE)
            d, m = divmod(i, 5)
            sc.blit(piece, (RUNESTONE_PIECE_FIRST[0]+m*RUNESTONE_PIECE[0]+(m-1)*RUNESTONE_PIECE_GAP, RUNESTONE_PIECE_FIRST[1]+d*RUNESTONE_PIECE[0]+(d-1)*RUNESTONE_PIECE_GAP))
        for i in range(self.size[0]):
            for j in range(self.size[1]):
                if self.runestone[i][j] > 0:
                    piece = pygame.transform.scale(Runa.pieces[self.runestone[i][j]].icon, (3*self.tile_size, 3*self.tile_size))
                    sc.blit(piece, (RUNESTONE_MAP[0]+(j-1.5)*self.tile_size+5, RUNESTONE_MAP[1]+(i-1.5)*self.tile_size+5))
        if self.piece_lock:
            piece = pygame.transform.scale(Runa.pieces[self.piece_lock].icon, RUNESTONE_PIECE)
            sc.blit(piece, (pos[0]-piece.get_width()//2, pos[1]-piece.get_height()//2))

    def hold_piece(self, pos):
        if RUNESTONE_PIECES[0] < pos[0] < RUNESTONE_PIECES_END[0] and RUNESTONE_PIECES[1] < pos[1] < RUNESTONE_PIECES_END[1]:
            for i, p in enumerate(self.pieces):
                d, m = divmod(i, 5)
                cords = (RUNESTONE_PIECE_FIRST[0] + m * RUNESTONE_PIECE[0] + (m - 1) * RUNESTONE_PIECE_GAP, RUNESTONE_PIECE_FIRST[1] + d * RUNESTONE_PIECE[0] + (d - 1) * RUNESTONE_PIECE_GAP)
                if cords[0] < pos[0] < cords[0]+RUNESTONE_PIECE[0] and cords[1] < pos[1] < cords[1]+RUNESTONE_PIECE[1]:
                    self.piece_lock = p
                    self.piece_lock_return = True
                    self.piece_lock_pos = True
                    self.pieces.remove(self.piece_lock)
                    return
        if RUNESTONE_MAP[0] < pos[0] < RUNESTONE_MAP[0]+self.tile_size*(self.size[1]-1)+10 and RUNESTONE_MAP[1] < pos[1] < RUNESTONE_MAP[1]+self.tile_size*(self.size[0]-1)+10:
            i, j = int(((pos[1]-RUNESTONE_MAP[1]-5)/self.tile_size)+0.5), int(((pos[0]-RUNESTONE_MAP[0]-5)/self.tile_size)+0.5)
            i, j = self.find_piece(i, j)
            if i is not False:
                self.piece_lock = self.runestone[i][j]
                self.piece_lock_return = True
                self.piece_lock_pos = i, j
                self.runestone[i][j] = 0
                for oi, oj in Runa.checks:
                    si, sj = i + oi, j + oj
                    self.runestone[si][sj] = 0

    def place_piece(self, pos):
        if RUNESTONE_MAP[0] < pos[0] < RUNESTONE_MAP[0]+self.tile_size*(self.size[1]-1)+10 and RUNESTONE_MAP[1] < pos[1] < RUNESTONE_MAP[1]+self.tile_size*(self.size[0]-1)+10:
            i, j = int(((pos[1]-RUNESTONE_MAP[1]-5)/self.tile_size)+0.5), int(((pos[0]-RUNESTONE_MAP[0]-5)/self.tile_size)+0.5)
            i, j = self.check_place_for_piece(i, j)
            if i is not False:
                i, j = self.expand_runestone(i, j)
                self.runestone[i][j] = self.piece_lock
                self.piece_lock_return = False
                for oi, oj in Runa.checks:
                    si, sj = i + oi, j + oj
                    self.runestone[si][sj] = -1
        if self.piece_lock_return is True:
            if self.piece_lock_pos is True:
                self.pieces.append(self.piece_lock)
            else:
                i, j = self.piece_lock_pos
                i, j = self.expand_runestone(i, j)
                self.runestone[i][j] = self.piece_lock
                self.piece_lock_return = False
                for oi, oj in Runa.checks:
                    si, sj = i + oi, j + oj
                    self.runestone[si][sj] = -1
            self.piece_lock_return = None
        self.contract_runestone()
        self.piece_lock = None
        self.piece_lock_pos = None

    def check_place_for_piece(self, i, j):
        if self.runestone[i][j]:
            return False, False
        colls = []
        for oi, oj in Runa.checks:
            si, sj = i+oi, j+oj
            if si < 0 or sj < 0 or si >= self.size[0] or sj >= self.size[1]:
                continue
            if self.runestone[si][sj]:
                colls.append((si, sj))
        if colls:
            i, j = self.check_place_for_piece(colls[0][0], colls[0][1])
        return i, j

    def find_piece(self, i, j):
        if not self.runestone[i][j]:
            return False, False
        if self.runestone[i][j] > 0:
            return i, j
        for oi, oj in Runa.checks:
            si, sj = i + oi, j + oj
            if si < 0 or sj < 0 or si >= self.size[0] or sj >= self.size[1]:
                continue
            if self.runestone[si][sj] > 0:
                return si, sj
        return False, False

    def expand_runestone(self, i, j):
        oldsize = self.size
        if i < 2:
            self.runestone = np.concatenate((np.zeros((2 - i, self.size[1]), 'int'), self.runestone), axis=0)
            self.size = self.runestone.shape
            i = 2
        if j < 2:
            self.runestone = np.concatenate((np.zeros((self.size[0], 2 - j), 'int'), self.runestone), axis=1)
            self.size = self.runestone.shape
            j = 2
        if i > self.size[0]-3:
            self.runestone = np.concatenate((self.runestone, np.zeros((i - self.size[0] + 3, self.size[1]), 'int')), axis=0)
            self.size = self.runestone.shape
        if j > self.size[1]-3:
            self.runestone = np.concatenate((self.runestone, np.zeros((self.size[0], j - self.size[1] + 3), 'int')), axis=1)
            self.size = self.runestone.shape
        if self.size != oldsize:
            self.tile_size = min([RUNESTONE_SIZE[1] // (self.size[0] - 1), RUNESTONE_SIZE[0] // (self.size[1] - 1)])
            self.sc = pygame.Surface((self.tile_size * (self.size[1] - 1) + 10, self.tile_size * (self.size[0] - 1) + 10), pygame.SRCALPHA, 32)
            self.runestone_rune_scaled = pygame.transform.scale(self.runestone_rune, (self.tile_size * (self.size[1] - 1) + 20, self.tile_size * (self.size[0] - 1) + 20))
            [pygame.draw.aaline(self.sc, BLACK, (0, (i + 0.5) * self.tile_size + 5), (self.sc.get_width(), (i + 0.5) * self.tile_size + 5)) for i in range(self.size[0])]
            [pygame.draw.aaline(self.sc, BLACK, ((i + 0.5) * self.tile_size + 5, 0), ((i + 0.5) * self.tile_size + 5, self.sc.get_height())) for i in range(self.size[1])]
        return i, j

    def contract_runestone(self, rec=False):
        oldsize = self.size
        if self.size[1] > 22 and not any((i[1] for i in self.runestone)):
            self.runestone = np.delete(self.runestone, 1, axis=1)
            self.size = self.runestone.shape
            self.contract_runestone(True)
        if self.size[0] > 22 and not any(self.runestone[1]):
            self.runestone = np.delete(self.runestone, 1, axis=0)
            self.size = self.runestone.shape
            self.contract_runestone(True)
        if self.size[1] > 22 and not any((i[-2] for i in self.runestone)):
            self.runestone = np.delete(self.runestone, -2, axis=1)
            self.size = self.runestone.shape
            self.contract_runestone(True)
        if self.size[0] > 22 and not any(self.runestone[-2]):
            self.runestone = np.delete(self.runestone, -2, axis=0)
            self.size = self.runestone.shape
            self.contract_runestone(True)
        if not rec and self.size != oldsize:
            self.tile_size = min([RUNESTONE_SIZE[1] // (self.size[0] - 1), RUNESTONE_SIZE[0] // (self.size[1] - 1)])
            self.sc = pygame.Surface((self.tile_size * (self.size[1] - 1) + 10, self.tile_size * (self.size[0] - 1) + 10), pygame.SRCALPHA, 32)
            self.runestone_rune_scaled = pygame.transform.scale(self.runestone_rune, (self.tile_size * (self.size[1] - 1) + 20, self.tile_size * (self.size[0] - 1) + 20))
            [pygame.draw.aaline(self.sc, BLACK, (0, (i + 0.5) * self.tile_size + 5), (self.sc.get_width(), (i + 0.5) * self.tile_size + 5)) for i in range(self.size[0])]
            [pygame.draw.aaline(self.sc, BLACK, ((i + 0.5) * self.tile_size + 5, 0), ((i + 0.5) * self.tile_size + 5, self.sc.get_height())) for i in range(self.size[1])]

    def tick(self): # TODO: Надписи о словах на основе dmgvs
        self.ticks += 1
        if self.ticks % 3600 == 0:
            self.save()

    def load_units(self):
        return [Unit(u[0], self.level).load(*u[1:]) for u in self.units]

    def inventory_put(self, item):
        for i in self.inventory:
            for j in i:
                if j.name == item.name:
                    j.count += item.count
                    return
        self.inventory[0].append(item)

for i in os.listdir('abilities'):
    if i.endswith('.py'):
        exec(f'from abilities.{i[:-3]} import *')

pygame.init()
DMGFONT = pygame.font.SysFont('calibri', 30)


def load_anim(folder, file, parts):
    path = f'{folder}\\{file}'
    data = ast.literal_eval(open(path, 'r', encoding='utf-8').read())
    animator.load([data, parts])
    data['frames_ready'] = {}
    frames = animator.create_frames()
    center = (-1 * animator.X_OFFSET + TILE_SIZE * animator.TILE_SCALE, -1 * animator.Y_OFFSET + 3 * TILE_SIZE * animator.TILE_SCALE)
    for frame in frames:
        sc = pygame.Surface((TILE_SIZE * animator.TILE_SCALE * 5, TILE_SIZE * animator.TILE_SCALE * 5), pygame.SRCALPHA, 32)
        for i in frames[frame]:
            part = pygame.transform.scale(parts[i[0]], (int(parts[i[0]].get_width() * i[2]), int(parts[i[0]].get_height() * i[2])))
            if i[3]:
                part = pygame.transform.rotate(part, i[3])
            sc.blit(part, (center[0] + i[1][0] - part.get_width() // 2, center[1] + i[1][1] - part.get_height() // 2))
        sc = pygame.transform.scale(sc, (int(TILE_SIZE * 7.5), int(TILE_SIZE * 7.5)))
        data['frames_ready'][frame] = {False: sc, True: pygame.transform.flip(sc, True, False)}
    return data


class Unit:
    parts = {}
    animations = {}

    def __init__(self, data, level, **kwargs):
        self.game_id = ''
        self.texture_folder = search_unit_folder(data)
        self.data = ast.literal_eval(open(f'{self.texture_folder}\\unit.txt', 'r', encoding='utf-8').read())
        self.id = self.data['id']
        self.name = self.data['name']
        self.element = self.data['element'] if 'element' in self.data else 'normal'
        self.avatar = pygame.image.load(f'{self.texture_folder}\\avatar.png').convert_alpha()
        self.avatar = pygame.transform.scale(self.avatar, GUI_ICON_SIZE)
        if self.name not in Unit.parts:
            Unit.parts[self.name] = {i: pygame.image.load(f'{self.texture_folder}\\{i}').convert_alpha() for i in
                                     os.listdir(self.texture_folder) if i.endswith('.png')}
            Unit.animations[self.name] = {i.split('.txt')[0]: load_anim(self.texture_folder, i, Unit.parts[self.name])
                                          for i in os.listdir(self.texture_folder) if i.endswith('.txt') and not i == 'unit.txt'}
            if 'attack' not in Unit.animations[self.name]:
                Unit.animations[self.name]['attack'] = Unit.animations[self.name]['idle']
            if 'jump' not in Unit.animations[self.name]:
                Unit.animations[self.name]['jump'] = Unit.animations[self.name]['idle']
            if 'fall' not in Unit.animations[self.name]:
                Unit.animations[self.name]['fall'] = Unit.animations[self.name]['idle']
            if 'die' not in Unit.animations[self.name]:
                Unit.animations[self.name]['die'] = Unit.animations[self.name]['idle']
            if 'move' not in Unit.animations[self.name]:
                Unit.animations[self.name]['move'] = Unit.animations[self.name]['idle']
            if 'cast1' not in Unit.animations[self.name]:
                Unit.animations[self.name]['cast1'] = Unit.animations[self.name]['attack']
            if 'cast2' not in Unit.animations[self.name]:
                Unit.animations[self.name]['cast2'] = Unit.animations[self.name]['cast1']
            if 'cast3' not in Unit.animations[self.name]:
                Unit.animations[self.name]['cast3'] = Unit.animations[self.name]['cast1']
            if 'cast4' not in Unit.animations[self.name]:
                Unit.animations[self.name]['cast4'] = Unit.animations[self.name]['cast1']
        self.cur_anim = 'idle'
        self.next_anim = 'idle'
        self.anim_idx = 0
        self.anim_speed = 1
        self.level = level
        self.units = level.units
        self.dialogs = []

        self.hp = self.data['stats']['hp']
        self.mana = self.data['stats']['mana']
        self.dmg = DamageTable(self.data['stats']['dmg'])
        self.armor = DamageTable(self.data['stats']['armor'])
        self.movespeed = self.data['stats']['speed']
        self.attack_speed = self.data['stats']['attack_speed']
        self.sight = self.data['stats']['sight']
        self.accuracy = self.data['stats']['accuracy']
        self.multishot = self.data['stats']['multishot']

        self.melee = self.data['melee']
        self.canattack = self.data['canattack'] if 'canattack' in self.data else True
        if self.canattack:
            if 'attack' in self.data:
                if not self.melee:
                    self.data['attack']['size'] = Vector(self.data['attack']['size'])
            elif self.melee:
                self.data['attack'] = {"projectile": "sword.png", "radius": 1, "spawn_offset": (0, -1),
                                       "top_angle": 90, "bottom_angle": -45}
            else:
                self.data['attack'] = {"projectile": "orb.png", "speed": 40, "size": Vector(30, 30), "spawn_offset": (0, -1),
                                       "attack_frame": 40, "top_angle": 90, "bottom_angle": -45, "destroybyMapCollisions": 1,
                                       "stopbyMapCollisions": 1, "destroybyUnitCollisions": 1, "stopbyUnitCollisions": 1,
                                       "destroyAnimation": "orbDestroy"}
            if 'atability' not in self.data['attack']:
                self.data['attack']['atability'] = 'AttackAbility'

        self.size = Vector(self.data['stats']['size'])
        self.cords = Vector(kwargs['cords']) if 'cords' in kwargs else None
        self.team = 'enemy' if 'e' in kwargs and kwargs['e'] else kwargs['team'] if 'team' in kwargs else 'ally'
        self.flip = True if 'e' in kwargs else False
        self.particles = [Particles(**p) for p in self.data['particles']] if 'particles' in self.data else []
        self.canfly = self.data['canfly'] if 'canfly' in self.data else False
        self.canswim = self.data['canswim'] if 'canswim' in self.data else False
        self.speed = Vector()
        self.accel = Vector(0, GRAVITY) if not self.canfly else Vector()

        self.abilities = []
        self.ability_raws = self.data['abilities'] if 'abilities' in self.data else []
        self.ability_raw_examples = []
        if 'astats' not in self.data:
            self.data['astats'] = {"strength": 1, "radius": 1, "aduration": 1, "manacost": 1, "castspeed": 1, "reduction": 1, "super": 1}
        self.strength = self.data['astats']['strength']  # урон, сила дебаффов или баффов
        self.radius = self.data['astats']['radius']  # радиус способностей и аур
        self.aduration = self.data['astats']['aduration']  # длительность юнитов и пр.
        self.manacost = self.data['astats']['manacost']  # манакост
        self.castspeed = self.data['astats']['castspeed']  # скорость каста
        self.reduction = self.data['astats']['reduction']  # снижение кулдауна
        self.super = self.data['astats']['super']  # ой

        self.exp = 0
        self.perks = []
        self.modifiers = []
        self.maxhp, self.maxmana = self.hp, self.mana
        self.lasthp = [0, self.hp, None]
        self.tasks = []
        self.dmgvs = []
        self.ticks = 0
        self.status = 0
        self.aiallowed = True
        self.ai = AI(self)

        self.dead = False
        self.summoner = kwargs['summoner'] if 'summoner' in kwargs else None
        self.duration = kwargs['duration'] if 'duration' in kwargs else 0
        self.baseduration = self.duration
        self.canbecontrolled = self.data['canbecontrolled'] if 'canbecontrolled' in self.data else True
        self.baroffset = self.data['baroffset'] if 'baroffset' in self.data else (0, -(self.size.y+0.3))
        self.baroffset = (self.baroffset[0], self.baroffset[1]+(random.randint(0,200)-100)/1000)
        self.mousepos = None
        self.stats = UnitStats()
        self.drop = self.data['drop'] if 'drop' in self.data else {}
        self.reward = self.data['reward'] if 'reward' in self.data else 0

    # TODO: новые анимации и текстуры Zalgo

    def change_anim(self, anim, speed=1):
        if not self.cur_anim in ['die', 'fall']:
            self.next_anim = anim
            self.anim_speed = speed

    def tick(self, sc, pos):
        if self.ticks == 0:
            for i in self.ability_raws:
                abl = {'self': self}
                exec(f'ab={i[0]}(self)', globals(), abl)
                ab = abl['ab']
                self.ability_raw_examples.append(ab)
                if i[5] in ('passive', 'orb'):
                    self.abilities.append(ab)
                    ab.onAbilityStart()

        if not get_bit(self.status, 6) and self.level.selected_unit is not self and self.aiallowed:
            if self.ticks % 20 == 0:
                self.ai.think()
            self.ai.act()

        spp = self.speed + self.accel
        dcords = self.cords()
        if not spp.y == 0:
            if spp.y < 0:
                if self.level.find_upper_space(self, spp.y):
                    self.speed.y += self.accel.y
                    self.cords.y += self.speed.y
                    self.next_anim = 'jump'
                else:
                    self.speed.y = 0
            elif self.level.find_under_space(self, spp.y):
                self.speed.y += self.accel.y
                self.cords.y += self.speed.y
                self.next_anim = 'fall'
            else:
                self.speed.y = 0
        if not spp.x == 0:
            if spp.x < 0:
                if self.level.find_left_space(self, spp.x):
                    self.speed.x += self.accel.x
                    self.cords.x += self.speed.x
                else:
                    self.speed.x = 0
            elif self.level.find_right_space(self, spp.x):
                self.speed.x += self.accel.x
                self.cords.x += self.speed.x
            else:
                self.speed.x = 0
        if dcords != self.cords:
            dcords -= self.cords
            self.level.runa.stats.move(self, dcords.getlen())
        # Tasks help
        # die: ['die', cur_frame, last_frame], the animation stops on last_frame when reaches it
        # attack: ['attack', cur_frame, attack time, AttackAbility or its subclass instance]
        # ability: ['cast<num>', cur_frame, cast_time, abilityStart frame, cooldown, Ability subclass instance, num, ifstarted, animation, manacost]
        for i, task in enumerate(self.tasks):
            if task[0] == 'attack':
                aframes = Unit.animations[self.name]['attack']['len'] if Unit.animations[self.name]['attack']['len'] < task[2] else task[2]
                if task[1] < aframes:
                    if Unit.animations[self.name]['attack']['len'] > task[2]:
                        self.anim_speed = Unit.animations[self.name]['attack']['len'] / task[2]
                    if self.melee:
                        task[3].meleeAttack(task[1], aframes, self.anim_speed)
                    else:
                        task[3].rangedAttack(task[1], aframes, self.anim_speed)
                    self.next_anim = 'attack'
                    self.tasks[i][1] += 1
                elif task[1] < task[2]:
                    self.tasks[i][1] += 1
                else:
                    self.tasks.remove(task)
                    if self.melee:
                        task[3].destroy()
                    continue
            if task[0].startswith('cast'):
                if task[1] == 0:
                    task[5].onAbilityCastStart()
                    for mod in self.modifiers:
                        if PROVIDE_SPELL_CASTING in mod.provides:
                            mod.onAbilityCastStart(task[5])
                if task[1] < task[2]:
                    self.next_anim = task[8]
                    self.anim_speed = Unit.animations[self.name][task[8]]['len']/task[2]
                    self.tasks[i][1] += 1
                    if self.mana < self.tasks[i][9] / self.manacost:
                        self.tasks.remove(task)
                        continue
                    elif not task[7] and self.tasks[i][1] >= task[3]:
                        self.abilities.append(task[5])
                        self.tasks[i][7] = True
                        task[5].onAbilityStart()
                        self.level.runa.stats.cast(self, task[5])
                        self.mana -= self.tasks[i][9] / self.manacost
                        for mod in self.modifiers:
                            if PROVIDE_SPELL_STARTING in mod.provides:
                                mod.onAbilityStart(task[5])
                elif task[1] < task[4]:
                    self.tasks[i][1] += 1
                else:
                    self.tasks.remove(task)
                    continue
            if task[0] == 'die':
                self.next_anim = 'die'
                if task[1] < task[2]:
                    self.tasks[i][1] += 1
                else:
                    self.anim_idx = task[2]

        if not self.next_anim == self.cur_anim:
            self.cur_anim = self.next_anim
            self.anim_idx = 0
        if self.anim_idx >= Unit.animations[self.name][self.cur_anim]['len']:
            self.anim_idx = 0

        self.pick_drop()
        self.ticks += 1
        for i in self.abilities:
            i.tick()
        for i in self.modifiers:
            i.tick()
        self.change_status()

        if self.duration and self.ticks > self.duration * FPS:
            self.die(self)

    def blit(self, sc):
        mp, cs, ts = self.level.mp, self.level.camera_scale, self.level.tile_size
        if int(self.anim_idx) in Unit.animations[self.name][self.cur_anim]['frames_ready']:
            part = Unit.animations[self.name][self.cur_anim]['frames_ready'][int(self.anim_idx)][self.flip]
            part = pygame.transform.scale(part, (int(self.level.tile_size*5), int(self.level.tile_size*5)))
            sc.blit(part, (self.cords.x*ts + mp[0] - part.get_width() // 2, self.cords.y*ts + mp[1] - part.get_height()))
            # pygame.draw.rect(sc, RED, (int(self.cords.x-self.size.x//2)*ts + mp[0], int(self.cords.y-self.size.y+0.25)*ts + mp[1], self.size.x*ts, self.size.y*ts), 1)
            # pygame.draw.circle(sc, YELLANGE, (self.cords.x*ts+mp[0], self.cords.y*ts+mp[1]), 3)

        if self.particles:
            pcds = self.cords.x * self.level.tile_size + self.level.mp[0], self.cords.y * self.level.tile_size + self.level.mp[1]
            for p in self.particles:
                p.spawn(pcds, level_scale=self.level.camera_scale)
                for x, p in p.act(pcds):
                    sc.blit(x, p)
        self.anim_idx += self.anim_speed
        self.anim_speed = 1
        self.next_anim = 'idle'

    def blit_dmgvs(self, sc):
        cs = self.level.camera_scale
        mp = self.level.mp
        if self.lasthp[0] >= DAMAGE_BAR_TIME:
            self.lasthp = [0, self.hp, None]
        elif self.hp != self.lasthp[1] or self.lasthp[0] >= DAMAGE_BAR_FRESH_END:
            self.lasthp[0] += 1
            if self.lasthp[2] is None:
                self.lasthp[2] = self.level.gui.make_unit_bar(self)
            bar = self.lasthp[2].copy()
            if self.lasthp[0] >= DAMAGE_BAR_TRANSPARENT_START:
                bar.set_alpha(255*(DAMAGE_BAR_TIME-self.lasthp[0])/DAMAGE_BAR_TRANSPARENT_TIME)
            elif self.lasthp[0] >= DAMAGE_BAR_FRESH_START:
                bar = self.level.gui.make_fresh_from_bar(self, bar, (DAMAGE_BAR_FRESH_END-self.lasthp[0])/DAMAGE_BAR_FRESH_TIME)
            else:
                bar = self.level.gui.make_fresh_from_bar(self, bar, 1)
            bar = pygame.transform.smoothscale(bar, (int(bar.get_width()*self.level.camera_scale//3), int(bar.get_height()*self.level.camera_scale//3)))
            sc.blit(bar, ((self.cords.x+self.baroffset[0])*self.level.tile_size+mp[0]-bar.get_width()//2, (self.cords.y+self.baroffset[1])*self.level.tile_size+mp[1]-bar.get_height()//2))

        for i, v in enumerate(self.dmgvs):
            if v[2] >= DAMAGE_VALUE_TIME:
                self.dmgvs.remove(v)
            else:
                if v[2] >= DAMAGE_VALUE_TRANSPARENT_START:
                    v[0].set_alpha(255*(DAMAGE_VALUE_TIME-self.dmgvs[i][2])/DAMAGE_VALUE_TRANSPARENT_TIME)
                self.dmgvs[i][2] += 1
                sc.blit(v[0], ((self.cords.x*TILE_SIZE+v[1][0])*cs+mp[0]-v[0].get_width()//2, (self.cords.y*TILE_SIZE+v[1][1])*cs+mp[1]-v[0].get_height()//2-self.dmgvs[i][2]*DAMAGE_VALUE_VSPEED*cs))

    def applyDamage(self, caster, dmg):
        if self.dead:
            return
        n = dmg['n'] * 0.5 ** (self.armor['n'] / 25)
        a = dmg['a'] * (100-self.armor['a'])/100
        f = dmg['f'] * (100-self.armor['f'])/100
        w = dmg['w'] * (100-self.armor['w'])/100
        e = dmg['e'] * (100-self.armor['e'])/100
        d = dmg['d'] * (100-self.armor['d'])/100
        l = dmg['l'] * (100-self.armor['l'])/100
        dmgv = DamageTable(*(n, a, w, f, e, d, l))
        dmgs = dmgv.sum()
        if dmgs > 0:
            last = self.hp if self.lasthp[0] >= DAMAGE_BAR_FRESH_END else self.lasthp[1]
            self.lasthp = [0, last, None]
            self.hp -= dmgs
            self.level.runa.stats.dmg(caster, self, dmgs, dmg.sum())
            for i, v in dmgv:
                v = int(v)
                if v > 0:
                    self.dmgvs.append([DMGFONT.render(str(v), True, DMGCOLORS[i]), (random.randint(0, 2*TILE_SIZE)-TILE_SIZE, random.randint(0, 2*TILE_SIZE)-TILE_SIZE-self.size.y*TILE_SIZE), 0])
                elif v < 0:
                    self.dmgvs.append([DMGFONT.render(str(v), True, DMGCOLORS['h']), (random.randint(0, 2*TILE_SIZE)-TILE_SIZE, random.randint(0, 2*TILE_SIZE)-TILE_SIZE-self.size.y*TILE_SIZE), 0])
            if self.hp <= 0:
                self.die(caster)

    def die(self, caster):
        if self.dead:
            return
        self.level.runa.stats.dead(caster, self)
        if caster.team == 'ally' and self.team != 'ally':
            self.level.sp.add(int(caster.super), caster.element)
            self.level.gui.recolor()
            self.level.runa.exp += self.reward
            caster.exp += self.reward
        if self != caster:
            self.get_drop()
        self.hp = 0
        self.dead = True
        self.status = STATUS_DEAD
        if self.canfly:
            self.canfly = False
            self.accel.y += GRAVITY
        self.tasks = [['die', 0, Unit.animations[self.name]['die']['len']-1]]
        for i in self.abilities:
            i.onOwnerDied()
        for i in self.modifiers:
            if i.removeOnDeath:
                i.destroy()
        self.recount((), all=True)
        if self.level.selected_unit is self:
            select_next_unit(self.level, pygame.mouse.get_pos())

    def canmove(self):
        if get_bit(self.status, 5):
            return False
        for i in self.tasks:
            if i[0] == 'attack':
                if i[1] < min((Unit.animations[self.name]['attack']['len'], i[2])):
                    return False
            elif i[0].startswith('cast'):
                if i[1] < i[2]:
                    return False
        return True

    def canflip(self):
        if get_bit(self.status, 6):
            return False
        return True

    def attack(self):
        if not self.canattack or self.ticks < 60:
            return
        if get_bit(self.status, 3):
            return
        for i in self.tasks:
            if i[0] == 'attack':
                return
            elif i[0].startswith('cast') and i[1] < i[2]:
                return
        abl = {'self': self}
        exec(f'ab={self.data["attack"]["atability"]}(self)', globals(), abl)
        ab = abl['ab']
        self.tasks.append(['attack', 0, 200 * FPS // self.attack_speed, ab])
        self.abilities.append(ab)

    def cast(self, num):
        if get_bit(self.status, 4):
            return
        if num > len(self.ability_raws):
            return
        if self.mana < self.ability_raws[num-1][6] / self.manacost:
            return
        for i in self.tasks:
            if i[0] == 'attack' and i[1] < min((Unit.animations[self.name]['attack']['len'], i[2])):
                return
            elif i[0] == f'cast{num}':
                return
            elif i[0].startswith('cast') and i[1] < i[2]:
                return
        abl = {'self': self}
        exec(f'ab={self.ability_raws[num-1][0]}(self)', globals(), abl)
        ab = abl['ab']
        if ab.type not in ('passive', 'orb'):
            self.tasks.append([f'cast{num}', 0, self.ability_raws[num-1][2]*FPS//self.castspeed, self.ability_raws[num-1][3]*FPS//self.castspeed, self.ability_raws[num-1][1]*FPS//self.reduction, ab, num, 0, self.ability_raws[num-1][4], self.ability_raws[num-1][6]])

    def jump(self):
        if get_bit(self.status, 6):
            return
        if not self.level.find_under_space(self):
            self.speed.y += JUMP_SPEED
            self.level.runa.stats.jump(self)
            self.change_anim('jump')

    def flyup(self):
        if not self.canfly or not self.canmove():
            return
        msps = -self.movespeed / FPS
        self.speed.y += msps * FLYING_ACCEL_TO_SPEED  # ось y инвертирована
        if self.speed.y < msps:
            self.speed.y = msps
        self.change_anim('jump')

    def flydown(self):
        if not self.canfly or not self.canmove():
            return
        msps = self.movespeed / FPS
        self.speed.y += msps * FLYING_ACCEL_TO_SPEED  # ось y инвертирована
        if self.speed.y > msps:
            self.speed.y = msps
        self.change_anim('fall')

    def moveleft(self):
        if self.canmove():
            msps = self.movespeed / FPS
            if self.canfly:
                self.speed.x -= msps * FLYING_ACCEL_TO_SPEED
                if self.speed.x < -msps:
                    self.speed.x = -msps
            elif self.level.find_left_space(self, -msps):
                self.cords.x -= msps
                self.level.runa.stats.move(self, msps)
            self.change_anim('move', self.movespeed / 6)
        if self.canflip():
            self.flip = True

    def moveright(self):
        if self.canmove():
            msps = self.movespeed / FPS
            if self.canfly:
                self.speed.x += msps * FLYING_ACCEL_TO_SPEED
                if self.speed.x > msps:
                    self.speed.x = msps
            elif self.level.find_right_space(self, msps):
                self.cords.x += msps
                self.level.runa.stats.move(self, msps)
            self.change_anim('move', self.movespeed / 6)
        if self.canflip():
            self.flip = False

    def addModifier(self, mod, ability, duration):
        mdl = {'self': self, 'ability': ability, 'duration': duration}
        exec(f'md={mod}(self, ability, duration)', globals(), mdl)
        md = mdl['md']
        self.modifiers.append(md)
        self.recount(md.provides.provides)

    def removeModifier(self, mod, caster, single=False):
        r = []
        for i in self.modifiers:
            if i.name == mod and i.ability.caster == caster:
                r += list(i.provides.provides)
                i.destroy(r=False)
                if single:
                    break
        self.recount(r)
                    
    def recount(self, prs, all=False):
        if isinstance(prs, Provides):
            prs = prs.provides
        prs = [clear_bit(i, 0) for i in prs]

        if all or PROVIDE_HP in prs:
            s, sp = find_provides(self, PROVIDE_HP, PROVIDE_HP_PERCENT)
            hp = (self.data['stats']['hp'] + sum(s.values())) * (sum(sp.values())/100+1)
            oldmaxhp = self.maxhp
            self.maxhp = hp if hp > MIN_HP else MIN_HP
            self.hp = self.maxhp * self.hp / oldmaxhp

        if all or PROVIDE_MANA in prs:
            s, sp = find_provides(self, PROVIDE_MANA, PROVIDE_MANA_PERCENT)
            mana = (self.data['stats']['mana'] + sum(s.values())) * (sum(sp.values())/100+1)
            oldmaxmana = self.maxmana
            self.maxmana = mana if mana > MIN_MANA else MIN_MANA
            self.mana = self.maxmana * self.mana / oldmaxmana

        if all or PROVIDE_SPEED in prs:
            s, sp = find_provides(self, PROVIDE_SPEED, PROVIDE_SPEED_PERCENT)
            speed = (self.data['stats']['speed'] + sum(s.values())) * (sum(sp.values()) / 100 + 1)
            self.movespeed = speed if speed > MIN_SPEED else MIN_SPEED

        if all or PROVIDE_SIGHT in prs:
            s, sp = find_provides(self, PROVIDE_SIGHT, PROVIDE_SIGHT_PERCENT)
            sight = (self.data['stats']['sight'] + sum(s.values())) * (sum(sp.values()) / 100 + 1)
            self.sight = sight if sight > MIN_SIGHT else MIN_SIGHT

        if all or PROVIDE_ARMOR in prs:
            s, sp = find_provides(self, PROVIDE_ARMOR, PROVIDE_ARMOR_PERCENT)
            armor = DamageTable(self.data['stats']['armor']) + deepsum(list(s.values())) if s else DamageTable(self.data['stats']['armor'])
            self.armor = armor * (deepsum(list(sp.values())) / 100 + 1) if sp else armor

        if all or PROVIDE_SIZE in prs:
            s, sp = find_provides(self, PROVIDE_SIZE, PROVIDE_SIZE_PERCENT)
            size = deepmax(list(s.values())) if s else Vector(self.data['stats']['size'])
            kef = sum(sp.values()) / 100 + 1
            kef = kef if kef > MIN_SIZE_PERCENT else MIN_SIZE_PERCENT
            self.size = size * kef

        if all or PROVIDE_DMG in prs:
            s, sp = find_provides(self, PROVIDE_DMG, PROVIDE_DMG_PERCENT)
            dmg = DamageTable(self.data['stats']['dmg']) + deepsum(list(s.values())) if s else DamageTable(self.data['stats']['dmg'])
            self.dmg = dmg * (deepsum(list(sp.values())) / 100 + 1) if sp else dmg

        if all or PROVIDE_ATTACK_SPEED in prs:
            s, sp = find_provides(self, PROVIDE_ATTACK_SPEED, PROVIDE_ATTACK_SPEED_PERCENT)
            aspeed = (self.data['stats']['attack_speed'] + sum(s.values())) * (sum(sp.values()) / 100 + 1)
            self.attack_speed = aspeed if aspeed > MIN_ATTACK_SPEED else MIN_ATTACK_SPEED

        if all or PROVIDE_ACCURACY in prs:
            s, sp = find_provides(self, PROVIDE_ACCURACY, PROVIDE_ACCURACY)
            accuracy = (self.data['stats']['accuracy'] + sum(s.values())) * (sum(sp.values()) / 100 + 1)
            self.accuracy = accuracy

        if all or PROVIDE_MULTISHOT in prs:
            s, sp = find_provides(self, PROVIDE_MULTISHOT, PROVIDE_MULTISHOT_PERCENT)
            mshot = (self.data['stats']['multishot'] + sum(s.values())) * (sum(sp.values()) / 100 + 1)
            self.multishot = mshot

        if all or PROVIDE_STRENGTH in prs:
            s, sp = find_provides(self, PROVIDE_STRENGTH, PROVIDE_STRENGTH_PERCENT)
            strength = (self.data['astats']['strength'] + sum(s.values())) * (sum(sp.values()) / 100 + 1)
            self.strength = strength

        if all or PROVIDE_RADIUS in prs:
            s, sp = find_provides(self, PROVIDE_RADIUS, PROVIDE_RADIUS_PERCENT)
            radius = (self.data['astats']['radius'] + sum(s.values())) * (sum(sp.values()) / 100 + 1)
            self.radius = radius

        if all or PROVIDE_ADURATION in prs:
            s, sp = find_provides(self, PROVIDE_ADURATION, PROVIDE_ADURATION_PERCENT)
            aduration = (self.data['astats']['aduration'] + sum(s.values())) * (sum(sp.values()) / 100 + 1)
            self.aduration = aduration

        if all or PROVIDE_MANACOST in prs:
            s, sp = find_provides(self, PROVIDE_MANACOST, PROVIDE_MANACOST_PERCENT)
            manacost = (self.data['astats']['manacost'] + sum(s.values())) * (sum(sp.values()) / 100 + 1)
            self.manacost = manacost

        if all or PROVIDE_CASTSPEED in prs:
            s, sp = find_provides(self, PROVIDE_CASTSPEED, PROVIDE_CASTSPEED_PERCENT)
            castspeed = (self.data['astats']['castspeed'] + sum(s.values())) * (sum(sp.values()) / 100 + 1)
            self.castspeed = castspeed

        if all or PROVIDE_REDUCTION in prs:
            s, sp = find_provides(self, PROVIDE_REDUCTION, PROVIDE_REDUCTION_PERCENT)
            reduction = (self.data['astats']['reduction'] + sum(s.values())) * (sum(sp.values()) / 100 + 1)
            self.reduction = reduction

        if all or PROVIDE_SUPER in prs:
            s, sp = find_provides(self, PROVIDE_SUPER, PROVIDE_SUPER_PERCENT)
            spr = (self.data['astats']['super'] + sum(s.values())) * (sum(sp.values()) / 100 + 1)
            self.super = spr
        # TODO: attack, attacktype

    def summon(self, unit_name, duration=0, team=None, cords=None, centercords=True):
        if team is None:
            team = self.team
        if cords is None:
            cords = self.cords
        u = Unit(unit_name, self.level, summoner=self, duration=duration, team=team)
        u.cords = cords()
        if centercords:
            u.cords.y += u.size.y/2
        self.units.append(u)
        return u

    def change_status(self):
        if self.dead:
            return
        status = 0
        for mod in self.modifiers:
            if PROVIDE_STATUS in mod.provides:
                status |= mod.provides[PROVIDE_STATUS]
        diff = self.status ^ status
        if get_bit(diff, 2):
            if get_bit(status, 2):           # 2 - passsives off
                for i in self.abilities:
                    if i.type == 'passive':
                        i.ability_off()
            else:                            # ~2 - раssives on
                for i in self.abilities:
                    if i.type == 'passive':
                        i.ability_on()
        if get_bit(diff, 3):                 # 3 attack
            for i, task in enumerate(self.tasks):
                if task[0] == 'attack':
                    if not task[3]:
                        self.tasks.remove(task)
        if get_bit(diff, 4):                 # 4 abs
            for i, task in enumerate(self.tasks):
                if task[0].startswith('cast'):
                    if not task[7]:
                        if task[1] > 0:
                            task[5].onAbilityCastInterrupted()
                        self.tasks.remove(task)
        if get_bit(diff, 5):                 # 5 move
            if self.canfly:
                self.speed /= 2
        self.status = status

    def boxcollide(self, box):
        if box[0] < self.cords.x + self.size.x / 2 and box[1] > self.cords.x - self.size.x / 2 and box[2] < self.cords.y and box[3] > self.cords.y - self.size.y:
            return True
        return False

    def cordcenter(self):
        return Vector(self.cords.x, self.cords.y - self.size.y / 2)

    def hitbox(self):
        return self.cords.x-self.size.x/2, self.cords.x+self.size.x/2, self.cords.y-self.size.y, self.cords.y

    def unitrange(self, unit):
        return math.sqrt((unit.cords.x-self.cords.x)**2+(unit.cords.y-self.cords.y)**2)

    def save(self):
        return self.name, self.game_id, self.exp, self.perks, self.stats.save(), self.aiallowed

    def load(self, game_id, exp, perks, stats, aiallowed):
        self.game_id = game_id
        self.exp = exp
        self.perks = perks
        self.stats.load(stats)
        self.aiallowed = aiallowed
        return self

    def get_drop(self):
        if self.team == 'ally':
            return
        for k, v in self.drop.items():
            count = v if type(v) == int else int(v) if '-' not in v else random.randint(*map(int, v.split('-')))
            if count:
                self.level.dropped.append([Item(k, self.level, count), self.cords])

    def pick_drop(self):
        if get_bit(self.status, 6):
            return
        for i in self.level.dropped:
            d, cords = i
            if math.sqrt((cords.x-self.cords.x)**2+(cords.y-self.cords.y)**2) <= 1:
                self.level.runa.inventory_put(d)
                self.level.dropped.remove(i)

